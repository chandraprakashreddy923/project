/*
 * INTEL CONFIDENTIAL
 *
 * Copyright 2020 Intel Corporation
 *
 * This software and the related documents are Intel copyrighted materials,
 * and your use of them is governed by the express license under which they
 * were provided to you (License). Unless the License provides otherwise, you
 * may not use, modify, copy, publish, distribute, disclose or transmit this
 * software or the related documents without Intel's prior written permission.
 *
 * This software and the related documents are provided as is, with no express
 * or implied warranties, other than those that are expressly stated in the
 * License.
 */

#include <unistd.h>
#include <time.h>
#include "config.h"
#include "bzm_common.h"
#include "../util.h"
#include "reg.h"
#include "cfg.h"
#include "common.h"
#include "utils.h"
#include "test.h"
#include "../oem/mcu.h"


extern bzm_paramslist bzm_params;



struct timespec t_start_time= {0,0}, t_end_time= {0,0};
double total_execution_time;

void t_starttime();
void t_endtime();


teststruct test_custom[] =
{
		{}, //Reserved
		{test_evb_powercycle, "test_evb_powercycle"}, //1
		{test_ldo_off, "test_ldo_off"},  //2
		{test_ldo_on, "test_ldo_on"}, //3
		{test_uart_notch_write_reg, "test_uart_notch_write_reg"}, //4
		{test_uart_notch_read_reg, "test_uart_notch_read_reg"},  //5
		{test_engine_read_reg,"test_engine_read_reg"},  //6
		{test_engine_write_reg,"test_engine_write_reg"},  //7
		{test_noop_without_asicreset, "test_noop_without_asicreset"}, //8
		{test_pll_lock_stress, "test_pll_lock_stress"}, //9
		{test_notch_register_dump, "test_notch_register_dump"}, //10
		{test_engine_register_dump, "test_engine_register_dump"}, //11
		{test_Idle1_Engines_NotOutofReset, "test_Idle1_Engines_NotOutofReset"}, //12
		{test_Idle2_Engines_AfterClockUngate, "test_Idle2_Engines_AfterClockUngate"}, //idle 2  -13


#if 0
		{test_open_close,"test_open_close"}, //1


		{test_notch_read_reg,"test_notch_read_reg"}, //2
		{test_notch_write_reg,"test_notch_write_reg"}, //3
		{test_engine_read_reg,"test_engine_read_reg"},//4
		{test_engine_write_reg,"test_engine_write_reg"}, //5
		{test_read_ErrorLog,"test_read_ErrorLog"}, //6
		{test_pll_enable,"test_pll_enable"},//7
		{test_pll_disable,"test_pll_disable"},//8
		{test_mcu_set_voltage,"test_mcu_set_voltage"}, //9
		{test_set_engine_fastclk_frequency,"test_set_engine_fastclk_frequency"}, //10
		{test_engine_broadcast_write_reg, "test_engine_broadcast_write_reg"},//11
		{test_engine_broadcast_write_reg_per_asic,"test_engine_broadcast_write_reg_per_asic"},//12
		{test_AFactor_IdleTime_Engines_NotOutofReset_PLLDisable,"test_AFactor_IdleTime_Engines_NotOutofReset_PLLDisable"}, //13
		{test_AFactor_IdleTime_Engines_AfterReset_PLLEnable,"test_AFactor_IdleTime_Engines_AfterReset_PLLEnable"}, //14
		{test_AFactor_IdleTime_Engines_AfterClockUngate,"test_AFactor_IdleTime_Engines_AfterClockUngate"}, //15
		{test_read_all_registers,"test_read_all_registers"},//16
		{test_mcu_getinfo,"test_mcu_getinfo"},//17
		{test_asic_reset,"test_asic_reset"},//18
		{test_RDS, "test_RDS"}, //19
		{test_RDS_Powerstack, "test_RDS_Powerstack"},//20
		{test_AFactor_IdleTime_Engines_BeforeSoftReset, "test_AFactor_IdleTime_Engines_BeforeSoftReset"},//21
		{test_AFactor_IdleTime_Engines_AfterSoftReset, "test_AFactor_IdleTime_Engines_AfterSoftReset"}, //22
#endif
};


teststruct test_bzm_presilicon[] =
{
		{}, //Reserved

		{test_noop, "test_noop"}, //1
		{test_loopback, "test_loopback"},
		{test_register_read_defaultvalue, "test_register_read_defaultvalue"},

		{test_tdm_jobsubmit_with_writejobcmd, "test_tdm_jobsubmit_with_writejobcmd"},
		{test_tdm_jobsubmit_with_writeregcmd, "test_tdm_jobsubmit_with_writeregcmd"},
		{test_tdm_jobsubmit_with_multicastwrite, "test_tdm_jobsubmit_with_multicastwrite"},

		{test_nontdm_jobsubmit_with_writejobcmd_frf0, "test_nontdm_jobsubmit_with_writejobcmd_frf0"},

#if 0
		{test_loopback, "test_loopback"}, //2
		{test_writereg,"test_writereg"},
		{test_multicastwrite,"test_multicastwrite"},
		{test_broadcastwrite,"test_broadcastwrite"},

		{test_random_asic_id,"P1.1 - test_random_asic_id"}, // P1.1
		{test_nontdm_jobsubmit_with_multicastwrite_frf1,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf1"}, // P1.2

		{test_nontdm_jobsubmit_with_multicastwrite_frf0,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf0"}, // P1.2

		{test_tdm_jobsubmit_with_multicastwrite,"P1.4/P1.19 - test_tdm_jobsubmit_with_multicastwrite"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writejobcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writejobcmd"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writeregcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writeregcmd"}, // P1.4, P1.19

		{test_register_access,"P1.3 - test_register_access"}, // P1.3

		{test_soft_reset,"P1.5 - test_soft_reset"}, // P1.5
		{test_broadcast_multicast_stress,"P1.6 - test_broadcast_multicast_stress"},// P1.6
		{test_max_loopback,"P1.7 - test_max_loopback"}, // P1.7
		{test_negative_error_invalid_offset, "P1.9 - test_negative_error_invalid_offset"}, // P1.9
		{test_thermal_trip,"P1.11 - test_thermal_trip"},// P1.11

		{test_tdm_invalid_broadcast_opcode, "P1a.8 - test_tdm_invalid_broadcast_opcode"},// P1a.8
		{test_tdm_with_Noop_sync, "P1a.9 - test_tdm_with_Noop_sync"},                                      // P1a.9
		{test_tdm_with_Noop_async, "P1a.9 - test_tdm_with_Noop_async"},                                    // P1a.9
		{test_tdm_with_Noop_broadcast_async, "P1b.1 - test_tdm_with_Noop_broadcast_async"},    //  P1b.1
		{test_pll_registers_progammable,"P1b.7 - test_pll_registers_progammable"},              // P1b.7

		{test_error_scenario_gt_42_read_write_read, "P1b.14 - test_error_scenario_gt_42_read_write_read"}, //P1b.14
		{test_error_scenario_gt_42_write_read, "P1b.15 - test_error_scenario_gt_42_write_read"}, // P1b.15
		{test_engine_clk_gated_CR_access, "P1b.17 - test_engine_clk_gated_CR_access"},
		{test_engineClkGated_ProgramValidJob, "P1b.18 - test_engineClkGated_ProgramValidJob"},

		{test_loadSpecificEngine_ReadResultRegsFromWrongEngine, "P1b.19 - test_loadSpecificEngine_ReadResultRegsFromWrongEngine"},
		{test_engineClkGate_LoadJob_ReadResultRegs, "P1b.20 - test_engineClkGate_LoadJob_ReadResultRegs"},

		{test_tdm_invalid_broadcast_opcode_muliticast,"P2.3 - test_tdm_invalid_broadcast_opcode_muliticast"},  // p2.3
		{test_tdm_data_corruption,"P1a.5 - test_tdm_data_corruption"},               // P1a.5

		{test_cancel_job_mode,"P1a.1 - test_cancel_job_mode"}, // P1a.1
		{test_negative_error_with_9thbit_set0, "P1.14 - test_negative_error_with_9thbit_set0"}, // P1.14

		{test_tdm_asic_reset_stress, "test_tdm_asic_reset_stress"},
		{test_tdm_engine_softreset_stress,"test_tdm_engine_softreset_stress"},
		{test_enable_disable_voltage_sensor,"test_enable_disable_voltage_sensor"},
		{test_tdm_delay_counter_variation,"test_tdm_delay_counter_variation"},
		{test_nontdm_resultfsm_fifofull_check,"test_nontdm_resultfsm_fifofull_check"},
		{test_tdm_packet_enable_disable, "test_tdm_packet_enable_disable"},

		{test_WriteJob_ReadResultThread_TDM_Enabled_PnP,"[PnP] [TDM-En] Write-Job, Read-Result Performance Test"},
		{test_stop_bit_validation,"P1a.7 - UART Stop Bit Validation - TDM Enable"},
		{test_FPGA_Baudrate_validation,"P1a.6 - TDM with varied BAUD rate for each ASIC"},
		{test_performance,"P1a.6,P1a.7,P1a.11 - UART Performance - TDM Enable"},

		{test_result_overflow,"P1a.4 - test_result_overflow"},                                  // P1a.4
#endif

};



teststruct test_1x129[] =
{
		{}, //Reserved

		{test_noop, "test_noop"}, //1
#if 0
		{test_loopback, "test_loopback"}, //2

		{test_writereg,"test_writereg"},
		{test_multicastwrite,"test_multicastwrite"},
		{test_broadcastwrite,"test_broadcastwrite"},

		{test_nontdm_jobsubmit_with_multicastwrite_frf1,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf1"}, // P1.2

		{test_nontdm_jobsubmit_with_multicastwrite_frf0,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf0"}, // P1.2

		{test_tdm_jobsubmit_with_multicastwrite,"P1.4/P1.19 - test_tdm_jobsubmit_with_multicastwrite"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writejobcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writejobcmd"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writeregcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writeregcmd"}, // P1.4, P1.19

		{test_register_access,"P1.3 - test_register_access"}, // P1.3
		{test_soft_reset,"P1.5 - test_soft_reset"}, // P1.5
		{test_broadcast_multicast_stress,"P1.6 - test_broadcast_multicast_stress"},// P1.6
		{test_max_loopback,"P1.7 - test_max_loopback"}, // P1.7

		{test_tdm_invalid_broadcast_opcode, "P1a.8 - test_tdm_invalid_broadcast_opcode"},// P1a.8
		{test_tdm_with_Noop_sync, "P1a.9 - test_tdm_with_Noop_sync"},                                      // P1a.9
		{test_tdm_with_Noop_async, "P1a.9 - test_tdm_with_Noop_async"},                                    // P1a.9
		{test_tdm_with_Noop_broadcast_async, "P1b.1 - test_tdm_with_Noop_broadcast_async"},    //  P1b.1

		{test_tdm_invalid_broadcast_opcode_muliticast,"P2.3 - test_tdm_invalid_broadcast_opcode_muliticast"},  // p2.3

		{test_loadJobWithMulticastWrite_readresult,"P1a.2 - test_loadJobWithMulticastWrite_readresult"},  // P1a.2
		{test_loadJobWithWritereg_readresult,"P1a.3 - test_loadJobWithWritereg_readresult"},// P1a.3
		{test_TDM_with_results_on_every_TDM_slot,"P1a.10 - test_TDM_with_results_on_every_TDM_slot"},     // P1a.10
		{test_tdm_result_disabled, "P1b.2 - test_tdm_result_disabled"},

		{test_tdm_asic_reset_stress, "test_tdm_asic_reset_stress"},
		{test_tdm_engine_softreset_stress,"test_tdm_engine_softreset_stress"},
		{test_enable_disable_voltage_sensor,"test_enable_disable_voltage_sensor"},
		{test_tdm_delay_counter_variation,"test_tdm_delay_counter_variation"},
		{test_nontdm_resultfsm_fifofull_check,"test_nontdm_resultfsm_fifofull_check"},


		{test_WriteJob_ReadResultThread_TDM_Enabled_PnP,"[PnP] [TDM-En] Write-Job, Read-Result Performance Test"},
		{test_stop_bit_validation,"P1a.7 - UART Stop Bit Validation - TDM Enable"},
		{test_FPGA_Baudrate_validation,"P1a.6 - TDM with varied BAUD rate for each ASIC"},
		{test_performance,"P1a.6,P1a.7,P1a.11 - UART Performance - TDM Enable"},
		{test_result_overflow,"P1a.4 - test_result_overflow"},                                  // P1a.4

#endif
};


teststruct test_2x129[] =
{
		{}, //Reserved

		{test_noop, "test_noop"}, //1
#if 0
		{test_loopback, "test_loopback"}, //2

		{test_writereg,"test_writereg"},
		{test_multicastwrite,"test_multicastwrite"},
		{test_broadcastwrite,"test_broadcastwrite"},
		{test_nontdm_jobsubmit_with_multicastwrite_frf1,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf1"}, // P1.2

		{test_nontdm_jobsubmit_with_multicastwrite_frf0,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf0"}, // P1.2

		{test_tdm_jobsubmit_with_multicastwrite,"P1.4/P1.19 - test_tdm_jobsubmit_with_multicastwrite"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writejobcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writejobcmd"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writeregcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writeregcmd"}, // P1.4, P1.19

		{test_register_access,"P1.3 - test_register_access"}, // P1.3
		{test_soft_reset,"P1.5 - test_soft_reset"}, // P1.5
		{test_broadcast_multicast_stress,"P1.6 - test_broadcast_multicast_stress"},// P1.6
		{test_max_loopback,"P1.7 - test_max_loopback"}, // P1.7

		{test_tdm_invalid_broadcast_opcode, "P1a.8 - test_tdm_invalid_broadcast_opcode"},// P1a.8
		{test_tdm_with_Noop_sync, "P1a.9 - test_tdm_with_Noop_sync"},                                      // P1a.9
		{test_tdm_with_Noop_async, "P1a.9 - test_tdm_with_Noop_async"},                                    // P1a.9
		{test_tdm_with_Noop_broadcast_async, "P1b.1 - test_tdm_with_Noop_broadcast_async"},    //  P1b.1

		{test_tdm_invalid_broadcast_opcode_muliticast,"P2.3 - test_tdm_invalid_broadcast_opcode_muliticast"},  // p2.3

		{test_loadJobWithMulticastWrite_readresult,"P1a.2 - test_loadJobWithMulticastWrite_readresult"},  // P1a.2
		{test_loadJobWithWritereg_readresult,"P1a.3 - test_loadJobWithWritereg_readresult"},// P1a.3
		{test_TDM_with_results_on_every_TDM_slot,"P1a.10 - test_TDM_with_results_on_every_TDM_slot"},     // P1a.10
		{test_tdm_result_disabled, "P1b.2 - test_tdm_result_disabled"},

		{test_tdm_asic_reset_stress, "test_tdm_asic_reset_stress"},
		{test_tdm_engine_softreset_stress,"test_tdm_engine_softreset_stress"},
		{test_enable_disable_voltage_sensor,"test_enable_disable_voltage_sensor"},
		{test_tdm_delay_counter_variation,"test_tdm_delay_counter_variation"},
		{test_nontdm_resultfsm_fifofull_check,"test_nontdm_resultfsm_fifofull_check"},

		{test_WriteJob_ReadResultThread_TDM_Enabled_PnP,"[PnP] [TDM-En] Write-Job, Read-Result Performance Test"},
		{test_stop_bit_validation,"P1a.7 - UART Stop Bit Validation - TDM Enable"},
		{test_FPGA_Baudrate_validation,"P1a.6 - TDM with varied BAUD rate for each ASIC"},
		{test_performance,"P1a.6,P1a.7,P1a.11 - UART Performance - TDM Enable"},
		{test_result_overflow,"P1a.4 - test_result_overflow"},                                  // P1a.4
#endif
};

teststruct test_100x1[] =
{
		{}, //Reserved

		{test_noop, "test_noop"}, //1
#if 0
		{test_loopback, "test_loopback"}, //2

		{test_writereg,"test_writereg"},
		{test_multicastwrite,"test_multicastwrite"},
		{test_broadcastwrite,"test_broadcastwrite"},

		{test_nontdm_jobsubmit_with_multicastwrite_frf1,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf1"}, // P1.2

		{test_nontdm_jobsubmit_with_multicastwrite_frf0,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf0"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf0"}, // P1.2

		{test_tdm_jobsubmit_with_multicastwrite,"P1.4/P1.19 - test_tdm_jobsubmit_with_multicastwrite"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writejobcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writejobcmd"}, // P1.4, P1.19
		{test_tdm_jobsubmit_with_writeregcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writeregcmd"}, // P1.4, P1.19

		{test_register_access,"P1.3 - test_register_access"}, // P1.3
		{test_soft_reset,"P1.5 - test_soft_reset"}, // P1.5
		{test_broadcast_multicast_stress,"P1.6 - test_broadcast_multicast_stress"},// P1.6
		{test_max_loopback,"P1.7 - test_max_loopback"}, // P1.7

		{test_tdm_invalid_broadcast_opcode, "P1a.8 - test_tdm_invalid_broadcast_opcode"},// P1a.8
		{test_tdm_with_Noop_sync, "P1a.9 - test_tdm_with_Noop_sync"},                                      // P1a.9
		{test_tdm_with_Noop_async, "P1a.9 - test_tdm_with_Noop_async"},                                    // P1a.9
		{test_tdm_with_Noop_broadcast_async, "P1b.1 - test_tdm_with_Noop_broadcast_async"},    //  P1b.1

		{test_tdm_invalid_broadcast_opcode_muliticast,"P2.3 - test_tdm_invalid_broadcast_opcode_muliticast"},  // p2.3


		{test_asic_asic_delay_tdm_delay_calibrator, "P1b.3 - test_asic_asic_delay_tdm_delay_calibrator"},  // P1b.3

		{test_tdm_asic_reset_stress, "test_tdm_asic_reset_stress"},
		{test_tdm_engine_softreset_stress,"test_tdm_engine_softreset_stress"},
		{test_enable_disable_voltage_sensor,"test_enable_disable_voltage_sensor"},
		{test_tdm_delay_counter_variation,"test_tdm_delay_counter_variation"},


		{test_WriteJob_ReadResultThread_TDM_Enabled_PnP,"[PnP] [TDM-En] Write-Job, Read-Result Performance Test"},
		{test_stop_bit_validation,"P1a.7 - UART Stop Bit Validation - TDM Enable"},
		{test_FPGA_Baudrate_validation,"P1a.6 - TDM with varied BAUD rate for each ASIC"},
		{test_performance,"P1a.6,P1a.7,P1a.11 - UART Performance - TDM Enable"},
#endif
};



teststruct test_bzm_postsilicon[] =
{
		{}, //Reserved
		{test_noop, "test_noop"}, //1
		{test_loopback, "test_loopback"}, //2
		{test_register_read_defaultvalue, "test_register_read_defaultvalue"}, //3
		{test_nontdm_jobsubmit_with_multicastwrite_frf1, "test_nontdm_jobsubmit_with_multicastwrite_frf1"}, //4
		{test_nontdm_jobsubmit_with_writejobcmd_frf1, "test_nontdm_jobsubmit_with_writejobcmd_frf1"}, //5
		{test_nontdm_jobsubmit_with_writeregcmd_frf1, "test_nontdm_jobsubmit_with_writeregcmd_frf1"}, //6
		{test_nontdm_jobsubmit_with_multicastwrite_frf0, "test_nontdm_jobsubmit_with_multicastwrite_frf0"}, //7
		{test_nontdm_jobsubmit_with_writejobcmd_frf0, "test_nontdm_jobsubmit_with_writejobcmd_frf0"}, //8
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"test_nontdm_jobsubmit_with_writeregcmd_frf0"}, //9
		{test_tdm_jobsubmit_with_multicastwrite, "test_tdm_jobsubmit_with_multicastwrite"},//10
		{test_tdm_jobsubmit_with_writejobcmd, "test_tdm_jobsubmit_with_writejobcmd"}, //11
		{test_tdm_jobsubmit_with_writeregcmd, "test_tdm_jobsubmit_with_writeregcmd"}, //12
		{test_tdm_disable_enable_engine, "test_tdm_disable_enable_engine"}, //13
		{test_tdm_broadcast_canceljob, "test_tdm_broadcast_canceljob"}, //14
		{test_slowclk_baudrate_stopbit_variation, "test_slowclk_baudrate_stopbit_variation"}, //15
		{test_uart_tdm_asic_reset_stress, "test_uart_tdm_asic_reset_stress"}, //16
		{test_uart_tdm_engine_softreset_stress, "test_uart_tdm_engine_softreset_stress"}, //17
		{test_tdm_pwrcycle_stress,"test_tdm_pwrcycle_stress"}, //18
		{test_uart_tdm_packet_enable_disable,"test_uart_tdm_packet_enable_disable"},//19
		{test_tdm_delay_counter_variation, "test_tdm_delay_counter_variation"}, //20
		{test_Idle1_Engines_NotOutofReset, "test_Idle1_Engines_NotOutofReset"}, //21
		{test_Idle2_Engines_AfterClockUngate, "test_Idle2_Engines_AfterClockUngate"}, //idle 2  -22
		{test_tdm_canceljob, "test_tdm_canceljob"}, //23


		{test_tdm_jobsubmit_to_1engine,"test_tdm_jobsubmit_to_1engine"},
		{test_nontdm_jobsubmit_to_1engine_frf1,"test_nontdm_jobsubmit_to_1engine_frf1"},


#if 0
		{test_loopback, "test_loopback"}, //2

		{test_register_access,"P1.3 - test_register_access"}, // P1.3  //3
		{test_writereg,"test_writereg"}, //4
		{test_multicastwrite,"test_multicastwrite"},//5
		{test_broadcastwrite,"test_broadcastwrite"},//6
		{test_tdm_packet_enable_disable, "test_tdm_packet_enable_disable"},

		{test_nontdm_jobsubmit_with_multicastwrite_frf1,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writejobcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf1"}, // P1.2
		{test_nontdm_jobsubmit_with_writeregcmd_frf1,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf1"}, // P1.2

		{test_nontdm_jobsubmit_with_multicastwrite_frf0,"P1.2 - test_nontdm_jobsubmit_with_multicastwrite_frf0"}, // P1.2

		{test_nontdm_jobsubmit_with_writejobcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writejobcmd_frf0"}, // P1.2

		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"P1.2 - test_nontdm_jobsubmit_with_writeregcmd_frf0"}, // P1.2

		{test_tdm_jobsubmit_with_multicastwrite,"P1.4/P1.19 - test_tdm_jobsubmit_with_multicastwrite"}, // P1.4, P1.19

		{test_tdm_jobsubmit_with_writejobcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writejobcmd"}, // P1.4, P1.19

		{test_tdm_jobsubmit_with_writeregcmd,"P1.4/P1.19 - test_tdm_jobsubmit_with_writeregcmd"}, // P1.4, P1.19
		{test_nontdm_resultfsm_fifofull_check,"test_nontdm_resultfsm_fifofull_check"},

		{test_soft_reset,"P1.5 - test_soft_reset"}, // P1.5
		{test_broadcast_multicast_stress,"P1.6 - test_broadcast_multicast_stress"},// P1.6
		{test_max_loopback,"P1.7 - test_max_loopback"}, // P1.7
		{test_negative_error_invalid_offset, "P1.9 - test_negative_error_invalid_offset"}, // P1.9
		{test_thermal_trip,"P1.11 - test_thermal_trip"},// P1.11

		{test_tdm_invalid_broadcast_opcode, "P1a.8 - test_tdm_invalid_broadcast_opcode"},// P1a.8
		{test_tdm_with_Noop_sync, "P1a.9 - test_tdm_with_Noop_sync"},                                      // P1a.9
		{test_tdm_with_Noop_async, "P1a.9 - test_tdm_with_Noop_async"},                                    // P1a.9
		{test_tdm_with_Noop_broadcast_async, "P1b.1 - test_tdm_with_Noop_broadcast_async"},    //  P1b.1
		{test_pll_registers_progammable,"P1b.7 - test_pll_registers_progammable"},              // P1b.7

		{test_error_scenario_gt_42_read_write_read, "P1b.14 - test_error_scenario_gt_42_read_write_read"}, //P1b.14
		{test_error_scenario_gt_42_write_read, "P1b.15 - test_error_scenario_gt_42_write_read"}, // P1b.15
		{test_engine_clk_gated_CR_access, "P1b.17 - test_engine_clk_gated_CR_access"},
		{test_engineClkGated_ProgramValidJob, "P1b.18 - test_engineClkGated_ProgramValidJob"},

		{test_loadSpecificEngine_ReadResultRegsFromWrongEngine, "P1b.19 - test_loadSpecificEngine_ReadResultRegsFromWrongEngine"},
		{test_engineClkGate_LoadJob_ReadResultRegs, "P1b.20 - test_engineClkGate_LoadJob_ReadResultRegs"},

		{test_tdm_invalid_broadcast_opcode_muliticast,"P2.3 - test_tdm_invalid_broadcast_opcode_muliticast"},  // p2.3
		{test_tdm_data_corruption,"P1a.5 - test_tdm_data_corruption"},               // P1a.5

		{test_cancel_job_mode,"P1a.1 - test_cancel_job_mode"}, // P1a.1
		{test_negative_error_with_9thbit_set0, "P1.14 - test_negative_error_with_9thbit_set0"}, // P1.14

		{test_WriteJob_ReadResultThread_TDM_Enabled_PnP,"[PnP] [TDM-En] Write-Job, Read-Result Performance Test"},
		{test_stop_bit_validation,"P1a.7 - UART Stop Bit Validation - TDM Enable"},
		{test_FPGA_Baudrate_validation,"P1a.6 - TDM with varied BAUD rate for each ASIC"},
		{test_performance,"P1a.6,P1a.7,P1a.11 - UART Performance - TDM Enable"},

		{test_tdm_asic_reset_stress, "test_tdm_asic_reset_stress"},
		{test_tdm_engine_softreset_stress,"test_tdm_engine_softreset_stress"},
		{test_enable_disable_voltage_sensor,"test_enable_disable_voltage_sensor"},
		{test_tdm_delay_counter_variation,"test_tdm_delay_counter_variation"},
		{test_tdm_disable_enable_engine,"test_tdm_disable_enable_engine"},
		{test_tdm_pll_variation,"test_tdm_pll_variation"},
		{test_result_overflow,"P1a.4 - test_result_overflow"},                                  // P1a.4
		{test_tdm_jobsubmit_with_writejobcmd_fixedengine, "test_tdm_jobsubmit_with_writejobcmd_fixedengine"},
		{test_tdm_jobsubmit_with_writejobcmd_optimal_pll_scan, "test_tdm_jobsubmit_with_writejobcmd_optimal_pll_scan"},
		{test_tdm_pwrcycle_stress, "test_tdm_pwrcycle_stress"},
		{test_nontdm_jobsubmit_with_writejobcmd_frf1_fixedengine, "test_nontdm_jobsubmit_with_writejobcmd_frf1_fixedengine"},
		{test_ate_tdm_jobsubmit_with_writejobcmd_1engineAtATime,"test_ate_tdm_jobsubmit_with_writejobcmd_1engineAtATime"},
		{test_tdm_jobsubmit_with_writejobcmd_limited_noncesearch_fixedengine,"test_tdm_jobsubmit_with_writejobcmd_limited_noncesearch_fixedengine"},
		{test_tdm_pll_variation_onthefly, "test_tdm_pll_variation_onthefly"},
#endif
};




rand_configs rand_cfg []= {
		{}, //Reserved!!!!!

		{.name="Config-1",.result_fsm_freeze = 0x1,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.enable_sha256_verification=0,.fake_engine_check=0,.enable_hw_sha256=true},

		{.name="Config-2",.result_fsm_freeze = 0x1,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =1,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.enable_sha256_verification=0,.fake_engine_check=0,.enable_hw_sha256=true},

		{.name="Config-3",.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=0,.disable_random_engine=0,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},

		{.name="Config-4",.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =1,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=0,.disable_random_engine=0,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},

		{.name="Config-5",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},

		{.name="Config-6",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =1,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=0,.disable_random_engine=1,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},

		{.name="Config-7",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_tdm_randomization=1,.baud_rate_divisor=0,.enable_change_uart_baudrate=true,.enable_re_run_configphase=1,.enable_tdm_delay=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.enable_submit_two_job=0,.fake_engine_check=0,.uart_stop_bit=0,.disable_random_engine=1,.enable_sha256_verification=0,.enable_hw_sha256=true, .sensorclk_variation=true,.sensor_tdm_gap_cnt_variation=true},

		{.name="Config-8",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=0,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_buffer_overflow=1,.enable_re_run_configphase=0,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.custom_timestamp_count=255,.fake_engine_check=0,.enable_sha256_verification=0,.custom_hours=16,.tdm_counter=255,.enable_hw_sha256=true},

		{.name="Config-9[Perf-HW-SHA]",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=0,.enable_random_sequence=0,.generate_error_scenario=0,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=0,.disable_random_engine=0,.fake_engine_check=0,.enable_sha256_verification=0,.b2b_jobsubmit=true,.custom_timestamp_count=0,.enable_hw_sha256=true,.b2b_jobsubmit_per_engine=true,.jobprocessingtime=258},

		{.name="Config-10",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true,.autoclkgate=true},

		{.name="Config-11",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true,.eng_recovery_disabletce=true},

		{.name="Config-12",.result_fsm_freeze = 0x1,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =4,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.enable_sha256_verification=0,.fake_engine_check=0,.enable_hw_sha256=true},

		{.name="Config-13",.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =4,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=0,.disable_random_engine=0,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},

		{.name="Config-14",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =4,.enable_random_instruction_during_writejob=1,.enable_random_sequence=1,.generate_error_scenario=1,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=1,.disable_random_engine=1,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},

		{.name="Config-15",.enable_tdm_mode=1,.result_fsm_freeze = 0x0,.row_id= 0xFFF,.col_id = 0xFFF,.workload_options =2,.enable_random_instruction_during_writejob=0,.enable_random_sequence=0,.generate_error_scenario=0,.additional_loop_count=1,.enable_bypass_job_waiting=1,.enable_eight_hour_stress_test=0,.enable_random_softreset_asic=0,.disable_random_engine=0,.fake_engine_check=0,.enable_sha256_verification=0,.enable_hw_sha256=true},


};


#if defined(ASIC_BZM2)
teststruct test_bzm2[] =
{
		{}, //Reserved

		{test_regwrite_broadcast_1asic,"test_regwrite_broadcast_1asic"}, /* 1 */
		{test_regwrite_broadcast_all_asic,"test_regwrite_broadcast_all_asic"},
		{test_tmd_jobsubmit_with_broadcast_all_asic, "test_tmd_jobsubmit_with_broadcast_all_asic"}, /* 3 */
		{test_tdm_broadcast_canceljob, "test_tdm_broadcast_canceljob"},
		{test_effbst_tdm_jobsubmit_to_1engine, "test_effbst_tdm_jobsubmit_to_1engine"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd, "test_effbst_tdm_jobsubmit_with_writejobcmd"}, /* 6 */
		{test_effbst_tdm_jobsubmit_with_writeregcmd, "test_effbst_tdm_jobsubmit_with_writeregcmd"},
		{test_effbst_tdm_jobsubmit_with_multicastwrite, "test_effbst_tdm_jobsubmit_with_multicastwrite"}, /* 8 */
		{test_effbst_tdm_jobsubmit_with_broadcastcmd,"test_effbst_tdm_jobsubmit_with_broadcastcmd"},

		{test_effbst_nontdm_jobsubmit_with_writejobcmd_frf0, "test_effbst_nontdm_jobsubmit_with_writejobcmd_frf0"}, /* 10 */
		{test_effbst_nontdm_jobsubmit_with_writeregcmd_frf0, "test_effbst_nontdm_jobsubmit_with_writeregcmd_frf0"},
		{test_effbst_nontdm_jobsubmit_with_multicastwrite_frf0, "test_effbst_nontdm_jobsubmit_with_multicastwrite_frf0"}, /* 12 */
		{test_effbst_nontdm_jobsubmit_with_broadcastcmd_frf0, "test_effbst_nontdm_jobsubmit_with_broadcastcmd_frf0"},
		{test_effbst_nontdm_jobsubmit_with_writejobcmd_frf1, "test_effbst_nontdm_jobsubmit_with_writejobcmd_frf1"}, /* 14 */
		{test_effbst_nontdm_jobsubmit_with_writeregcmd_frf1, "test_effbst_nontdm_jobsubmit_with_writeregcmd_frf1"},
		{test_effbst_nontdm_jobsubmit_with_multicastwrite_frf1, "test_effbst_nontdm_jobsubmit_with_multicastwrite_frf1"},
		{test_effbst_nontdm_jobsubmit_with_broadcastcmd_frf1, "test_effbst_nontdm_jobsubmit_with_broadcastcmd_frf1"}, /* 17 */
		{test_effbst_tdm_canceljob, "test_effbst_tdm_canceljob"}, /* 18 */
		{test_effbst_tdm_disable_enable_engine, "test_effbst_tdm_disable_enable_engine"},
		{test_effbst_tdm_incomplete_jobsubmit, "test_effbst_tdm_incomplete_jobsubmit"}, /* 20 */
		{test_effbst_tdm_shuffle_seq_id, "test_effbst_tdm_shuffle_seq_id"},
		{test_effbst_tdm_timestamp1, "test_effbst_tdm_timestamp1"}, /* 22 */
		{test_effbst_resultfsm_overflow, "test_effbst_resultfsm_overflow"},
		{test_effbst_engine_fifofull_check, "test_effbst_engine_fifofull_check"}, /* 24 */
		{test_effbst_slowclk_baudrate_stopbit_variation, "test_effbst_slowclk_baudrate_stopbit_variation"}, /* 25 */
		{test_effbst_tdm_jobsubmit_with_diff_merkelrootresidue,"test_effbst_tdm_jobsubmit_with_diff_merkelrootresidue"}, /* 26 */
		{test_effbst_tdm_jobsubmit_with_same_subjobs,"test_effbst_tdm_jobsubmit_with_same_subjobs"},
		{test_effbst_thermal_trip,"test_effbst_thermal_trip"}, /* 28 */
		{test_effbst_tdm_softreset, "test_effbst_tdm_softreset"},
		{test_effbst_tdm_readreg_inbetween_readresult, "test_effbst_tdm_readreg_inbetween_readresult"}, /* 30 */
		{test_tdm_readreg_inbetween_readresult, "test_tdm_readreg_inbetween_readresult"},
		{test_tdm_selectable_leadingzeros, "test_tdm_selectable_leadingzeros"}, /* 32 */
		{test_effbst_tdm_selectable_leadingzeros, "test_effbst_tdm_selectable_leadingzeros"},
		{test_tdm_selectable_leadingzeros_update_zerotofind_inbetween,"test_tdm_selectable_leadingzeros_update_zerotofind_inbetween"}, /* 34 */
		{test_effbst_tdm_selectable_leadingzeros_update_zerotofind_inbetween, "test_effbst_tdm_selectable_leadingzeros_update_zerotofind_inbetween"},
		{test_tdm_engine_recovery_with_1tce, "test_tdm_engine_recovery_with_1tce"}, /* 36 */
		//{test_effbst_tdm_engine_recovery_with_1tce, "test_effbst_tdm_engine_recovery_with_1tce"},
		{test_effbst_tdm_engine_recovery_with_disabletce, "test_effbst_tdm_engine_recovery_with_disabletce"},

		{test_tdm_autoclockgating, "test_tdm_autoclockgating"}, /* 38 */
		{test_effbst_tdm_autoclockgating, "test_effbst_tdm_autoclockgating"},
		{test_tdm_autoclockgating_b2b,"test_tdm_autoclockgating_b2b"}, /* 40 */
		{test_effbst_tdm_autoclockgating_b2b,"test_effbst_tdm_autoclockgating_b2b"},
		{test_tdm_autoclockgating_update_timestamp_inbetween,"test_tdm_autoclockgating_udpate_timestamp_inbetween"}, /* 42 */
		{test_tdm_engine_recovery_with_oddtce_on,"test_tdm_engine_recovery_with_oddtce_on"}, /* 43 */
		{test_tdm_engine_recovery_with_eventce_on,"test_tdm_engine_recovery_with_eventce_on"}, /* 44 */

		{test_bist_internal_pattern_unicast, "test_bist_internal_pattern_unicast"}, /* 45 */
		{test_bist_internal_pattern_multicast, "test_bist_internal_pattern_multicastcast"}, /* 46 */
		{test_bist_internal_pattern_broadcast, "test_bist_internal_pattern_broadcast"}, /* 47 */
		{test_bist_external_pattern_unicast, "test_bist_external_pattern_unicast"}, /* 48 */
		{test_bist_external_pattern_multicast, "test_bist_external_pattern_multicastcast"}, /* 49*/
		{test_bist_external_pattern_broadcast, "test_bist_external_pattern_broadcast"}, /* 50 */
		{test_register_read_during_bist,"test_register_read_during_bist"}, /* 51 */
		{test_register_read_defaultvalue,"test_register_read_defaultvalue"}, /* 52 */
		{test_effbst_tdm_asic_reset_stress, "test_effbst_tdm_asic_reset_stress"}, /* 53 */
		{test_noop_all_asic, "test_noop_all_asic"}, /* 54 */
		{test_tdm_jobdone_status_with_resultvalid,"test_tdm_jobdone_status_with_resultvalid"}, /* 55 */
		{test_effbst_tdm_jobdone_status_with_resultvalid,"test_effbst_tdm_jobdone_status_with_resultvalid"}, /* 56 */
		{test_tdm_jobdone_status_without_resultvalid,"test_tdm_jobdone_status_without_resultvalid"}, /* 57 */
		{test_effbst_tdm_jobdone_status_without_resultvalid,"test_effbst_tdm_jobdone_status_without_resultvalid"}, /* 58 */
		{test_tdm_jobdone_status_dropoff_with_disable_engine,"test_tdm_jobdone_status_dropoff_with_disable_engine"}, /* 59 */
		{test_effbst_tdm_jobdone_status_dropoff_with_disable_engine, "test_effbst_tdm_jobdone_status_dropoff_with_disable_engine"}, /* 60 */
		{test_tdm_jobdone_status_dropoff_with_fsm_overflow,"test_tdm_jobdone_status_dropoff_with_fsm_overflow"}, /* 61 */
		{test_effbst_tdm_jobdone_status_dropoff_with_fsm_overflow,"test_effbst_tdm_jobdone_status_dropoff_with_fsm_overflow"},	/* 62 */
		{test_tdm_pendingjob_status_for_b2b,"test_tdm_pendingjob_status_for_b2b"}, /* 63 */
		{test_effbst_tdm_pendingjob_status_for_b2b,"test_effbst_tdm_pendingjob_status_for_b2b"}, /* 64 */
		{test_tdm_jobdone_status_disable,"test_tdm_jobdone_status_disable"}, /* 65 */
		{test_effbst_tdm_jobdone_status_disable,"test_effbst_tdm_jobdone_status_disable"}, /* 66 */
		{test_tdm_jobdone_status_disable_enable_stress,"test_tdm_jobdone_status_disable_enable_stress"}, /* 67 */
		{test_effbst_tdm_jobdone_status_disable_enable_stress,"test_effbst_tdm_jobdone_status_disable_enable_stress"}, /* 68 */
		{test_tdm_jobdone_status_enable_autoclockgating,"test_tdm_jobdone_status_enable_autoclockgating"}, /* 69 */
		{test_effbst_tdm_jobdone_status_enable_autoclockgating, "test_effbst_tdm_jobdone_status_enable_autoclockgating"}, /* 70 */
		{test_tdm_jobdone_status_disable_autoclockgating, "test_tdm_jobdone_status_disable_autoclockgating"}, /*71 */
		{test_effbst_tdm_jobdone_status_disable_autoclockgating, "test_effbst_tdm_jobdone_status_disable_autoclockgating"}, /*72 */
		{test_nontdm_jobdone_status_disable_frf1,"test_nontdm_jobdone_status_disable_frf1"}, /* 73 */
		{test_effbst_nontdm_jobdone_status_disable_frf1,"test_effbst_nontdm_jobdone_status_disable_frf1"}, /* 74 */
		{test_tdm_continuous_b2b_jobs,"test_tdm_continuous_b2b_jobs"}, /* 75 */
		{test_effbst_tdm_continuous_b2b_jobs,"test_effbst_tdm_continuous_b2b_jobs"}, /* 76 */
		{test_thermal_resolution_variation,"test_thermal_resolution_variation"}, /* 77 */
		{test_voltage_resolution_variation,"test_voltage_resolution_variation"}, /* 78 */
		{test_thermal_threshold_exceeds_inbetween_jobprocessing,"test_thermal_threshold_exceeds_inbetween_jobprocessing"}, /* 79 */
		{test_voltage_threshold_exceeds_inbetween_jobprocessing,"test_voltage_threshold_exceeds_inbetween_jobprocessing"}, /* 80 */
		{test_thermal_threshold_exceeds_at_beginning,"test_thermal_threshold_exceeds_at_beginning"}, /* 81 */
		{test_voltage_threshold_exceeds_at_beginning,"test_voltage_threshold_exceeds_at_beginning"}, /* 82 */
		{test_voltage_shutdown_disabled, "test_voltage_shutdown_disabled"}, /* 83 */
		{test_tdm_dutycycle_variation,"test_tdm_dutycycle_variation"}, /* 84 */
		{test_effbst_tdm_dutycycle_variation,"test_effbst_tdm_dutycycle_variation"}, /* 85 */
		{test_tdm_internalfastclk_dcdll_enabled,"test_tdm_internalfastclk_dcdll_enabled"}, /* 86 */
		{test_effbst_tdm_internalfastclk_dcdll_enabled,"test_effbst_tdm_internalfastclk_dcdll_enabled"}, /* 87 */
		{test_tdm_internalfastclk_dcdll_disabled,"test_tdm_internalfastclk_dcdll_disabled"}, /* 88 */
		{test_effbst_tdm_internalfastclk_dcdll_disabled,"test_effbst_tdm_internalfastclk_dcdll_disabled"}, /* 89 */
		{test_tdm_internalfastclk_dcdll_freeze,"test_tdm_internalfastclk_dcdll_freeze"}, /* 90 */
		{test_tdm_internalfastclk_dcdll_pi_byp_disabled,"test_tdm_internalfastclk_dcdll_pi_byp_disabled"}, /* 91 */
		{test_tdm_externalfastclk_dcdll_enable,"test_tdm_externalfastclk_dcdll_enable"}, /* 92 */
		{test_tdm_externalfastclk_dcdll_disable,"test_tdm_externalfastclk_dcdll_disable"}, /* 93 */
		{test_nontdm_enable_disable_jobdone_status_frf0_backpressurefifo, "test_nontdm_enable_disable_jobdone_status_frf0_backpressurefifo"}, /*94 */
		{test_tdm_enable_disable_jobdone_status_backpressurefifo, "test_tdm_enable_disable_jobdone_status_backpressurefifo"}, /* 95 */
		{test_tdm_result_fifobackpressure_with_dummyresult, "test_tdm_result_fifobackpressure_with_dummyresult"}, /* 96 */
		{test_bist_pattern_with_tce_disable,"test_bist_pattern_with_tce_disable"}, /* 97 */
		{test_update_extrn_bist_when_intrb_bist_enabled,"test_update_extrn_bist_when_intrb_bist_enabled"}, /* 98 */
		{test_bist_ext_unicast_thermal_threshold_exceeds_at_beginning, "test_bist_ext_unicast_thermal_threshold_exceeds_at_beginning"}, /* 99 */
		{test_tdm_switch_bw_dll_enabled_and_disable, "test_tdm_switch_bw_dll_enabled_and_disable"}, /* 100 */
		{test_bist_func_with_ext_bypass_clk_mode,"test_bist_func_with_ext_bypass_clk_mode"}, /* 101 */
		{test_direct_mode_vol_sensor_dout_read, "test_direct_mode_vol_sensor_dout_read"}, /*102 */
		{test_direct_mode_temp_sensor_dout_read, "test_direct_mode_temp_sensor_dout_read"}, /* 103 */
		{test_effbst_tdm_dll_tuning_without_dll_bypass,"test_effbst_tdm_dll_tuning_without_dll_bypass"}, /* 104 */
		{test_bist_unique_pattern_per_job, "test_bist_unique_pattern_per_job"}, /* 105 */

		{test_bist_internal_pattern_engine_disable, "test_bist_internal_pattern_engine_disable"}, /* 106 */
		{test_bist_external_pattern_engine_disable, "test_bist_external_pattern_engine_disable"}, /* 107 */

		{test_thermal_threshold_counter_update_and_reset, "test_thermal_threshold_counter_update_and_reset"}, /* 108 */
		{test_effbst_thermal_threshold_counter_update_and_reset, "test_effbst_thermal_threshold_counter_update_and_reset"}, /*109*/
		{test_voltage_threshold_counter_update_and_reset_ch0, "test_voltage_threshold_counter_update_and_reset_ch0"},/* 110 */
		{test_effbst_voltage_threshold_counter_update_and_reset_ch0, "test_effbst_voltage_threshold_counter_update_and_reset_ch0"}, /* 111 */
		{test_voltage_threshold_counter_update_and_reset_ch1, "test_voltage_threshold_counter_update_and_reset_ch1"}, /* 112 */
		{test_effbst_voltage_threshold_counter_update_and_reset_ch1, "test_effbst_voltage_threshold_counter_update_and_reset_ch1"}, /* 113 */

		{test_thermal_threshold_variation_and_counter_update," test_thermal_threshold_variation_and_counter_update "}, /* 114 */
		{test_effbst_thermal_threshold_variation_and_counter_update, "test_effbst_thermal_threshold_variation_and_counter_update"}, /* 115 */
		{test_voltage_threshold_variation_and_counter_update_ch0, "test_voltage_threshold_variation_and_counter_update_ch0"}, /* 116 */
		{test_effbst_voltage_threshold_variation_and_counter_update_ch0, "test_effbst_voltage_threshold_variation_and_counter_update_ch0"}, /* 117 */
		{test_voltage_threshold_variation_and_counter_update_ch1, "test_voltage_threshold_variation_and_counter_update_ch1"}, /* 118 */
		{test_effbst_voltage_threshold_variation_and_counter_update_ch1, "test_effbst_voltage_threshold_variation_and_counter_update_ch1"}, /* 119 */

		{test_vs_onetime_conversion_read_inbetween_jobprocessing,"test_vs_onetime_conversion_read_inbetween_jobprocessing"}, /* 120 */
		{test_vs_continous_conversion_read_inbetween_jobprocessing,"test_vs_continous_read_inbetween_jobprocessing"}, /* 121 */

		{test_tdm_jobsubmit_update_tdmgapcnt_dts_disable, "test_tdm_jobsubmit_update_tdmgapcnt_dts_disable"}, /* 122 */
		{test_tdm_effbst_jobsubmit_update_tdmgapcnt_with_dts_disable,"test_tdm_effbst_jobsubmit_update_tdmgapcnt_with_dts_disable"}, /* 123 */
		{test_tdm_jobsubmit_update_tdmgapcnt_onfly, "test_tdm_jobsubmit_update_tdmgapcnt_onfly"}, /* 124 */
		{test_tdm_effbst_jobsubmit_update_tdmgapcnt_onfly, "test_tdm_effbst_jobsubmit_update_tdmgapcnt_onfly"}, /* 125 */
		{test_tdm_effbst_without_jobsubmit_update_tdmgapcnt_with_dts_disable, "test_tdm_effbst_without_jobsubmit_update_tdmgapcnt_with_dts_disable"}, /* 126 */
		{test_tdm_without_jobsubmit_update_tdmgapcnt_onfly,"test_tdm_without_jobsubmit_update_tdmgapcnt_onfly"}, /* 127 */
		{test_tdm_jobsubmit_different_tdmgapcnt, "test_tdm_jobsubmit_different_tdmgapcnt"}, /*128*/
		{test_update_tdmgapcnt_with_readreg,"test_update_tdmgapcnt_with_readreg"}, /* 129 */
		{test_tdm_without_jobsubmit_update_tdmgapcnt_in_ascen_descn_order,"test_tdm_without_jobsubmit_update_tdmgapcnt_in_ascen_descn_order"}, /* 130 */
		{test_voltage_sensor_clk_div_variation, "test_voltage_sensor_clk_div_variation"},  /*131*/
		{test_thermal_sensor_clk_div_variation, "test_thermal_sensor_clk_div_variation"},  /*132*/
		{test_sensor_clk_div_below4mhz, "test_sensor_clk_div_below4mhz"}, /*133*/
		{test_effbst_tdm_engine_recovery_with_alternate_tce, "test_effbst_tdm_engine_recovery_with_alternate_tce"}, /*134*/
		{test_effbst_tdm_canceljob_with_writejob, "test_effbst_tdm_canceljob_with_writejob"}, /*135 */

		{test_loopback,"test_loopback"}, 
		{test_effbst_tdm_autoclockgating_withcanceljob,"test_effbst_tdm_autoclockgating_withcanceljob"},
		{test_effbst_tdm_autoclockgating_withcanceljob_1engine,"test_effbst_tdm_autoclockgating_withcanceljob_1engine"},
		{test_tdm_autoclockgating_withcanceljob_1engine, "test_tdm_autoclockgating_withcanceljob_1engine"},

		{test_nontdm_jobsubmit_with_multicastwrite_frf1, "test_nontdm_jobsubmit_with_multicastwrite_frf1"},
		{test_nontdm_jobsubmit_with_writejobcmd_frf1, "test_nontdm_jobsubmit_with_writejobcmd_frf1"},
		{test_nontdm_jobsubmit_with_writeregcmd_frf1, "test_nontdm_jobsubmit_with_writeregcmd_frf1"},
		{test_nontdm_jobsubmit_with_multicastwrite_frf0, "test_nontdm_jobsubmit_with_multicastwrite_frf0"},
		{test_nontdm_jobsubmit_with_writejobcmd_frf0, "test_nontdm_jobsubmit_with_writejobcmd_frf0"},
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"test_nontdm_jobsubmit_with_writeregcmd_frf0"},
		{test_tdm_jobsubmit_with_multicastwrite, "test_tdm_jobsubmit_with_multicastwrite"},
		{test_tdm_jobsubmit_with_writejobcmd, "test_tdm_jobsubmit_with_writejobcmd"},
		{test_tdm_jobsubmit_with_writeregcmd, "test_tdm_jobsubmit_with_writeregcmd"},

		{test_uart_notch_write_reg, "test_uart_notch_write_reg"},
		{test_uart_notch_read_reg, "test_uart_notch_read_reg"},
		{test_engine_read_reg,"test_engine_read_reg"},
		{test_engine_write_reg,"test_engine_write_reg"},
		{test_tdm_jobsubmit_to_1engine,"test_tdm_jobsubmit_to_1engine"},
		{test_nontdm_jobsubmit_to_1engine_frf1,"test_nontdm_jobsubmit_to_1engine_frf1"},
		{test_sanity_check, " test_sanity_check "},
		{test_end_successful, "test_end_successful"},
		{test_notch_register_dump, "test_notch_register_dump"},
		{test_engine_register_dump, "test_engine_register_dump"},
		{test_uart_bist_write_reg, "test_uart_bist_write_reg"},
		{test_uart_bist_read_reg, "test_uart_bist_read_reg"},

		{test_effbst_tdm_jobsubmit_with_both_tce_disabled_and_enabled_back, "test_effbst_tdm_jobsubmit_with_both_tce_disabled_and_enabled_back "},
		{test_effbst_tdm_jobsubmit_with_both_tce_disabled_and_enabled_with_canceljob, " test_effbst_tdm_jobsubmit_with_both_tce_disabled_and_enabled_with_canceljob "},
		{test_tdm_dts_disable,"test_tdm_dts_disable"},
		{test_clockgate, "test_clockgate"},
		{test_effbst_clockgate, "test_effbst_clockgate"},
		{test_tce_clockgate, "test_tce_clockgate"},
		{test_tce_effbst_clockgate, "test_tce_effbst_clockgate"},
		{test_tdm_delay_sensgapcnt_variation_for_all_asic,"test_tdm_delay_sensgapcnt_variation_for_all_asic"},
		{test_effbst_tdm_delay_sensgapcnt_variation_for_all_asic,"test_effbst_tdm_delay_sensgapcnt_variation_for_all_asic"},
		{test_tdm_max_delay_for_all_asic,"test_tdm_max_delay_for_all_asic"},
		{test_effbst_tdm_max_delay_for_all_asic,"test_effbst_tdm_max_delay_for_all_asic"},
		{test_engine_broadcastwrite, "test_engine_broadcastwrite"},
		{test_effbst_tdm_jobsubmit_with_multicastwrite_and_disable_1tce,"test_effbst_tdm_jobsubmit_with_multicastwrite_and_disable_1tce"},
        {test_tdm_selectable_leadingzeros_b2b, "test_tdm_selectable_leadingzeros_b2b"}, /* 32 */
        {test_effbst_tdm_selectable_leadingzeros_b2b, "test_effbst_tdm_selectable_leadingzeros_b2b"},
		//{test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl2, "test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl2"},
		//{test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl1, "test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl1"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl3, "test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl3"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence1, "test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence1"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence2, "test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence2"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence3, "test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence3"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence4, "test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence4"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence5, "test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence5"},
		{test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence6, "test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence6"},
		{test_effbst_tdm_disable_enable_many_engines, "test_effbst_tdm_disable_enable_many_engines"},
		{test_effbst_tdm_cancelcurrentjob, "test_effbst_tdm_cancelcurrentjob"},
		{test_tdm_cancel_current_and_pending_job, "test_tdm_cancel_current_and_pending_job"},
		{test_effbst_tdm_engine_config_regread_during_job, "test_effbst_tdm_engine_config_regread_during_job"},
		{test_non_effbst_job_in_effbstmode,"test_non_effbst_job_in_effbstmode"},
		{test_effbst_tdm_jobsubmit_with_jobcontrol1_for_all_subjobs, "test_effbst_tdm_jobsubmit_with_jobcontrol1_for_all_subjobs"},
		{test_uart_open_close, "test_uart_open_close"},
		{test_engine_broadcast_reset, "test_engine_broadcast_reset"},
		{test_asic_asic_delay_tdm_delay_calibrator, "test_asic_asic_delay_tdm_delay_calibrator"},
		{test_dummy_noop_for_2x2_image, "test_dummy_noop_for_2x2_image"},

};
#else

teststruct test_bzm2[] =
{
		{}, //Reserved
};
#endif

teststruct test_edm[] =
{
		{}, //Reserved

		{test_noop, "test_noop"}, //1
		{test_loopback, "test_loopback"}, //2
		{test_register_read_defaultvalue, "test_register_read_defaultvalue"}, //3
		{test_nontdm_jobsubmit_with_multicastwrite_frf1, "test_nontdm_jobsubmit_with_multicastwrite_frf1"}, //4
		{test_nontdm_jobsubmit_with_writejobcmd_frf1, "test_nontdm_jobsubmit_with_writejobcmd_frf1"}, //5
		{test_nontdm_jobsubmit_with_writeregcmd_frf1, "test_nontdm_jobsubmit_with_writeregcmd_frf1"}, //6
		{test_nontdm_jobsubmit_with_multicastwrite_frf0, "test_nontdm_jobsubmit_with_multicastwrite_frf0"}, //7
		{test_nontdm_jobsubmit_with_writejobcmd_frf0, "test_nontdm_jobsubmit_with_writejobcmd_frf0"}, //8
		{test_nontdm_jobsubmit_with_writeregcmd_frf0,"test_nontdm_jobsubmit_with_writeregcmd_frf0"}, //9
		{test_tdm_jobsubmit_with_multicastwrite, "test_tdm_jobsubmit_with_multicastwrite"},//10
		{test_tdm_jobsubmit_with_writejobcmd, "test_tdm_jobsubmit_with_writejobcmd"}, //11
		{test_tdm_jobsubmit_with_writeregcmd, "test_tdm_jobsubmit_with_writeregcmd"}, //12
		{test_tdm_disable_enable_engine, "test_tdm_disable_enable_engine"}, //13
		{test_tdm_canceljob, "test_tdm_canceljob"}, //14
		{test_slowclk_baudrate_stopbit_variation, "test_slowclk_baudrate_stopbit_variation"}, //15
		{test_uart_tdm_asic_reset_stress, "test_uart_tdm_asic_reset_stress"}, //16
		{test_uart_tdm_engine_softreset_stress, "test_uart_tdm_engine_softreset_stress"}, //17
		{test_tdm_pwrcycle_stress,"test_tdm_pwrcycle_stress"}, //18
		{test_edm_pll_variation_parallel_mode, "test_edm_pll_variation_parallel_mode"}, //19
		{test_edm_pll_variation_serial_mode, "test_edm_pll_variation_serial_mode"}, //20
		{test_uart_tdm_packet_enable_disable,"test_uart_tdm_packet_enable_disable"}, //21
		{test_tdm_delay_counter_variation, "test_tdm_delay_counter_variation"}, //22
		{test_Idle1_Engines_NotOutofReset, "test_Idle1_Engines_NotOutofReset"}, //23
		{test_Idle2_Engines_AfterClockUngate, "test_Idle2_Engines_AfterClockUngate"}, //idle 2  -24

		{test_tdm_jobsubmit_to_1engine,"test_tdm_jobsubmit_to_1engine"}, //25
		{test_nontdm_jobsubmit_to_1engine_frf1,"test_nontdm_jobsubmit_to_1engine_frf1"}, //26
		{test_tdm_jobsubmit_with_writejobcmd_per_row, "test_tdm_jobsubmit_with_writejobcmd_per_row"}, //27
		{test_tdm_writejob_readresult_pnp, "test_tdm_writejob_readresult_pnp"}, //28
		{test_tdm_jobsubmit_with_writejobcmd_per_eng, "test_tdm_jobsubmit_with_writejobcmd_per_eng"}, //29
		{test_tdm_jobsubmit_with_multicastwrite_per_row, "test_tdm_jobsubmit_with_multicastwrite_per_row"},//30
		{test_tdm_jobsubmit_with_writejobcmd_with_timeprint, "test_tdm_jobsubmit_with_writejobcmd_with_timeprint"}, //31
		{test_tdm_jobsubmit_with_writejobcmd_with_samepattern, "test_tdm_jobsubmit_with_writejobcmd_with_samepattern"}, //32


};


void print_testlist(struct teststruct *test, uint32_t testcnt)
{

	printf("\n************************** %s TestList ****************************\n\n",bzm_params.testarray_name);
	for(uint32_t i=1;i<testcnt;i++)
	{
		printf("  %d: %s\n", i, (test+i)->fname);

	}
	printf("\n*********************************************************************\n\n");
}

void print_testresult(uint32_t test_num, uint32_t ret)
{
	char status[20];
	char fname[100]= " ";

	if(bzm_params.uart_dev!=NULL)
	{
		if(bzm_params.tdm_enabled==true)
			disable_tdm();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			uart_drain(bzm_params.uart_dev,b);// Tx
			uart_flush(bzm_params.uart_dev,b);// Rx

		}


		//	API_ErrorLogRegRead();

		/*
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(board_exist[b] == 0)
				continue;
			asic_global_reset(b,false);
			asic_soft_reset(b, BROADCAST_ASIC);
		}
		 */
	}

	if(ret==0)
	{
		strcpy(status,"PASSED");
	}
	else
	{
#if 0
		char errstatus[100];
		sprintf(errstatus,"FAILED - %s",print_errorcode(ret));
		strcpy(status,errstatus);
#endif
		strcpy(status,"FAILED");
	}

	if(bzm_params.testtype == RAND_TEST)
	{
		strcpy(fname, bzm_params.rand_params->rand_cfg[test_num].name);

	}

	else
	{
		strcpy(fname, bzm_params.test[test_num].fname);
		strcpy(bzm_params.test[test_num].status, status);
	}


	sleep(3);
	rand_log(LOG_INFO, "\n");
	rand_log(LOG_INFO,"========================================================================================\n" );
	rand_log(LOG_INFO,"      TEST %d - %s -  %s\n",test_num, fname, status);
	rand_log(LOG_INFO,"=========================================================================================\n\n\n" );
	sleep(3);
}



void print_alltestresult(uint32_t from_testid)
{

	rand_log(LOG_INFO,"\n\n\n============================================= REGRESSION REPORT ===============================================\n\n" );

	for(uint32_t i = from_testid; i < bzm_params.testcnt; i++)
	{
		rand_log(LOG_INFO,"     %-3d - %-65s -  %-10s   %d min:%d sec\n",i, bzm_params.test[i].fname, bzm_params.test[i].status, bzm_params.test[i].timetaken/60, bzm_params.test[i].timetaken%60);
	}

	rand_log(LOG_INFO,"\n===============================================================================================================\n\n\n" );


}




void get_testlist_info(bool printinfo)
{
	if(bzm_params.testtype == CUSTOM_TEST)
	{
		strcpy(bzm_params.testarray_name, "Custom");
		bzm_params.testcnt = sizeof(test_custom)/sizeof(teststruct);
		bzm_params.test = test_custom;

		if(printinfo == true)
			print_testlist(bzm_params.test,bzm_params.testcnt);


	}
	else if(bzm_params.testtype == RAND_TEST)
	{

		bzm_params.testcnt = sizeof(rand_cfg)/sizeof(rand_configs);
		bzm_params.rand_params->rand_cfg = rand_cfg;
		printf("rand testcnt = %d\n",bzm_params.testcnt);
	}
	else if(bzm_params.testtype == FOCUS_TEST)
	{
		if(bzm_params.cfg.prj == BZM2)
		{
			strcpy(bzm_params.testarray_name, "BZM2");
			bzm_params.testcnt = sizeof(test_bzm2)/sizeof(teststruct);
			bzm_params.test = test_bzm2;

		}
		else if(bzm_params.cfg.prj == EDM)
		{
			strcpy(bzm_params.testarray_name, "EDM");
			bzm_params.testcnt = sizeof(test_edm)/sizeof(teststruct);
			bzm_params.test = test_edm;

		}
		else //BZM
		{
			if(bzm_params.cfg.env == POSTSILICON)
			{
				strcpy(bzm_params.testarray_name, bzm_params.cfg.envname);
				bzm_params.testcnt = sizeof(test_bzm_postsilicon)/sizeof(teststruct);
				bzm_params.test = test_bzm_postsilicon;
			}
			else
			{
				strcpy(bzm_params.testarray_name, bzm_params.cfg.fpganame);
				if(bzm_params.cfg.fpga == FPGA_1x129)
				{
					bzm_params.testcnt = sizeof(test_1x129)/sizeof(teststruct);
					bzm_params.test = test_1x129;
				}
				else if(bzm_params.cfg.fpga == FPGA_2x129)
				{
					bzm_params.testcnt = sizeof(test_2x129)/sizeof(teststruct);
					bzm_params.test = test_2x129;
				}
				else if(bzm_params.cfg.fpga == FPGA_100x1)
				{
					bzm_params.testcnt = sizeof(test_100x1)/sizeof(teststruct);
					bzm_params.test = test_100x1;
				}
				else
				{
					bzm_params.testcnt = sizeof(test_bzm_presilicon)/sizeof(teststruct);
					bzm_params.test = test_bzm_presilicon;
				}

			}

		}
		if(printinfo == true)
			print_testlist(bzm_params.test,bzm_params.testcnt);

	}


}


void t_starttime()
{

	/** Execution Time START**/
	clock_gettime(CLOCK_MONOTONIC, &t_start_time);

}

void t_endtime()
{
	double var_total_execution_time;

	clock_gettime(CLOCK_MONOTONIC, &t_end_time);
	var_total_execution_time=((double)t_end_time.tv_sec + 1.0e-9*t_end_time.tv_nsec) -
			((double)t_start_time.tv_sec + 1.0e-9*t_start_time.tv_nsec);
	rand_log(LOG_INFO, "jobprocessingtime=%d secs\n",bzm_params.jobprocessingtime);
	total_execution_time = var_total_execution_time;
	rand_log(LOG_INFO, "Time taken is: %.5f seconds ( OR %f minutes )\n",  var_total_execution_time, var_total_execution_time/60);

}

int test_noop(void)
{
	int ret=SUCCESS;
	char buf[3];
	uint32_t asic_per_board[BOARD_PER_DEVICE];
	uint32_t asic_cnt=0;

	memset(bzm_params.board_exist, 0, sizeof(bzm_params.board_exist));


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);

			if((ret=asic_global_reset(b,false)))
				return ret;
		}
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		asic_cnt=0;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			asic_per_board[b]=0;
			rand_log(LOG_INFO, "Finding asic in board %d..\n",b);
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				memset(buf, '\0', 3);

				ret=uart_command_noop(bzm_params.uart_dev, b, a, buf);
				if(ret)
				{
					rand_log(LOG_INFO, "NOOP Response of [b:%d] [a:%d] = %c %c %c\n", b, a, buf[0], buf[1], buf[2]);

					if(strncmp(buf,bzm_params.expected_noop_resp,3) == 0)
					{
						asic_cnt++;
						asic_per_board[b]++;
					}
				}

			}
			rand_log(LOG_INFO,"\n\nNo. of asic found in [b:%d] = %d\n\n",b,asic_per_board[b]);
		}
		if(asic_cnt==0)
		{
			rand_log(LOG_ERROR,"[ERROR] - No asic found\n");
			ret=ERR_NO_ASIC_FOUND;
			break;
		}
		else
		{
			rand_log(LOG_INFO,"Total no. of asic found = %d\n\n",asic_cnt);
			ret=SUCCESS;
		}

	}
	//uart_dev_close();
	return ret;

}



int test_nontdm_jobsubmit_with_multicastwrite_frf1()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 1);

	if(bzm_params.cfg.env == POSTSILICON)
		bzm_params.cfg.nonce_count=2;

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
						break;

					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d, VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.expected_nonce_found);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;


}


int test_nontdm_jobsubmit_with_writejobcmd_frf1()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 1);

	if(bzm_params.cfg.env == POSTSILICON)
		bzm_params.cfg.nonce_count=2;

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}

					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;


}










int test_nontdm_jobsubmit_with_writeregcmd_frf1()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 1);

	if(bzm_params.cfg.env == POSTSILICON)
		bzm_params.cfg.nonce_count=2;

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;


						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}



					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;


}



int test_nontdm_jobsubmit_with_multicastwrite_frf0()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						nonce_cnt=write_bch_data(true,false,false,true,b,a,c,r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							nonce_cnt=write_bch_data(true,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=nonce_cnt;
							bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
							seq_id--;
						}
						break;

					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		ret=nontdm_readresult_from_resultfsm_frf0_wo_fifofull(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;


}



int test_nontdm_jobsubmit_with_writejobcmd_frf0()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						nonce_cnt=write_bch_data(false,true,false,true,b,a,c,r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							nonce_cnt=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=nonce_cnt;
							bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
							seq_id--;
						}

					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_resultfsm_frf0_wo_fifofull(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_nontdm_jobsubmit_with_writeregcmd_frf0()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						nonce_cnt=write_bch_data(false,false,false,true,b,a,c,r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							nonce_cnt=write_bch_data(false,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=nonce_cnt;
							bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
							seq_id--;
						}

					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		ret=nontdm_readresult_from_resultfsm_frf0_wo_fifofull(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;




}



int test_tdm_jobsubmit_with_multicastwrite()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		/** Time Initialization START **/
		double var_total_execution_time;
		struct timespec var_start_time= {0,0}, var_end_time= {0,0};
		/** Time Initialization END **/

		/** Execution Time START**/
		clock_gettime(CLOCK_MONOTONIC, &var_start_time);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
						break;
					}
				}
			}
		}

		/** Execution Time END **/
		/** Time Calculation START **/
		clock_gettime(CLOCK_MONOTONIC, &var_end_time);
		var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
				((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
		rand_log(LOG_INFO, "Time taken to send %d write jobs is: %.5f seconds ( OR %f minutes )\n",
				bzm_params.job_submit, var_total_execution_time, var_total_execution_time/60);
		/** Time Calculation END **/


		/** Execution Time START **/
		clock_gettime(CLOCK_MONOTONIC, &var_start_time);

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);


		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);


		/** Execution Time END **/
		/** Time Calculation START **/
		clock_gettime(CLOCK_MONOTONIC, &var_end_time);
		var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
				((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
		rand_log(LOG_INFO, "Time taken to get PASS:%d NONCE is: %.5f seconds ( OR %f minutes )\n",
				bzm_params.collected_noncecnt,
				var_total_execution_time, var_total_execution_time/60);
		/** Time Calculation END **/

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}
	ret|= verify_noncecollected(true);

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_jobsubmit_with_writejobcmd()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	if(ret)
		ret|= verify_noncecollected(true);

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_jobsubmit_with_writejobcmd_with_timeprint()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.hw_sha256_pass = 0;
		bzm_params.hw_sha256_fail = 0;
		bzm_params.total_nonce_collected=0;
		bzm_params.expected_nonce_found=0;
		bzm_params.expected_nonce_not_found=0;
		bzm_params.total_job_done_sts_cnt = 0;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		t_starttime();

		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret|=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		//if(ret)
		//	break;
		uint32_t ret1=SUCCESS;
		ret1 =check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		ret|=ret1;
		t_endtime();
		if(ret1)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			//break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);

		uint32_t total_jobs_fail=0, missing_nonce=0, sha_fail=0;

		missing_nonce=bzm_params.exp_noncecnt-bzm_params.expected_nonce_found;

		sha_fail=bzm_params.expected_nonce_not_found;

		if(bzm_params.failcnt_shafail==1)
		{
			//only missed out nonce
			total_jobs_fail= missing_nonce;
		}
		else if(bzm_params.failcnt_shafail==2)
		{
			//only sha failure
			total_jobs_fail=sha_fail;
		}
		else
		{
			total_jobs_fail=missing_nonce+sha_fail;
		}
		rand_log(LOG_INFO,"\n\n");
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);
		rand_log(LOG_CRIT,"Expected Nonce Count=%d, SHA Verified Nonce Produced=%d, Total Failure Count=%d\n",bzm_params.exp_noncecnt, bzm_params.expected_nonce_found, total_jobs_fail);

		float passcnt = (float)bzm_params.expected_nonce_found;
		float failcnt = (float)total_jobs_fail;
		float totalcnt =(float)(passcnt+failcnt);
		float passrate = (float)(passcnt/totalcnt);
		float passing_rate_percentage = passrate*100;


		long double time;
		time=4294967294; //0xFFFFFFFE in decimal
		//(End nonce  Start nonce) * 3 * 1/2 / 25Mhz = 6,442,450,941 / 25 Mhz = ~258s
		time = ((time*3)/2)/(bzm_params.cfg.fastclk*1000*1000);
		if(bzm_params.cfg.jobcnt==2)
			time = time*2;
		rand_log(LOG_INFO, "Job processing Time - Expected = %Lf seconds... Actual Time taken = %.5f seconds\n",time, total_execution_time);

		rand_log(LOG_CRIT,"Pass Rate Percentage obtained  = %.2f\n\n",passing_rate_percentage);

		//if(ret)
		//	break;
	}

	//ret|= verify_noncecollected(true);

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_jobsubmit_with_writejobcmd_with_samepattern()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		if((ret = evb_ldo_off()))
			break;



		if((ret=set_vdddig_vddpll_voltage(bzm_params.cfg.vdd_dig,bzm_params.cfg.vdd_pll)))
			break;

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			applog(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
			ret=asic_global_reset(b,false);
			if(ret)
				break;

			ret=engine_init(b);
			if(ret)
				break;
		}

		initialize_board(1, 0);
		bzm_params.cfg.same_job=1;
		bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
		get_next_static_data_index();

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
		}
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.hw_sha256_pass = 0;
		bzm_params.hw_sha256_fail = 0;
		bzm_params.total_nonce_collected=0;
		bzm_params.expected_nonce_found=0;
		bzm_params.expected_nonce_not_found=0;
		bzm_params.total_job_done_sts_cnt = 0;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		t_starttime();

		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret|=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		//if(ret)
		//	break;
		uint32_t ret1=SUCCESS;
		ret1 =check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		ret|=ret1;
		t_endtime();
		if(ret1)
			break;

		if(bzm_params.cfg.ntc_read_en)
		{
			uint16_t thermal=0;
			mcu_get_ntc_thermal(bzm_params.mcu_dev, 0, 0, &thermal);
			rand_log(LOG_INFO, "NTC data = %.2f DegC\n",(float)thermal/100);

			//mcu_get_ntc_thermal(bzm_params.mcu_dev, 0, 0, &thermal);
			//rand_log(LOG_INFO, "NTC data = %.2f DegC\n",(float)thermal/100);
		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			//break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);

		uint32_t total_jobs_fail=0, missing_nonce=0, sha_fail=0;

		missing_nonce=bzm_params.exp_noncecnt-bzm_params.expected_nonce_found;

		sha_fail=bzm_params.expected_nonce_not_found;

		if(bzm_params.failcnt_shafail==1)
		{
			//only missed out nonce
			total_jobs_fail= missing_nonce;
		}
		else if(bzm_params.failcnt_shafail==2)
		{
			//only sha failure
			total_jobs_fail=sha_fail;
		}
		else
		{
			total_jobs_fail=missing_nonce+sha_fail;
		}

		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		rand_log(LOG_CRIT,"Expected Nonce Count=%d, SHA Verified Nonce Produced=%d, Total Failure Count=%d\n",bzm_params.exp_noncecnt, bzm_params.expected_nonce_found, total_jobs_fail);

		float passcnt = (float)bzm_params.expected_nonce_found;
		float failcnt = (float)total_jobs_fail;
		float totalcnt =(float)(passcnt+failcnt);
		float passrate = (float)(passcnt/totalcnt);
		float passing_rate_percentage = passrate*100;


		rand_log(LOG_CRIT,"Pass Rate Percentage obtained  = %.2f\n",passing_rate_percentage);

		//if(ret)
		//	break;
		bzm_params.cfg.bch_data_index++;
		disable_tdm();
	}

	ret|= verify_noncecollected(true);

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_jobsubmit_with_multicastwrite_per_row()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
						clear_jobdone_status_counters();
						bzm_params.hw_sha256_pass = 0;
						bzm_params.hw_sha256_fail = 0;
						bzm_params.total_nonce_collected=0;
						bzm_params.expected_nonce_found=0;
						bzm_params.expected_nonce_not_found=0;
						bzm_params.total_job_done_sts_cnt = 0;

						/** Time Initialization START **/
						double var_total_execution_time;
						struct timespec var_start_time= {0,0}, var_end_time= {0,0};
						/** Time Initialization END **/

						/** Execution Time START**/
						clock_gettime(CLOCK_MONOTONIC, &var_start_time);


						bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}


						//seq_id+=bzm_params.cfg.jobcnt;

						bzm_params.job_submit=bzm_params.cfg.jobcnt *ENGINE_COLUMN_PER_ASIC;

						bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit * ENGINE_COLUMN_PER_ASIC;
						rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

						rand_log(LOG_INFO, "\nWait for TDM results....\n");
						ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
						rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

						//if(ret)
						//	break;

						ret=check_1asic_1row_engine_status(b, a, r, (bzm_params.sw_timeout+160)*bzm_params.cfg.jobcnt);
						if(ret)
						{
							rand_log(LOG_ERROR, "[ERROR] - Engine didnt turn idle. Cancelling the job\n");
							uint8_t canceljob_mode=2;
							uart_command_multicast_write(bzm_params.uart_dev, b, a, r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);
							sleep(2);
							ret=check_1asic_1row_engine_status(b, a, r, (bzm_params.sw_timeout+160)*bzm_params.cfg.jobcnt);
							if(ret)
							{
								rand_log(LOG_ERROR, "[ERROR] - Engine didnt turn idle after cancelling the job.. breaking\n");
								goto END;
							}
						}


						/** Execution Time END **/
						/** Time Calculation START **/
						clock_gettime(CLOCK_MONOTONIC, &var_end_time);
						var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
								((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
						rand_log(LOG_INFO, "[b:%d, a:%d, r:%d, c:%d] - Time taken to complete %d write jobs is: %.5f seconds ( OR %f minutes )\n",b, a, r, c,
								bzm_params.job_submit, var_total_execution_time, var_total_execution_time/60);
						/** Time Calculation END **/

						//if(ret)
						//	break;

						if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
						{
							rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
							ret|= ERR_NONCE_CNT_MISMATCH;
							//break; /*breaking regression loop on failure */
						}



						ret|= verify_noncecollected(true);
						/** Time Calculation END **/
						uint32_t total_jobs_fail=0, missing_nonce=0, sha_fail=0;


						missing_nonce=bzm_params.exp_noncecnt-bzm_params.expected_nonce_found;

						sha_fail=bzm_params.expected_nonce_not_found;

						if(bzm_params.failcnt_shafail==1)
						{
							//only missed out nonce
							total_jobs_fail= missing_nonce;
						}
						else if(bzm_params.failcnt_shafail==2)
						{
							//only sha failure
							total_jobs_fail=sha_fail;
						}
						else
						{
							total_jobs_fail=missing_nonce+sha_fail;
						}

						rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

						rand_log(LOG_CRIT,"Expected Nonce Count=%d, SHA Verified Nonce Produced=%d, Total Failure Count=%d\n",bzm_params.exp_noncecnt, bzm_params.expected_nonce_found, total_jobs_fail);

						float passcnt = (float)bzm_params.expected_nonce_found;
						float failcnt = (float)total_jobs_fail;
						float totalcnt =(float)(passcnt+failcnt);
						float passrate = (float)(passcnt/totalcnt);
						float passing_rate_percentage = passrate*100;


						rand_log(LOG_CRIT,"Pass Rate Percentage obtained  = %.2f\n",passing_rate_percentage);
						break;
					}
				}
			}
		}
	}
	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_jobsubmit_with_writejobcmd_per_eng()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
						clear_jobdone_status_counters();
						bzm_params.hw_sha256_pass = 0;
						bzm_params.hw_sha256_fail = 0;
						bzm_params.total_nonce_collected=0;
						bzm_params.expected_nonce_found=0;
						bzm_params.expected_nonce_not_found=0;
						bzm_params.total_job_done_sts_cnt = 0;

						/** Time Initialization START **/
						double var_total_execution_time;
						struct timespec var_start_time= {0,0}, var_end_time= {0,0};
						/** Time Initialization END **/

						/** Execution Time START**/
						clock_gettime(CLOCK_MONOTONIC, &var_start_time);


						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}


						//seq_id+=bzm_params.cfg.jobcnt;

						bzm_params.job_submit=bzm_params.cfg.jobcnt;

						bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
						rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

						rand_log(LOG_INFO, "\nWait for TDM results....\n");
						ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
						rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

						//if(ret)
						//	break;

						ret=check_1engine_status(b, a, r, c, (bzm_params.sw_timeout+160)*bzm_params.cfg.jobcnt);
						if(ret)
						{
							rand_log(LOG_ERROR, "[ERROR] - Engine didnt turn idle. Cancelling the job\n");
							uint8_t canceljob_mode=2;
							uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);
							sleep(2);
							ret=check_1engine_status(b, a, r, c, bzm_params.sw_timeout*bzm_params.cfg.jobcnt+160);
							if(ret)
							{
								rand_log(LOG_ERROR, "[ERROR] - Engine didnt turn idle after cancelling the job.. breaking\n");
								goto END;
							}
						}


						/** Execution Time END **/
						/** Time Calculation START **/
						clock_gettime(CLOCK_MONOTONIC, &var_end_time);
						var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
								((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
						rand_log(LOG_INFO, "[b:%d, a:%d, r:%d, c:%d] - Time taken to complete %d write jobs is: %.5f seconds ( OR %f minutes )\n",b, a, r, c,
								bzm_params.job_submit, var_total_execution_time, var_total_execution_time/60);
						/** Time Calculation END **/

						//if(ret)
						//	break;

						if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
						{
							rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
							ret|= ERR_NONCE_CNT_MISMATCH;
							//break; /*breaking regression loop on failure */
						}



						ret|= verify_noncecollected(true);
						/** Time Calculation END **/
						uint32_t total_jobs_fail=0, missing_nonce=0, sha_fail=0;


						missing_nonce=bzm_params.exp_noncecnt-bzm_params.expected_nonce_found;

						sha_fail=bzm_params.expected_nonce_not_found;

						if(bzm_params.failcnt_shafail==1)
						{
							//only missed out nonce
							total_jobs_fail= missing_nonce;
						}
						else if(bzm_params.failcnt_shafail==2)
						{
							//only sha failure
							total_jobs_fail=sha_fail;
						}
						else
						{
							total_jobs_fail=missing_nonce+sha_fail;
						}

						rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

						rand_log(LOG_CRIT,"Expected Nonce Count=%d, SHA Verified Nonce Produced=%d, Total Failure Count=%d\n",bzm_params.exp_noncecnt, bzm_params.expected_nonce_found, total_jobs_fail);

						float passcnt = (float)bzm_params.expected_nonce_found;
						float failcnt = (float)total_jobs_fail;
						float totalcnt =(float)(passcnt+failcnt);
						float passrate = (float)(passcnt/totalcnt);
						float passing_rate_percentage = passrate*100;


						rand_log(LOG_CRIT,"Pass Rate Percentage obtained  = %.2f\n",passing_rate_percentage);

					}
				}
			}
		}
	}
	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_tdm_jobsubmit_with_writejobcmd_per_row()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	//uint32_t r=bzm_params.row;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
				{
					continue;
				}
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0){
							continue;
						}

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

					}
				}
			}
		}
		seq_id+=1;

		bzm_params.job_submit = bzm_params.engine_count;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

		//if(ret)
		//	break;

		ret=check_all_engine_status(bzm_params.sw_timeout+160);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		//ret|= verify_noncecollected(true);
		if(ret)
			break;
	}
	ret|= verify_noncecollected(true);

	uint32_t total_jobs_fail=0, missing_nonce=0, sha_fail=0;


	missing_nonce=bzm_params.exp_noncecnt-bzm_params.expected_nonce_found;

	sha_fail=bzm_params.expected_nonce_not_found;

	if(bzm_params.failcnt_shafail==1)
	{
		//only missed out nonce
		total_jobs_fail= missing_nonce;
	}
	else if(bzm_params.failcnt_shafail==2)
	{
		//only sha failure
		total_jobs_fail=sha_fail;
	}
	else
	{
		total_jobs_fail=missing_nonce+sha_fail;
	}

	rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

	rand_log(LOG_CRIT,"Expected Nonce Count=%d, SHA Verified Nonce Produced=%d, Total Failure Count=%d\n",bzm_params.exp_noncecnt, bzm_params.expected_nonce_found, total_jobs_fail);

	float passcnt = (float)bzm_params.expected_nonce_found;
	float failcnt = (float)total_jobs_fail;
	float totalcnt =(float)(passcnt+failcnt);
	float passrate = (float)(passcnt/totalcnt);
	float passing_rate_percentage = passrate*100;


	rand_log(LOG_CRIT,"Pass Rate Percentage obtained  = %.2f\n",passing_rate_percentage);

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_jobsubmit_with_writeregcmd()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}



	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


int test_tdm_jobsubmit_to_1engine()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	uint32_t a=0,r=0,c=0;

	char input[50];
	char *endptr;

	printf("\nEnter Asic Row and Column ID  : ");
	fgets(input, sizeof input, stdin);


	a = (uint32_t)strtoul(input, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	bzm_params.sw_timeout= bzm_params.sw_timeout*bzm_params.cfg.jobcnt;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			/** Time Initialization START **/
			double var_total_execution_time;
			struct timespec var_start_time= {0,0}, var_end_time= {0,0};
			/** Time Initialization END **/

			/** Execution Time START**/
			clock_gettime(CLOCK_MONOTONIC, &var_start_time);
			bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
			seq_id++;
			if(bzm_params.cfg.jobcnt==2)
			{

				bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
			}
			seq_id++;
			bzm_params.job_submit=bzm_params.cfg.jobcnt;
			bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
			rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
			rand_log(LOG_INFO, "\nWait for TDM results....\n");
			ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
			rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			//if(ret)
			//	goto END;
			ret=check_1engine_status(b,a,r,c,bzm_params.sw_timeout);
			if(ret)
				goto END;

			/** Execution Time END **/
			/** Time Calculation START **/
			clock_gettime(CLOCK_MONOTONIC, &var_end_time);
			var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
					((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
			rand_log(LOG_INFO, "[b:%d, a:%d, r:%d, c:%d] - Time taken to complete %d write jobs is: %.5f seconds ( OR %f minutes )\n",b, a, r, c,
					bzm_params.job_submit, var_total_execution_time, var_total_execution_time/60);
			/** Time Calculation END **/

			if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				//goto END;
			}
		}

		//	ret|= verify_noncecollected(true);
		//	if(ret)
		//		break;
	}
	ret|= verify_noncecollected(true);

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_nontdm_jobsubmit_to_1engine_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t a=0,r=0,c=0;

	char input[50];
	char *endptr;

	printf("\nEnter Asic Row and Column ID  : ");
	fgets(input, sizeof input, stdin);


	a = (uint32_t)strtoul(input, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 1);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	bzm_params.sw_timeout= bzm_params.sw_timeout*bzm_params.cfg.jobcnt;
	bzm_params.verify_nonce_received=true;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
			seq_id++;
			if(bzm_params.cfg.jobcnt==2)
			{

				bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
			}
			seq_id++;
			bzm_params.job_submit=bzm_params.cfg.jobcnt;
			bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
			rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

			ret=nontdm_readresult_from_1engines_frf1(b,a,r,c,bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
			rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			//if(ret)
			//	goto END;


			if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				//goto END;
			}

		}

		//	ret|= verify_noncecollected(true);
		//	if(ret)
		//		break;
	}


	//END:
	//notch_register_dump(0,a);
	//engine_register_dump(0,a,r,c);
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_canceljob()
{

	int ret=SUCCESS;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	uint32_t mode0_result ,mode2_result,mode3_result;

	initialize_board(1, 0);

	mode0_result = load_and_cancel_job(CANCEL_PENDING_JOB, false, false);
	rand_log(LOG_INFO,"CANCEL_PENDING_JOB - Mode0 Result=%d \n",mode0_result);

	usleep(2000);
	mode2_result = load_and_cancel_job(CANCEL_CUR_PENDING_JOB, false,false);
	rand_log(LOG_INFO,"CANCEL_CUR_PENDING_JOB - Mode2 Result=%d \n",mode2_result);

	usleep(2000);
	mode3_result = load_and_cancel_job(CANCEL_CURRENT_JOB, false,false);
	rand_log(LOG_INFO,"CANCEL_CURRENT_JOB - Mode3 Result=%d \n",mode3_result);

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	if( (mode0_result == 0) && (mode2_result == 0) && (mode3_result == 0) )
	{
		ret=SUCCESS;
	}
	else
	{
		ret= ERR_CANCELJOB_MODE_FAILURE;
	}

	return ret;

}


int test_tdm_delay_counter_variation()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t tdm_delay = 0;
	uint32_t value = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		tdm_delay = rand()%3; //delay counter value to beprogrammed 2bit data

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				value = 0;

				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay);
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));
				rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, a, value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_disable_enable_engine()
{


	int ret = SUCCESS;

	uint8_t seq_id=0;


	//int disable_seq_id =1;
	uint32_t disabled_b=0,disabled_a=0,disabled_r=0,disabled_c=0;

	uint32_t exp_jobs_for_disabled_eng = 0;
	uint32_t exp_jobs_per_engine=0;
	bool engine_disabled = false;


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1,0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {

		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		engine_disabled = false;

		if(bzm_params.cfg.boardcount>1)
		{
			disabled_b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			disabled_b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[disabled_b],bzm_params.asic_count);
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		else
		{
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[disabled_b][disabled_a],bzm_params.enginecount_per_asic);
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			randomize(bzm_params.active_col_id[disabled_b][disabled_a][disabled_r],bzm_params.enginecount_per_asic);
			disabled_c =  bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}
		else
		{
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			disabled_c = bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						if((b==disabled_b) && (a==disabled_a) && (r==disabled_r) && (c==disabled_c))
						{
							//if(seq_id == disable_seq_id){
							rand_log(LOG_INFO, "Disabling engine id with b:%d a:%d r:%d c:%d\n", b, a, r, c );
							uint32_t engine_offset = 0x80;
							uint32_t row_offset = (r) << 1;
							uint32_t col_offset = 0; //MSB of Column
							uint32_t value = (1<<c);
							engine_offset = engine_offset | row_offset | col_offset;
							uart_command_writereg(bzm_params.uart_dev, b,a,NOTCH_REG,engine_offset,4,&value);
							engine_disabled = true;
						}

						exp_jobs_per_engine=write_bch_data(false,true,false,true, b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						bzm_params.exp_noncecnt+= exp_jobs_per_engine;
						if(engine_disabled == true)
						{
							exp_jobs_for_disabled_eng = exp_jobs_per_engine;
							engine_disabled = false;
						}


					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		bzm_params.exp_noncecnt = bzm_params.exp_noncecnt - exp_jobs_for_disabled_eng;
		bzm_params.exp_jobdone_sts_cnt = (bzm_params.job_submit)-1;


		rand_log(LOG_INFO, "JOB_SUBMITTED=%d EXPECTED_NONCE_COUNT = %d\n",bzm_params.job_submit,bzm_params.exp_noncecnt);


		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		if(bzm_params.engine_count==1)
		{

			bzm_params.poll_eng_idle=true;
			ret=check_all_engine_status(bzm_params.sw_timeout);
			if(ret)
				break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;
		}



		rand_log(LOG_INFO, "Enabling engine id with b:%d a:%d r:%d c:%d\n",  disabled_b,disabled_a,disabled_r,disabled_c);
		bzm_params.collected_noncecnt=0;
		uint32_t engine_offset = 0x80;
		uint32_t row_offset = (disabled_r) << 1;
		uint32_t col_offset = 0; //MSB of Column
		uint32_t value = (0<<disabled_c);
		engine_offset = engine_offset | row_offset | col_offset;
		uart_command_writereg(bzm_params.uart_dev, disabled_b,disabled_a,NOTCH_REG,engine_offset,4,&value);

		bzm_params.poll_eng_idle=true;
		rand_log(LOG_INFO, "\nWait for b:%d a:%d r:%d c:%d engine fifo to become empty...\n",disabled_b,disabled_a,disabled_r,disabled_c);
		ret=check_1engine_status(disabled_b,disabled_a,disabled_r,disabled_c,bzm_params.sw_timeout);
		if(ret)
			break;

		rand_log(LOG_INFO,"JOB_DONE after enabling engine = %d\n",bzm_params.collected_noncecnt);
		if(bzm_params.collected_noncecnt == exp_jobs_for_disabled_eng){
			ret = SUCCESS;
		}
		else
		{
			if((exp_jobs_for_disabled_eng>4) && (bzm_params.collected_noncecnt == 4))
			{
				rand_log(LOG_ERROR, "[ERROR-EXPECTED] -EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d. DROPPED_OFF_RESULTS=%d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt,(exp_jobs_for_disabled_eng-bzm_params.collected_noncecnt));
				ret = SUCCESS;
			}
			else
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				break;
			}
		}

		if(bzm_params.job_done_sts_enabled)
		{
			//if(exp_jobs_for_disabled_eng <=4)
			bzm_params.exp_jobdone_sts_cnt+=1;
			if( bzm_params.exp_jobdone_sts_cnt == bzm_params.total_job_done_sts_cnt )
				rand_log(LOG_INFO,"Received the expected job done %d\n",bzm_params.exp_jobdone_sts_cnt);
			else
			{
				rand_log(LOG_ERROR,"[ERROR] Job done status count mismatch. Expected=%d Received=%d\n",bzm_params.exp_jobdone_sts_cnt,bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
				goto END;
			}
		}



	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_writejob_readresult_pnp()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	if(bzm_params.cfg.prj == BZM2)
	{
		if(bzm_params.notch_initialized==false)
			initialize_board(1, 0);
	}
	else
	{
		initialize_board(1, 0);
	}

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	//bzm_params.tdm_divider_value = 125;
	bzm_params.tdm_divider_value = 0xFF;
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, tdm_result_callback, &bzm_params.collected_noncecnt);


	/** Time Initialization START **/
	double var_total_execution_time;
	struct timespec var_start_time= {0,0}, var_end_time= {0,0};
	/** Time Initialization END **/

	/** Execution Time START**/
	clock_gettime(CLOCK_MONOTONIC, &var_start_time);


	bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if(bzm_params.asic_exist[b][a] == 0)
				continue;

			for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
			{
				for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
				{
					if(bzm_params.engine_exist[b][a][r][c] == 0)
						continue;

					bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);

				}
			}
		}
	}
	seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

	bzm_params.job_submit = bzm_params.engine_count;
	bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

	rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
	/** Execution Time END **/
	/** Time Calculation START **/
	clock_gettime(CLOCK_MONOTONIC, &var_end_time);
	var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
			((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
	rand_log(LOG_INFO, "Time taken to send %d write jobs is: %.5f seconds ( OR %f minutes )\n",
			bzm_params.job_submit, var_total_execution_time, var_total_execution_time/60);
	/** Time Calculation END **/


	/** Execution Time START **/
	clock_gettime(CLOCK_MONOTONIC, &var_start_time);


	rand_log(LOG_INFO, "\nWait for TDM results....\n");
	ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
	rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

	if(bzm_params.cfg.prj != EDM)
	{
		if(ret)
			goto END;
	}


	rand_log(LOG_INFO, "\nWait for Engine Idle....\n");

	if(bzm_params.cfg.prj == EDM)
		ret=check_all_engine_status(bzm_params.sw_timeout+670);
	else
		ret=check_all_engine_status(bzm_params.sw_timeout);

	if(ret)
		goto END;

	/** Execution Time END **/
	/** Time Calculation START **/
	clock_gettime(CLOCK_MONOTONIC, &var_end_time);
	var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
			((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
	rand_log(LOG_INFO, "Time taken to get PASS:%d NONCE is: %.5f seconds ( OR %f minutes )\n",
			bzm_params.collected_noncecnt,
			var_total_execution_time, var_total_execution_time/60);
	/** Time Calculation END **/


	if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
	{
		rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		ret = ERR_NONCE_CNT_MISMATCH;
		goto END;
	}



	ret |= verify_noncecollected(true);
	if(ret)
		goto END;

	END:
	ret |= verify_noncecollected(true);
	uint32_t total_jobs_fail=0, missing_nonce=0, sha_fail=0;


	missing_nonce=bzm_params.exp_noncecnt-bzm_params.expected_nonce_found;

	sha_fail=bzm_params.expected_nonce_not_found;

	if(bzm_params.failcnt_shafail==1)
	{
		//only missed out nonce
		total_jobs_fail= missing_nonce;
	}
	else if(bzm_params.failcnt_shafail==2)
	{
		//only sha failure
		total_jobs_fail=sha_fail;
	}
	else
	{
		total_jobs_fail=missing_nonce+sha_fail;
	}

	rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d,  VALID_NONCE=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt, bzm_params.expected_nonce_found);

	rand_log(LOG_CRIT,"Expected Nonce Count=%d, SHA Verified Nonce Produced=%d, Total Failure Count=%d\n",bzm_params.exp_noncecnt, bzm_params.expected_nonce_found, total_jobs_fail);

	float passcnt = (float)bzm_params.expected_nonce_found;
	float failcnt = (float)total_jobs_fail;
	float totalcnt =(float)(passcnt+failcnt);
	float passrate = (float)(passcnt/totalcnt);
	float passing_rate_percentage = passrate*100;


	rand_log(LOG_CRIT,"Pass Rate Percentage obtained  = %.2f\n",passing_rate_percentage);
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_uart_parameter_settings_fpga(uint8_t stop_bit, uint32_t slowclk, uint32_t fgpa_baudrate)
{

	int ret=SUCCESS;
	uint32_t baudrate_div, nano_baudrate_div;
	//uint32_t uart_tx_ctrl=0;
	//static int fncallcntfpga=0;
	rand_log(LOG_DEBUG,"\n *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	rand_log(LOG_DEBUG,"\n Recommended zImage with GIT: https://android.intel.com/#/c/671225/1 \n");
	rand_log(LOG_DEBUG,"\n UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops\n");

	if(bzm_params.cfg.nano_uart_clk == 160)
	{
		nano_baudrate_div = bzm_params.nano_baud_rate[fgpa_baudrate];
		baudrate_div = bzm_params.asic_baud_rate[fgpa_baudrate];
	}
	else
	{
		nano_baudrate_div=bzm_params.nano_baud_rate[fgpa_baudrate];
		baudrate_div = bzm_params.asic_baud_rate[fgpa_baudrate];
	}


	sleep(1);

	disable_tdm();


	if(bzm_params.cfg.prj !=BZM2)
	{
		//disable_tdm();
		/** Close UART Post, which is opened by UART Init START **/
		rand_log(LOG_INFO,"\n Calling uart_close(uart_dev)\n");
		uart_dev_close();
		//uart_close(uart_dev);
		sleep(2);
		/** Close UART Post, which is opened by UART Init END **/

		/** Initial Configuration START **/
		rand_log(LOG_INFO,"\n Calling uart_init()\n");
		bzm_params.uart_dev = uart_init(bzm_params.default_baudrate,1);

		/** Initial Configuration END **/

		/** Initial Configuration START **/

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			uart_drain(bzm_params.uart_dev,b);
			uart_flush(bzm_params.uart_dev,b);
			rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
			ret=asic_global_reset(b,false);
			if(ret)
				return ret;
			ret=engine_init(b);
			if(ret)
				return ret;
		}

	}
	//if(fncallcntfpga==0)
	//	initialize_board(1, 0);

	//if(bzm_params.cfg.prj == BZM2)
	//	fncallcntfpga=1;

	/** Initial Configuration END **/

	sleep(2);

	uint32_t FPGA_baud =0;



	for (int b = BOARD_PER_DEVICE-1; b >= 0; b--)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		printf("board=%d\n",b);

		/**
        uart_command_writereg(uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &slowclk);
        FPGA_baud = (stop_bit << 3) | fgpa_baudrate | 0x0020;  //program divisor to value 7
        uart_command_writereg(uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 1, &FPGA_baud);
        uart_configure(uart_dev, baud_rate_50[fgpa_baudrate], stop_bit, 0);
		 **/

		/**********************************************/
		//Read Default Value
		for (int a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
				continue;

			/**********************************************/
#if 0
			//Disable DTS if BZM2 so that uart line is idle for baudrate change
			if(bzm_params.cfg.enable_dts_callback == true)
			{
				if(bzm_params.tdm_enabled)
					uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &uart_tx_ctrl);
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &uart_tx_ctrl);
				rand_log(LOG_INFO, "board:%d LOCAL_REG_UART_TX: 0x%x\n",b,uart_tx_ctrl);
				uint32_t control=0;
				control=uart_tx_ctrl & 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);


			}
#endif
			uint32_t tmp_slowclk_value = 0;
			if(bzm_params.tdm_enabled)
				uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &tmp_slowclk_value);
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &tmp_slowclk_value);
			rand_log(LOG_INFO, "[ Default ] board:%d LOCAL_REG_SLOW_CLK_DIV: 0x%x\n",b,tmp_slowclk_value);


		}



		//slowclk=0x2;	// change it to 0x02 or 0x04 0r 0x08 or 0x10 to submit different divisor value

		rand_log(LOG_INFO, "[ Changing Value ] board:%d LOCAL_REG_SLOW_CLK_DIV: 0x%x\n",b,slowclk);

		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &slowclk);
		sleep(5);
		for (int a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
			{
				continue;
			}
			/**********************************************/
			uint32_t tmp_slowclk_value = 0;
			if(bzm_params.tdm_enabled)
				uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &tmp_slowclk_value);
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &tmp_slowclk_value);
			if (slowclk!=tmp_slowclk_value)
			{
				rand_log(LOG_INFO, "[ After Change ] board:%d LOCAL_REG_SLOW_CLK_DIV: ( Change FAIL ): 0x%x (Expected :0x%x)\n",b,tmp_slowclk_value,slowclk);
				ret=FAILURE;
			}
			else
			{
				rand_log(LOG_INFO, "[ After Change ] board:%d LOCAL_REG_SLOW_CLK_DIV: ( Change PASS ): 0x%x (Expected :0x%x)\n",b,tmp_slowclk_value,slowclk);

			}

		}
		bzm_params.slow_clk_updated=true;
		/**********************************************/

		//sleep(3);

		/**********************************************/

		uint32_t tmp_FPGA_baud =0;

		for (int a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
			{
				continue;
			}
			if(bzm_params.tdm_enabled)
				uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 4, &tmp_FPGA_baud);
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 4, &tmp_FPGA_baud);
			rand_log(LOG_INFO, "[ Default ] board:%d, ASIC:%d LOCAL_REG_UART_LINE_CTL: 0x%x\n",b,a,tmp_FPGA_baud);
		}
		//FPGA_baud = 0;	// change it between 0-7 to change baud rate through LOCAL_REG_UART_LINE_CTL
		if(bzm_params.cfg.prj == BZM2)
			FPGA_baud = ( stop_bit << 3 ) |  baudrate_div;
		else
			FPGA_baud = ( stop_bit << 3 ) | ( baudrate_div | 0x0020);  //program divisor to value 7
		rand_log(LOG_INFO, "[ Changing Value for FPGA ] board:%d LOCAL_REG_UART_LINE_CTL: 0x%x\n",b,FPGA_baud);
		// for FPGA Change Baudrate : LOCAL_REG_UART_LINE_CTL

		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 4, &FPGA_baud);

		sleep(5);


	}//BOARD_PER_DEVICE


	/**********************************************/

	uart_configure(bzm_params.uart_dev, nano_baudrate_div, stop_bit, 0);

	/**********************************************/

	sleep(5);

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;

		uint32_t tmp_FPGA_baud =0;
		for (int a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
			{
				continue;
			}
			if(bzm_params.tdm_enabled)
				uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 4, &tmp_FPGA_baud);
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 4, &tmp_FPGA_baud);
			if (FPGA_baud!=tmp_FPGA_baud)
			{
				rand_log(LOG_INFO, "[ After Change ] board:%d, ASIC:%d, LOCAL_REG_UART_LINE_CTL ( Change FAIL ): 0x%x (Expected :0x%x)\n",b,a,tmp_FPGA_baud, FPGA_baud);
				ret=FAILURE;
			}
			else
			{
				rand_log(LOG_INFO, "[ After Change ] board:%d, ASIC:%d, LOCAL_REG_UART_LINE_CTL ( Change PASS ): 0x%x (Expected :0x%x)\n",b,a,tmp_FPGA_baud, FPGA_baud);
			}
#if 0
			if(bzm_params.cfg.enable_dts_callback == true)
			{

				uint32_t control=uart_tx_ctrl;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);
				uart_tx_ctrl=0;
				if(bzm_params.tdm_enabled)
					uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &uart_tx_ctrl);
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &uart_tx_ctrl);
				rand_log(LOG_INFO, "board:%d LOCAL_REG_UART_TX: 0x%x\n",b,uart_tx_ctrl);
			}
#endif

		}

		//sleep(3);

	}//BOARD_PER_DEVICE


	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

//**********

int test_slowclk_baudrate_stopbit_variation()
{
	int ret=SUCCESS;

	rand_log(LOG_INFO,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST START ] : P1a.7, P1a.11, P1a.6  \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.7] TDM with different STOP Bit variations in each ASIC\n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.11] UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.6] TDM with varied BAUD rate for each ASIC \n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(uint32_t stopbit=0; stopbit<=1; stopbit++)
	{
		for(uint32_t fpga_baudrate=0; fpga_baudrate<=7; fpga_baudrate++)
		{
			for(uint32_t slowclk=2; slowclk<=16; slowclk = slowclk * 2)
			{

				/**
                    StopBit: possible values are
                        DEC: 0 and 1

                    fpga_baudrate: possible values are
                        DEC: 0 to 7

                    slowclk: possible values are
                        HEX: 0x2, 0x4, 0x8, 0x10
                        DEC: 2, 4, 8, 16
				 **/

				rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
				rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - StopBit:%d, FPGA-BaudRate:%d, SlowClk:%d \n",stopbit,fpga_baudrate,slowclk);
				rand_log(LOG_INFO,"=========================================================================\n\n\n" );

				ret = test_uart_parameter_settings_fpga(stopbit,slowclk,fpga_baudrate);
				if(ret==SUCCESS)
				{
					ret = test_tdm_writejob_readresult_pnp();
				}

				char status[20];
				if(ret==SUCCESS)
					strcpy(status,"PASSED");
				else
					strcpy(status,"FAILED");

				rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
				rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - StopBit:%d, FPGA-BaudRate:%d, SlowClk:%d ( or 0x%x )-  status: %s\n",stopbit, fpga_baudrate,slowclk,slowclk,status);
				rand_log(LOG_INFO,"=========================================================================\n\n\n" );

			}
		}
	}
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST END ] : P1a.7, P1a.11, P1a.6 \n");

	/**  Stop Bit / FPGA Baud Rate / Slow Clock Validation END **/

	/**
        -------------------------------------
        P1a..11     : UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops
        -------------------------------------
        FPGA Baud Rate / Slow Clock Validation START
        Execution Time: 17 * 8 * 5 =  680 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST START ] : P1a.11, P1a.6  \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.11] UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.6] TDM with varied BAUD rate for each ASIC \n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int fpga_baudrate=0; fpga_baudrate<=7; fpga_baudrate++)
	{
		for(int slowclk=2; slowclk<=16; slowclk = slowclk * 2)
		{
			/**
                fpga_baudrate: possible values are
                    DEC: 0 to 7

                slowclk: possible values are
                    HEX: 0x2, 0x4, 0x8, 0x10
                    DEC: 2, 4, 8, 16
			 **/

			rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
			rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - FPGA-BaudRate:%d, SlowClk:%d \n",fpga_baudrate,slowclk);
			rand_log(LOG_INFO,"=========================================================================\n\n\n" );

			ret = test_uart_parameter_settings_fpga(0,slowclk,fpga_baudrate);
			if(ret==SUCCESS)
			{
				ret = test_tdm_writejob_readresult_pnp();

			}

			char status[20];
			if(ret==SUCCESS)
				strcpy(status,"PASSED");
			else
				strcpy(status,"FAILED");

			rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
			rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - FPGA-BaudRate:%d, SlowClk:%d ( or 0x%x )-  status: %s\n",fpga_baudrate,slowclk,slowclk,status);
			rand_log(LOG_INFO,"=========================================================================\n\n\n" );


		}
	}
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST END ] : P1a.11, P1a.6 \n");

	/**  FPGA Baud Rate / Slow Clock Validation END **/

	//return ret_master;

	/**
       -------------------------------------
       P1a.6       : TDM with varied BAUD rate for each ASIC
       -------------------------------------
       FPGA Baud Rate Validation START
       Max Execution Time: 17 * 8 = 136 Minutes
       -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P1a.6 \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] TDM with varied BAUD rate for each ASIC \n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	sleep(3);

	for(uint32_t fpga_baudrate=0; fpga_baudrate<=7; fpga_baudrate++)
	{
		/**
            possible values are
                DEC: 0 to 7
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - FPGA-BaudRate:%d \n",fpga_baudrate);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(0,0x2,fpga_baudrate);
		if(ret==SUCCESS)
		{
			ret = test_tdm_writejob_readresult_pnp();
		}

		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - FPGA-BaudRate:%d -  status: %s\n",fpga_baudrate,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		sleep(5);

	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P1a.6 \n");


	/**  FPGA Baud Rate Validation END **/


	/**
        -------------------------------------
        P1a.7       : TDM with different STOP Bit variations in each ASIC
        -------------------------------------
        NANO & FPGA Stop Bit Validation START
        Execution Time: 17 * 2 = 34 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P1a.7 \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] TDM with different STOP Bit variations in each ASIC\n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int stopbit=0; stopbit<=1; stopbit++)
	{
		/**
            possible values are
                DEC: 0 and 1
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - StopBit:%d \n",stopbit);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(stopbit,0x2,0);
		if(ret==SUCCESS)
		{
			ret = test_tdm_writejob_readresult_pnp();
		}

		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - StopBit:%d -  status: %s\n",stopbit,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		//sleep(5);

		//rand_log(LOG_INFO,"waiting for 10 seconds before starting next test \n");
		//sleep(10);
	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P1a.7 \n");


	/** NANO & FPGA Stop Bit Validation END **/

	/**
        -------------------------------------
        P??.?? [ LOCAL_REG_SLOW_CLK_DIV ]
        -------------------------------------
        FPGA Slow Clock Validation START
        Execution Time: 17 * 5 = 85 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P??.?? [ LOCAL_REG_SLOW_CLK_DIV ] \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] Slow Clock variations in each ASIC\n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int slowclk=2; slowclk<=16; slowclk = slowclk * 2)
	{
		/**
            possible values are
                HEX: 0x2, 0x4, 0x8, 0x10
                DEC: 2, 4, 8, 16
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - SlowClock:%d ( or 0x%x ) \n",slowclk,slowclk);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(0,slowclk,0);
		if(ret==SUCCESS)
		{
			ret = test_tdm_writejob_readresult_pnp();
			if(ret!=SUCCESS)
			{
				rand_log(LOG_ERROR,"[INTERMEDIATE] TEST FAILED - SlowClock:%d ( or 0x%x ) at test_tdm_writejob_readresult_pnp\n",slowclk,slowclk);
			}
		}
		else
		{
			rand_log(LOG_ERROR,"[INTERMEDIATE] TEST FAILED - SlowClock:%d ( or 0x%x ) at test_uart_parameter_settings_NANO\n",slowclk,slowclk);
		}


		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - SlowClock:%d ( or 0x%x ) -  status: %s\n",slowclk,slowclk,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P??.?? [ LOCAL_REG_SLOW_CLK_DIV ] \n");

	/** FPGA Slow Clock Validation END **/

	rand_log(LOG_INFO,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	return ret;
}


int test_uart_tdm_asic_reset_stress()
{
	int ret = 0;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);


	for(int l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			applog(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
			ret=asic_global_reset(b,false);
			if(ret)
				goto END;

			ret=engine_init(b);
			if(ret)
				goto END;
		}

		initialize_board(1, 0);
		bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
		get_next_static_data_index();

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
		}

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (int c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						break;
					}
				}
			}
		}
		bzm_params.job_submit = bzm_params.engine_count;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"\nJOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
		{
			rand_log(LOG_INFO,"JOB_SUBMIT: %d and JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
			break;
		}

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		disable_tdm();

	}
	END:
	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);

	return ret;

}

int test_uart_tdm_engine_softreset_stress()
{
	int ret = 0;
	uint32_t nonce_cnt=0;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);


	initialize_board(1, 0);
	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(int l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				rand_log(LOG_INFO,"Issuing Engine soft reset to board:%d asic:%d\n",b,a);
				asic_soft_reset(b,a);
				rand_log(LOG_INFO,"Clock ungating engines of board:%d asic:%d\n",b,a);
				uint8_t cfg=0;
				engine_config(b,a,cfg);

				for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (int c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						nonce_cnt = write_bch_data(true,false,false,true, b, a, c, r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						break;
					}
				}
			}
		}
		bzm_params.job_submit = bzm_params.engine_count;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"\nJOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
		{
			rand_log(LOG_INFO,"JOB_SUBMIT: %d and JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
			break;
		}

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

	}
	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);

	return ret;

}

int test_uart_tdm_packet_enable_disable()
{

	int ret = SUCCESS;
	uint32_t seq_id=0;

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);


	initialize_board(1, 0);
	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
		uint32_t control=0x7;

		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);
	}
	for(int l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		//srand(time(0));
		//index = rand() %100;


		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				bzm_params.job_done_count = 0;
				bzm_params.job_done_count_new[b] = 0;
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (int c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						break;

					}
				}
				seq_id+=1;
				bzm_params.job_submit=bzm_params.engine_count;
				rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

				if((ret=tdm_noop_response_enable_disable(b,a))){
					goto END;
				}

				if((ret=tdm_readresult_response_enable_disable(b,a))){
					goto END;
				}


				if((ret=tdm_readreg_response_enable_disable(b,a))){
					ret = FAILURE;
					goto END;
				}

				rand_log(LOG_INFO, "\nWait for TDM results....\n");
				ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
				rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);



				ret=check_1asic_all_engine_status(b, a,bzm_params.sw_timeout);

				if(ret)
				{
					goto END;
				}
				rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

				if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
				{
					rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					ret = ERR_NONCE_CNT_MISMATCH;
					goto END; /*breaking regression loop on failure */
				}
				ret|= verify_noncecollected(true);
				if(ret)
					goto END;
			}
		}
	}
	END:
	applog(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);

	return ret;





}

int test_tdm_pwrcycle_stress()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();
	for(int l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		//srand(time(0));
		//index = rand() %100;

		for (int b = 0; b < BOARD_PER_DEVICE; b++) {
			if(b==bzm_params.cfg.boardcount)
				break;
			bzm_params.board_exist[b] = detect_board(b);
			if (bzm_params.board_exist[b] == 1)
			{
				rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);

				if(asic_global_reset(b,true))
					return 1;
				if(engine_init(b));
			}
		}


		initialize_board(1, 0);

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);

		}

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (int c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.exp_noncecnt+=write_bch_data(true,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						break;

					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;
		//job_submit = bzm_params.engine_count;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);


		if(ret)
		{
			break;
		}

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;
		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		disable_tdm();

	}
	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);

	return ret;


}






//idle_1: test_Idle1_Engines_NotOutofReset

int test_Idle1_Engines_NotOutofReset()
{
	int ret=SUCCESS;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	rand_log(LOG_INFO,"Start Time = %s: \n\n",get_datetime());

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);

			if(asic_global_reset(b,true))
				return FAILURE;
		}
	}

	bzm_params.cfg.enginecnt_for_testing = 0;
	rand_log(LOG_INFO,"\nWaiting for ASIC/Engine Discovery....\n");
	if(bzm_params.cfg.prj == BZM2)
	{

		if(bzm_params.cfg.sw_prg_asic_id)
			ret=sw_prog_asic_discovery();
		else
			ret=asic_discovery();

	}
	else
	{
		ret=asic_discovery();
	}
	if(ret == SUCCESS)
	{
		bzm_params.asic_discovered=true;

	}
	else
		return FAILURE;


	initialize_board(1, 0);
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}
	rand_log(LOG_INFO,"System entering idle for %d s. Please start Afactor now..\n",bzm_params.cfg.idle_time);
	sleep(bzm_params.cfg.idle_time);
	rand_log(LOG_INFO,"Exiting sleep\n");
	rand_log(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());

	//TODO : ADD NTC thermistor read

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return SUCCESS;
}


//idle 2: test_Idle2_Engines_AfterClockUngate

int test_Idle2_Engines_AfterClockUngate()
{

	uint8_t ret = SUCCESS;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO,"Start Time = %s: \n\n",get_datetime());
	initialize_board(1, 0);

	//if(bzm_params.cfg.prj == EDM)
	if(bzm_params.cfg.ntc_read_en)
	{
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
		}
		uint16_t thermal=0;
		rand_log(LOG_INFO,"System entering idle for %d s... \n",bzm_params.cfg.idle_time);
		uint32_t sleeptime = bzm_params.cfg.idle_time;

		while(1)
		{
			thermal=0x0;
			int b=0,a=0;
			mcu_get_ntc_thermal(bzm_params.mcu_dev, b, a, &thermal);
			rand_log(LOG_INFO, "NTC data = %.2f DegC\n",(float)thermal/100);

			sleep(1);
			sleeptime--;
			if(sleeptime==0)
				break;
		}
		rand_log(LOG_INFO,"Exiting sleep\n");
		rand_log(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
	}
	else
	{

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
		}

		rand_log(LOG_INFO,"System entering idle for %d s. Please start Afactor now..\n",bzm_params.cfg.idle_time);
		sleep(bzm_params.cfg.idle_time);
		rand_log(LOG_INFO,"Exiting sleep\n");
		rand_log(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			enable_tdm(false,false,b,bzm_params.tdm_divider_value,NULL);
		}
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_evb_powercycle()
{
	int ret =SUCCESS;
	uint32_t gpio[] = {483, 484, 485, 486};


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);
			gpio_export(gpio[b]);
			gpio_set_direction_output(gpio[b]);

			rand_log(LOG_INFO, "Setting Reset low in board %d\n",b);
			gpio_set_value(gpio[b], 0);

			/* TODO: sync with MCU, now just add 1 second sleep here */
			if((ret=mcu_initialize(true)))
				return ret;

			rand_log(LOG_INFO, "Setting Reset high in board %d\n",b);
			gpio_set_value(gpio[b], 1);
			/* wait 10ms */
			usleep(10000);

			gpio_unexport(gpio[b]);
		}
	}

	return ret;
}


int test_ldo_off()
{
	int ret =SUCCESS;
	uint32_t gpio[] = {483, 484, 485, 486};
	uint32_t stack_id=0;
	uint8_t boardpower =  0;
	uint8_t engpower = 0;
	uint32_t expected_stackid=bzm_params.cfg.boardcount-1;
	uint8_t secs_to_sleep = bzm_params.cfg.asiccount*2;

	if(mcu_dev_init())
		return ERR_MCU_INIT;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);
			gpio_export(gpio[b]);
			gpio_set_direction_output(gpio[b]);

			rand_log(LOG_INFO, "Setting Reset low in board %d\n",b);
			gpio_set_value(gpio[b], 0);


			while(1)
			{
				rand_log(LOG_INFO, "Doing LDO Power OFF..\n");

				mcu_update_power(bzm_params.mcu_dev,0,false);
				sleep(secs_to_sleep);
				stack_id = mcu_get_stack_id(bzm_params.mcu_dev,0);
				rand_log(LOG_INFO, "MCU Stack ID = 0x%x\n",stack_id);
				if(stack_id!=expected_stackid)
				{
					rand_log(LOG_ERROR, "[ERROR] - MCU Stack ID not %d\n",expected_stackid);
					mcu_uninit(bzm_params.mcu_dev);
					bzm_params.mcu_dev = mcu_init();
					if (!bzm_params.mcu_dev)
						return ERR_MCU_INIT;
					continue;
				}
				mcu_get_power_status(bzm_params.mcu_dev, 0,&boardpower, &engpower);
				rand_log(LOG_INFO, "After LDO Off - MCU boardpower = 0x%x; engpower = 0x%x\n",boardpower, engpower);
				if(boardpower ==1)
				{
					sleep(secs_to_sleep);
					mcu_get_power_status(bzm_params.mcu_dev, 0,&boardpower, &engpower);
					rand_log(LOG_INFO, "After LDO Off - MCU boardpower = 0x%x; engpower = 0x%x\n",boardpower, engpower);
					if(boardpower ==0)
						break;
				}
				if(boardpower==0)
					break;

			}

			rand_log(LOG_INFO, "Setting Reset high in board %d\n",b);
			gpio_set_value(gpio[b], 1);
			/* wait 10ms */
			usleep(10000);

			gpio_unexport(gpio[b]);
		}

	}
	if(bzm_params.board_exist[0]==0)
	{
		rand_log(LOG_ERROR, "[ERROR] - Board detect failed\n");
		ret=FAILURE;
	}

	return ret;
}

int test_ldo_on()
{
	int ret =SUCCESS;
	uint32_t gpio[] = {483, 484, 485, 486};
	uint32_t stack_id=0;
	uint8_t boardpower =  0;
	uint8_t engpower = 0;
	uint32_t expected_stackid=bzm_params.cfg.boardcount-1;
	uint8_t secs_to_sleep = bzm_params.cfg.asiccount*2;

	if(mcu_dev_init())
		return ERR_MCU_INIT;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);
			gpio_export(gpio[b]);
			gpio_set_direction_output(gpio[b]);

			rand_log(LOG_INFO, "Setting Reset low in board %d\n",b);
			gpio_set_value(gpio[b], 0);

			stack_id = mcu_get_stack_id(bzm_params.mcu_dev,0);
			rand_log(LOG_INFO, "MCU Stack ID = 0x%x\n",stack_id);
			if(stack_id!=expected_stackid)
			{
				rand_log(LOG_ERROR, "[ERROR] - MCU Stack ID not %d\n",expected_stackid);
				return ERR_MCU_INIT;

			}

			rand_log(LOG_INFO, "Doing LDO Power ON..\n");
			mcu_update_power(bzm_params.mcu_dev,0,true);
			sleep(secs_to_sleep);

			stack_id = mcu_get_stack_id(bzm_params.mcu_dev,0);
			rand_log(LOG_INFO, "MCU Stack ID = 0x%x\n",stack_id);
			if(stack_id!=expected_stackid)
			{
				return ERR_MCU_INIT;
			}


			mcu_get_power_status(bzm_params.mcu_dev, 0,&boardpower, &engpower);
			rand_log(LOG_INFO, "MCU boardpower = 0x%x; engpower = 0x%x\n",boardpower, engpower);
			if(boardpower!=1)
			{
				while(1) {
					sleep(secs_to_sleep);
					mcu_get_power_status(bzm_params.mcu_dev, 0,&boardpower, &engpower);
					rand_log(LOG_INFO, "MCU boardpower = 0x%x; engpower = 0x%x\n",boardpower, engpower);
					if(boardpower==1)
						break;
					rand_log(LOG_INFO, "Retry to turn on all LDO..\n");
					mcu_update_power(bzm_params.mcu_dev,0,true);
					sleep(secs_to_sleep);
					stack_id = mcu_get_stack_id(bzm_params.mcu_dev,0);
					rand_log(LOG_INFO, "MCU Stack ID = 0x%x\n",stack_id);
				}
			}

			//if(bzm_params.cfg.prj == EDM)
			{
				int dac_gpio = 401;
				gpio_export(dac_gpio);
				gpio_set_direction_output(dac_gpio);
				rand_log(LOG_INFO, "Setting GPIO 401 to low\n");
				gpio_set_value(dac_gpio, 0);
				gpio_unexport(dac_gpio);


			}

			rand_log(LOG_INFO, "Setting Reset high in board %d\n",b);
			gpio_set_value(gpio[b], 1);
			/* wait 10ms */
			usleep(10000);

			gpio_unexport(gpio[b]);
		}

	}
	if(bzm_params.board_exist[0]==0)
	{
		rand_log(LOG_ERROR, "[ERROR] - Board detect failed\n");
		ret=FAILURE;
	}

	return ret;
}


int test_edm_pll_variation_serial_mode()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t divider_val = 0, pre_scalar_val = 1;
	uint32_t possible_fastclk[7] = {400,500,600,700,800,900, 1000};
	uint8_t random_num=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		//random_num = rand()%5;
		if(random_num ==7)
			random_num=0;
		unsigned long long clk;
		clk = possible_fastclk[random_num++];
		clk*=1000000;
		clk*=pre_scalar_val;

		divider_val = clk/bzm_params.refclk;

		//divider_val = 10 + rand() % 16; 	//considering min 10 val for now -> fastclk = divider_val*50Mhz

		ret = enable_edm_pll_serial_mode(divider_val, pre_scalar_val,true);
		if(ret)
			break;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		t_starttime();
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		t_endtime();
		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}



	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_edm_pll_variation_parallel_mode()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t random_num=0;

	//uint32_t possible_fastclk[14] = {800,125,200,300,400,600,800,1200,1300,1500,1600,2000,2250,2700};
	uint32_t possible_fastclk[4] = {400, 600, 800, 1200}; //{400, 600, 800};

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}
	//ret = enable_edm_pll_parallel_mode();
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		//random_num = rand()%3;//rand()%13;
		if(random_num==4)
			random_num=0;
		ret=enable_edm_pll_parallel_mode(possible_fastclk[random_num++], true);

		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		t_starttime();
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);

		//if(ret)
		//	break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		t_endtime();
		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}



	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


int test_regwrite_broadcast_1asic()
{
	int ret = SUCCESS;

	for(uint32_t l = 0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				if(regwrite_broadcast_1asic(b, a, ENGINE_REG_MIDSTATE))
					return ERR_READVALUE_MISMATCH;
				if(regwrite_broadcast_1asic(b, a, ENGINE_REG_MRRESIDUE))
					return ERR_READVALUE_MISMATCH;
				if(regwrite_broadcast_1asic(b, a, ENGINE_REG_START_TIMESTAMP))
					return ERR_READVALUE_MISMATCH;
				if(regwrite_broadcast_1asic(b, a, ENGINE_REG_START_NONCE))
					return ERR_READVALUE_MISMATCH;
				if(regwrite_broadcast_1asic(b, a, ENGINE_REG_END_NONCE))
					return ERR_READVALUE_MISMATCH;
				if(regwrite_broadcast_1asic(b, a, ENGINE_REG_TARGET))
					return ERR_READVALUE_MISMATCH;
			}
		}
	}
	return ret;
}


int test_regwrite_broadcast_all_asic()
{
	int ret = SUCCESS;

	for(uint32_t l = 0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			if(regwrite_broadcast_all_asic(b, ENGINE_REG_MIDSTATE))
				return ERR_READVALUE_MISMATCH;
			if(regwrite_broadcast_all_asic(b, ENGINE_REG_MRRESIDUE))
				return ERR_READVALUE_MISMATCH;
			if(regwrite_broadcast_all_asic(b, ENGINE_REG_START_TIMESTAMP))
				return ERR_READVALUE_MISMATCH;
			if(regwrite_broadcast_all_asic(b, ENGINE_REG_START_NONCE))
				return ERR_READVALUE_MISMATCH;
			if(regwrite_broadcast_all_asic(b, ENGINE_REG_END_NONCE))
				return ERR_READVALUE_MISMATCH;
			if(regwrite_broadcast_all_asic(b, ENGINE_REG_TARGET))
				return ERR_READVALUE_MISMATCH;
		}
	}
	return ret;
}



int test_tmd_jobsubmit_with_broadcast_all_asic()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board (1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			bzm_params.exp_noncecnt+=write_bch_data(false,false,true,true, b, BROADCAST_ASIC, 0, BROADCAST_ENGINE, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
			if(bzm_params.cfg.jobcnt==2)
			{
				seq_id++;
				bzm_params.exp_noncecnt+=write_bch_data(false,false,true,true, b, BROADCAST_ASIC, 0, BROADCAST_ENGINE, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
				seq_id--;
			}

		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count*bzm_params.cfg.jobcnt;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_broadcast_canceljob()
{

	int ret=SUCCESS;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	uint32_t mode0_result ,mode2_result,mode3_result;

	initialize_board(1, 0);

	mode0_result = load_and_cancel_job(CANCEL_PENDING_JOB, true, false);
	rand_log(LOG_INFO,"CANCEL_PENDING_JOB - Mode0 Result=%d \n",mode0_result);

	usleep(2000);
	mode2_result = load_and_cancel_job(CANCEL_CUR_PENDING_JOB,true, false);
	rand_log(LOG_INFO,"CANCEL_CUR_PENDING_JOB - Mode2 Result=%d \n",mode2_result);

	usleep(2000);
	mode3_result = load_and_cancel_job(CANCEL_CURRENT_JOB,true, false);
	rand_log(LOG_INFO,"CANCEL_CURRENT_JOB - Mode3 Result=%d \n",mode3_result);

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	if( (mode0_result == 0) && (mode2_result == 0) && (mode3_result == 0) )
	{
		ret=SUCCESS;
	}
	else
	{
		ret= ERR_CANCELJOB_MODE_FAILURE;
	}

	return ret;

}



int test_loopback(void)
{
	int ret=0,resp=0;
	char buf[4];
	uint32_t asic_per_board[BOARD_PER_DEVICE];
	uint32_t asic_cnt=0;

	uint8_t buf_in[8];
	uint8_t buf_out[8];


	memset(bzm_params.board_exist, 0, sizeof(bzm_params.board_exist));

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = 1;
		ret = asic_global_reset(b,false);
		if(ret)
			goto END;
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		asic_cnt=0;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_per_board[b]=0;
			rand_log(LOG_INFO, "Finding asic in board %d....\n\n",b);
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				memset(buf, '\0', 4);

				resp=uart_command_noop(bzm_params.uart_dev, b, a, buf);
				if(resp)
				{
					if (strcmp(buf, bzm_params.expected_noop_resp) == 0)
					{
						asic_cnt++;
						asic_per_board[b]++;
						rand_log(LOG_INFO,"Found Asic %d in board %d\n",a,b);
						rand_log(LOG_INFO, "NOOP Response of [b:%d][a:%d] = %c %c %c\n", b, a, buf[0], buf[1], buf[2]);

						for(int i=0; i < 8; i=i+4)
							*(uint32_t *)&buf_in[i] = rand();

						rand_log(LOG_INFO, "\nSending LOOPBACK command to [b:%d][a:%d]\n",b,a);
						rand_log(LOG_INFO, "\nDATA_IN  : 0x");
						for (int i=0; i<8; i++)
						{
							rand_log(LOG_INFO,"%02x \n",buf_in[i]);
						}

						rand_log(LOG_INFO,"\n");
						uart_command_loopback(bzm_params.uart_dev, b, a, 8, buf_in, buf_out);
						rand_log(LOG_INFO, "\nDATA_OUT : 0x");
						for (int i=0; i<8; i++)
						{
							rand_log(LOG_INFO,"%02x \n",buf_out[i]);
						}

						rand_log(LOG_INFO,"\n");

						for (int i=0; i<8; i++)
						{
							if(buf_in[i]!=buf_out[i])
							{
								rand_log(LOG_ERROR,"[ERROR] - \nBuffer mismatch at offset %d. Expected=0x%x, Received=0x%x\n",i,buf_in[i],buf_out[i]);
								ret = 1;
								break;
							}

							if(sizeof(buf_out[i]) < sizeof(buf_in[i]))
							{
								rand_log(LOG_ERROR, "[ERROR] - \n Incomplete payload...");
								ret =1;
								break;
							}

						}



						if(ret)
							goto END;
						else
							rand_log(LOG_INFO,"DATA IN and OUT matched\n\n");

					}

				}

			}
			rand_log(LOG_INFO,"\nNo. of asic found in [b:%d] = %d\n\n",b,asic_per_board[b]);
		}
		if(asic_cnt==0)
		{
			rand_log(LOG_ERROR,"[ERROR] - No asic found\n");
			ret=1;
			break;
		}
		else
		{
			rand_log(LOG_INFO,"Total no. of asic found = %d\n\n",asic_cnt);
			ret=0;
		}

	}
	END:
	return ret;

}


int test_dummy_noop_for_2x2_image(void)
{
	rand_log(LOG_INFO,"Hello, world\n");
}



int test_noop_all_asic(void)
{
	int ret=SUCCESS;
	char buf[4];
	uint32_t asic_per_board[BOARD_PER_DEVICE];
	uint32_t asic_cnt=0;

	initialize_board(1, 0);

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		asic_cnt=0;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			asic_per_board[b]=0;
			applog(LOG_INFO, "Finding asic in board %d..\n",b);
			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				memset(buf, '\0', 4);

				ret = uart_command_noop(bzm_params.uart_dev, b, a, buf);
				if (strcmp(buf, bzm_params.expected_noop_resp) == 0)
				{
					applog(LOG_INFO, "NOOP Response of [b:%d] [a:%d] = %c %c %c\n", b, a, buf[0], buf[1], buf[2]);
					asic_cnt++;
					asic_per_board[b]++;
				}

			}
			rand_log(LOG_INFO,"\n\nNo. of asic found in [b:%d] = %d\n\n",b,asic_per_board[b]);
		}
		if(asic_cnt !=bzm_params.asic_count)
		{
			rand_log(LOG_ERROR,"[ERROR] - Noop failure. Asics count does not match. expected=%d found=%d\n",bzm_params.asic_count,asic_cnt);
			ret=ERR_ASIC_DISCOVERY;
			break;
		}
		else
		{
			rand_log(LOG_INFO,"Total no. of asic found = %d\n\n",asic_cnt);
			ret=SUCCESS;
		}

	}
	return ret;

}


////////////////

int read_edm_notch_registers(int b, int a)
{
	uint32_t value;
	uint8_t val;
	uint8_t ret = 0;


	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_RESULT_STS_CTL, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_RESULT_STS_CTL:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_result_sts_ctl){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_RESULT_STS_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_RESULT_STS_CTL, default_reg_val.loc_reg_result_sts_ctl, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG0, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG0:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG0, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG1, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG1:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG1, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG2, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG2:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG2 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG2, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG3, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG3:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG3 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG3, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SPI_STS_CTL, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_SPI_STS_CTL:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_spi_sts_ctl){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_SPI_STS_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_SPI_STS_CTL, default_reg_val.loc_reg_spi_sts_ctl, value);
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TDM_CTL, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_TDM_CTL:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_TDM_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_TDM_CTL, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_SLOW_CLK_DIV:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_slow_clk_div){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_SLOW_CLK_DIV (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_SLOW_CLK_DIV, default_reg_val.loc_reg_slow_clk_div, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_tdm_delay){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_TDM_DELAY (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_TDM_DELAY, default_reg_val.loc_reg_tdm_delay, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_TX:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_uart_tx){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_TX (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_TX, default_reg_val.loc_reg_uart_tx, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_UDB_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_UDB_REG:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_PLL_UDB_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_PLL_UDB_REG, default_reg_val.default_value_zero, value);
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_ENABLE_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_ENABLE_REG:0x%x\n", b, a, value);
	if((value!=default_reg_val.default_value_zero) &&  (value!=4)){

		rand_log(LOG_ERROR,"[ERROR] - \bDefault Value Mismatch for EDM_PLL_ENABLE_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_PLL_ENABLE_REG, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ENG_SOFT_RESET, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ENG_SOFT_RESET:0x%x\n", b, a, value);
	uint expectedvalue=0;
	if(bzm_params.cfg.enginecnt_for_testing==0)
		expectedvalue=0;
	else
		expectedvalue=1;
	//if(value!=default_reg_val.default_value_zero){
	if(value!=expectedvalue){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ENG_SOFT_RESET (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ENG_SOFT_RESET, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_SPI_TAP, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_SPI_TAP:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_uart_spi_tap){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_SPI_TAP (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_SPI_TAP, default_reg_val.loc_reg_uart_spi_tap, value);
		ret = 1;

	}
#if 0
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_TUNE_CODE, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TEMPSENSOR_TUNE_CODE:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_tempsensor_tune_code){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_TEMPSENSOR_TUNE_CODE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_TEMPSENSOR_TUNE_CODE, default_reg_val.loc_reg_tempsensor_tune_code, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TRIP_STATUS, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_TRIP_STATUS:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_TRIP_STATUS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_TRIP_STATUS, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TEMP_CODE, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_TEMP_CODE:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_TEMP_CODE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_TEMP_CODE, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SAR_COUNT_LOAD , 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_SAR_COUNT_LOAD :0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_thermal_sar_count_load){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_SAR_COUNT_LOAD (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_SAR_COUNT_LOAD, default_reg_val.loc_reg_thermal_sar_count_load, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SAR_STATE_RESET, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_SAR_STATE_RESET:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_SAR_STATE_RESET (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_SAR_STATE_RESET,default_reg_val.default_value_zero, value );
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_STATUS, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_STATUS:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_STATUS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_STATUS, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_DFT, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_DFT:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_DFT (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_DFT, default_reg_val.default_value_zero, value);
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_BANDGAP, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_BANDGAP:0x%x\n", b, a, value);
	if(value!=default_reg_val.loc_reg_bandgap){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_BANDGAP (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_BANDGAP, default_reg_val.loc_reg_bandgap, value);
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_MISC, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_MISC:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_MISC (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_MISC, default_reg_val.default_value_zero, value);
		ret = 1;

	}
#endif
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_IO_PUPD_CONFIG_REG0, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_IO_PUPD_CONFIG_REG0:0x%x\n", b, a, value);
	if(value!=default_reg_val.edm_io_pupd_cfg_reg0){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_IO_PUPD_CONFIG_REG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n",EDM_IO_PUPD_CONFIG_REG0, default_reg_val.edm_io_pupd_cfg_reg0, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_IO_PUPD_CONFIG_REG1, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_IO_PUPD_CONFIG_REG0_DS:0x%x\n", b, a, value);
	if(value!=default_reg_val.edm_io_pupd_cfg_reg1){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_IO_PUPD_CONFIG_REG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_PUPD_CONFIG_REG1, default_reg_val.edm_io_pupd_cfg_reg1, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_IO_DS_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_IO_DS_REG:0x%x\n", b, a, value);
	if(value!=default_reg_val.edm_io_ds_reg){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_IO_DS_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_IO_NON_CLK_DS, default_reg_val.edm_io_ds_reg, value);
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_IO_INSTR_REG0, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_IO_INSTR_REG0:0x%x\n", b, a, value);
	if(value!=default_reg_val.edm_io_instr_reg0){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_IO_INSTR_REG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_INSTR_REG0, default_reg_val.edm_io_instr_reg0, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_IO_INSTR_REG1, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_IO_INSTR_REG1:0x%x\n", b, a, value);
	if(value!=default_reg_val.edm_io_instr_reg1){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_IO_INSTR_REG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_INSTR_REG0, default_reg_val.edm_io_instr_reg1, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_SERIAL_DELAY_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_SERIAL_DELAY_REG:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_PLL_SERIAL_DELAY_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_INSTR_REG0, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_SERIAL_ENABLE_SWITCH_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_SERIAL_ENABLE_SWITCH_REG:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_PLL_SERIAL_ENABLE_SWITCH_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_INSTR_REG0, default_reg_val.default_value_zero, value);
		ret = 1;

	}
	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_SERIAL_RD_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_SERIAL_RD_REG:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_PLL_SERIAL_RD_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_INSTR_REG0, default_reg_val.default_value_zero, value);
		ret = 1;

	}

	uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_SERIAL_WR_REG, 4, &value);
	rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_SERIAL_WR_REG:0x%x\n", b, a, value);
	if(value!=default_reg_val.default_value_zero){
		rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_PLL_SERIAL_WR_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", EDM_IO_INSTR_REG0, default_reg_val.default_value_zero, value);
		ret = 1;

	}

	for (int i=0; i<32; i++){
		uint8_t offset = EDM_PLL_SERIAL_MODE_REG0 + i;
		uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &value);
		rand_log(LOG_INFO, "board:%d asic:%d EDM_PLL_SERIAL_MODE_REG%d:0x%x offset: 0x%X\n", b, a, i, value, offset);
		if(value!=default_reg_val.default_value_zero){
			rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for EDM_PLL_SERIAL_MODE_REG%d (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", i, offset, default_reg_val.default_value_zero, value);
			ret = 1;

		}
	}
	uint8_t vec = LOCAL_REG_ENG_VEC1;
	for(uint8_t row = 0; row < 13; row++){
		// if(vec == 0xff){
		//         break;
		// }
		val = 0;
		value = 1;
		uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ENG_SOFT_RESET, 4, &value);
		usleep(1000);
		uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, vec, 1, &val);
		rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ENG_VEC(row:%d offset:%xh): %02x\n", b, a, row, vec, val);
		if(val!=default_reg_val.default_value_zero_8){
			rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ENG_VEC (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", vec, default_reg_val.default_value_zero_8, value);
			ret = 1;

		}
		vec = vec +( 1 << 1);
	}



	return ret;
}
/////////////


int test_register_read_defaultvalue()
{

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);
	uint32_t value;
	uint8_t val;
	uint8_t ret = 0;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if (bzm_params.board_exist[b] == 0)
				continue;
			ret= asic_global_reset(b,false);
			if(ret)
				goto END;


			if(bzm_params.cfg.enginecnt_for_testing!=0)
				asic_soft_reset(b, 0xFF);
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				rand_log(LOG_INFO, "\nChecking Default values for [b:%d][a:%d] ...\n\n",b,a);

				val = 0;
				value = 0;
				if(bzm_params.cfg.prj == EDM)
					ret = read_edm_notch_registers(b, a);
				else{
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_RESULT_STS_CTL, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_RESULT_STS_CTL:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_result_sts_ctl){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_RESULT_STS_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_RESULT_STS_CTL, default_reg_val.loc_reg_result_sts_ctl, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG0, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG0:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG0, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG1, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG1:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG1, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG2, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG2:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG2 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG2, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ERROR_LOG3, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ERROR_LOG3:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ERROR_LOG3 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ERROR_LOG3, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SPI_STS_CTL, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_SPI_STS_CTL:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_spi_sts_ctl){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_SPI_STS_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_SPI_STS_CTL, default_reg_val.loc_reg_spi_sts_ctl, value);
						ret = 1;

					}
#if 0
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_LINE_CTL, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_LINE_CTL:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_uart_line_ctl){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_LINE_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_LINE_CTL, default_reg_val.loc_reg_uart_line_ctl, value);
						ret = 1;

					}
#endif
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TDM_CTL, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_TDM_CTL:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_TDM_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_TDM_CTL, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SLOW_CLK_DIV, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_SLOW_CLK_DIV:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_slow_clk_div){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_SLOW_CLK_DIV (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_SLOW_CLK_DIV, default_reg_val.loc_reg_slow_clk_div, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_tdm_delay){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_TDM_DELAY (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_TDM_DELAY, default_reg_val.loc_reg_tdm_delay, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_TX:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_uart_tx){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_TX (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_TX, default_reg_val.loc_reg_uart_tx, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_PLL_POSTDIV, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_PLL_POSTDIV:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_pll_postdiv){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_PLL_POSTDIV (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_PLL_POSTDIV, default_reg_val.loc_reg_pll_postdiv, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_PLL_FBDIV, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_PLL_FBDIV:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_pll_fbdiv){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_PLL_FBDIV (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_PLL_FBDIV, default_reg_val.loc_reg_pll_fbdiv, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_PLL_ENABLE, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_PLL_ENABLE:0x%x\n", b, a, value);
					if((value!=default_reg_val.default_value_zero) &&  (value!=4)){

						rand_log(LOG_ERROR,"[ERROR] - \bDefault Value Mismatch for LOCAL_REG_PLL_ENABLE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_PLL_ENABLE, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ENG_SOFT_RESET, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ENG_SOFT_RESET:0x%x\n", b, a, value);
					uint expectedvalue=0;
					if(bzm_params.cfg.enginecnt_for_testing==0)
						expectedvalue=0;
					else
						expectedvalue=1;
					//if(value!=default_reg_val.default_value_zero){
					if(value!=expectedvalue){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ENG_SOFT_RESET (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ENG_SOFT_RESET, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_SPI_TAP, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_UART_SPI_TAP:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_uart_spi_tap){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_UART_SPI_TAP (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_UART_SPI_TAP, default_reg_val.loc_reg_uart_spi_tap, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_TUNE_CODE, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TEMPSENSOR_TUNE_CODE:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_tempsensor_tune_code){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_TEMPSENSOR_TUNE_CODE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_TEMPSENSOR_TUNE_CODE, default_reg_val.loc_reg_tempsensor_tune_code, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TRIP_STATUS, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_TRIP_STATUS:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_TRIP_STATUS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_TRIP_STATUS, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TEMP_CODE, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_TEMP_CODE:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_TEMP_CODE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_TEMP_CODE, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SAR_COUNT_LOAD , 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_SAR_COUNT_LOAD :0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_thermal_sar_count_load){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_SAR_COUNT_LOAD (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_SAR_COUNT_LOAD, default_reg_val.loc_reg_thermal_sar_count_load, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SAR_STATE_RESET, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_THERMAL_SAR_STATE_RESET:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_THERMAL_SAR_STATE_RESET (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_THERMAL_SAR_STATE_RESET,default_reg_val.default_value_zero, value );
						ret = 1;

					}

					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_STATUS, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_STATUS:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_STATUS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_STATUS, default_reg_val.default_value_zero, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_DFT, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_DFT:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_DFT (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_DFT, default_reg_val.default_value_zero, value);
						ret = 1;

					}

					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_BANDGAP, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_BANDGAP:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_bandgap){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_BANDGAP (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_BANDGAP, default_reg_val.loc_reg_bandgap, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_MISC, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_MISC:0x%x\n", b, a, value);
					if(value!=default_reg_val.default_value_zero){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_MISC (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_MISC, default_reg_val.default_value_zero, value);
						ret = 1;

					}

					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_IO_PEPS, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_IO_PEPS:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_io_peps){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_IO_PEPS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n",LOCAL_REG_IO_PEPS, default_reg_val.loc_reg_io_peps, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_IO_PEPS_DS, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_IO_PEPS_DS:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_io_peps_ds){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_IO_PEPS_DS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_IO_PEPS_DS, default_reg_val.loc_reg_io_peps_ds, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_IO_PUPDST, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_IO_PUPDST:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_io_pupdst){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_IO_PUPDST (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_IO_PUPDST, default_reg_val.loc_reg_io_pupdst, value);
						ret = 1;

					}
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_IO_NON_CLK_DS, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_IO_NON_CLK_DS:0x%x\n", b, a, value);
					if(value!=default_reg_val.loc_reg_io_non_clk_ds){
						rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_IO_NON_CLK_DS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_IO_NON_CLK_DS, default_reg_val.loc_reg_io_non_clk_ds, value);
						ret = 1;

					}

					//newly added
					if(bzm_params.cfg.prj == BZM2)
					{

#if 0  //Cannot check default value of ASID ID since it will be updated in asic discovery
						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ASIC_ID, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ASIC_ID:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_asic_id){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ASIC_ID (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_ASIC_ID, default_reg_val.loc_reg_asic_id, value);
							ret = 1;

						}
#endif

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_EXT_CLK_SEL, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_EXT_CLK_SEL:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_ext_clk_sel){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_EXT_CLK_SEL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_EXT_CLK_SEL, default_reg_val.loc_reg_ext_clk_sel, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_PLL_CNTRL, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_PLL_CNTRL:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_pll_cntrl){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_PLL_CNTRL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_PLL_CNTRL, default_reg_val.loc_reg_pll_cntrl, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_PLL_MISC, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_PLL_MISC:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_pll_misc){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_PLL_MISC (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_PLL_MISC, default_reg_val.loc_reg_pll_misc, value);
							ret = 1;

						}



						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_SENS_TDM_GAP_CNT:0x%x\n", b, a, value);
						if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_SENS_TDM_GAP_CNT (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_SENS_TDM_GAP_CNT, default_reg_val.default_value_zero, value);
								ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_DTS_CLKGT_PD, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_DTS_CLKGT_PD:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_dts_clkgt_pd){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_DTS_CLKGT_PD (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_DTS_CLKGT_PD, default_reg_val.loc_reg_dts_clkgt_pd, value);
							ret = 1;

						}


						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_CFG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TEMPSENSOR_CFG:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_tempsensor_cfg){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_TEMPSENSOR_CFG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_TEMPSENSOR_CFG, default_reg_val.loc_reg_tempsensor_cfg, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENSOR_CLK_DIV, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_SENSOR_CLK_DIV:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_sensor_clk_div){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_SENSOR_CLK_DIV (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_SENSOR_CLK_DIV, default_reg_val.loc_reg_sensor_clk_div, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VSENSOR_CLKGT_PD, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VSENSOR_CLKGT_PD:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_vsensor_clkgt_pd){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VSENSOR_CLKGT_PD (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VSENSOR_CLKGT_PD, default_reg_val.loc_reg_vsensor_clkgt_pd, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VSENSOR_CFG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VSENSOR_CFG:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_vsensor_cfg){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VSENSOR_CFG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VSENSOR_CFG, default_reg_val.loc_reg_vsensor_cfg, value);
							ret = 1;

						}


						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VOLTAGE_SENSOR_CTL:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_vsensor_ctrl){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VOLTAGE_SENSOR_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VOLTAGE_SENSOR_CTL, default_reg_val.loc_reg_vsensor_ctrl, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT:0x%x\n", b, a, value);
						if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, default_reg_val.default_value_zero, value);
								ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT:0x%x\n", b, a, value);
						if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, default_reg_val.default_value_zero, value);
								ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS:0x%x\n", b, a, value);
						if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS, default_reg_val.default_value_zero, value);
								ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_LDO_0_CTRL_AND_STS, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_LDO_0_CTRL_AND_STS:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_ldo_0_ctrl_and_sts){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_LDO_0_CTRL_AND_STS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_LDO_0_CTRL_AND_STS, default_reg_val.loc_reg_ldo_0_ctrl_and_sts, value);
								ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_LDO_1_CTRL_AND_STS, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_LDO_1_CTRL_AND_STS:0x%x\n", b, a, value);
						if(value!=default_reg_val.loc_reg_ldo_1_ctrl_and_sts){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_LDO_1_CTRL_AND_STS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", LOCAL_REG_LDO_1_CTRL_AND_STS, default_reg_val.loc_reg_ldo_1_ctrl_and_sts, value);
								ret = 1;

						}



						//====================================DLL 0=======================
						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_0_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_0_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_0_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_0_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_0_0, default_reg_val.dll_reg_ckdccr_0_0, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_1_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_1_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_1_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_1_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_1_0, default_reg_val.dll_reg_ckdccr_1_0, value);
							ret = 1;

						}


						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_2_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_2_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_2_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_2_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_2_0, default_reg_val.dll_reg_ckdccr_2_0, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_3_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_3_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_3_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_3_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_3_0, default_reg_val.dll_reg_ckdccr_3_0, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_4_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_4_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_4_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_4_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_4_0, default_reg_val.dll_reg_ckdccr_4_0, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_5_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_5_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_5_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCC_5_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_5_0, default_reg_val.dll_reg_ckdccr_5_0, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDLLR_0_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDLLR_0_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdllr_0_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDLLR_0_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDLLR_0_0, default_reg_val.dll_reg_ckdllr_0_0, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDLLR_1_0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDLLR_1_0:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdllr_1_0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDLLR_1_0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDLLR_1_0, default_reg_val.dll_reg_ckdllr_1_0, value);
							ret = 1;

						}


						//====================================DLL 1=======================
						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_0_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_0_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_0_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_0_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_0_1, default_reg_val.dll_reg_ckdccr_0_1, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_1_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_1_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_1_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_1_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_1_1, default_reg_val.dll_reg_ckdccr_1_1, value);
							ret = 1;

						}


						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_2_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_2_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_2_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_2_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_2_1, default_reg_val.dll_reg_ckdccr_2_1, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_3_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_3_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_3_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_3_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_3_1, default_reg_val.dll_reg_ckdccr_3_1, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_4_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_4_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_4_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCCR_4_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_4_1, default_reg_val.dll_reg_ckdccr_4_1, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDCCR_5_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDCCR_5_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdccr_5_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDCC_5_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDCCR_5_1, default_reg_val.dll_reg_ckdccr_5_1, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDLLR_0_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDLLR_0_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdllr_0_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDLLR_0_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDLLR_0_1, default_reg_val.dll_reg_ckdllr_0_1, value);
							ret = 1;

						}

						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, DLL_REG_CKDLLR_1_1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d DLL_REG_CKDLLR_1_1:0x%x\n", b, a, value);
						if(value!=default_reg_val.dll_reg_ckdllr_1_1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for DLL_REG_CKDLLR_1_1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", DLL_REG_CKDLLR_1_1, default_reg_val.dll_reg_ckdllr_1_1, value);
							ret = 1;

						}



						//======================BIST=========================
						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_RESULT_FSM_CTL:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_result_fsm_ctl){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_RESULT_FSM_CTL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_RESULT_FSM_CTL, default_reg_val.bist_result_fsm_ctl, value);
							ret = 1;

						}//0x1

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_ENABLE_REG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%dBIST_ENABLE_REG:%08x\n", b, a, value);
						if(value!=default_reg_val.default_value_zero){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_ENABLE_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_ENABLE_REG, default_reg_val.default_value_zero, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_CONTROL_REG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_CONTROL_REG:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_control_reg){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_CONTROL_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_CONTROL_REG, default_reg_val.bist_control_reg, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_RESULT_TIMEOUT_REG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_RESULT_TIMEOUT_REG:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_result_timeout_reg){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_RESULT_TIMEOUT_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_RESULT_TIMEOUT_REG, default_reg_val.bist_result_timeout_reg, value);
							ret = 1;

						}//0x2

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_JOB_COUNT_REG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_JOB_COUNT_REG:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_job_count_reg){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_JOB_COUNT_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_JOB_COUNT_REG, default_reg_val.bist_job_count_reg, value);
							ret = 1;

						}//0x7

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_GAP_COUNT_REG, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_GAP_COUNT_REG:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_gap_count_reg){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_GAP_COUNT_REG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_GAP_COUNT_REG, default_reg_val.bist_gap_count_reg, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXPECTED_RES_REG0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXPECTED_RES_REG0:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_expected_res_reg0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXPECTED_RES_REG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXPECTED_RES_REG0, default_reg_val.bist_expected_res_reg0, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXPECTED_RES_REG1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXPECTED_RES_REG1:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_expected_res_reg1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXPECTED_RES_REG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXPECTED_RES_REG1, default_reg_val.bist_expected_res_reg1, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXPECTED_RES_REG2, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXPECTED_RES_REG2:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_expected_res_reg2){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXPECTED_RES_REG2 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXPECTED_RES_REG2, default_reg_val.bist_expected_res_reg2, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXPECTED_RES_REG3, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXPECTED_RES_REG3:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_expected_res_reg3){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXPECTED_RES_REG3 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXPECTED_RES_REG3, default_reg_val.bist_expected_res_reg3, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_REG2, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_REG2:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_exp_pat_reg2){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_REG2 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_REG2, default_reg_val.bist_exp_pat_reg2, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_REG0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_REG0:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_exp_pat_reg0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_REG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_REG0, default_reg_val.bist_exp_pat_reg0, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_REG1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_REG1:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_exp_pat_reg1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_REG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_REG1, default_reg_val.bist_exp_pat_reg1, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_REG3, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_REG3:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_exp_pat_reg3){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_REG3 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_REG3, default_reg_val.bist_exp_pat_reg3, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG0, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG0:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg0){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG0 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG0, default_reg_val.bist_ext_pat_job_reg0, value);
							ret = 1;

						}//0x1

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG1, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG1:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg1){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG1, default_reg_val.bist_ext_pat_job_reg1, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG2, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG2:%08x\n", b, a,value);
						if(value!=default_reg_val.bist_ext_pat_job_reg2){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG2 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG2, default_reg_val.bist_ext_pat_job_reg2, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG3, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG3:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg3){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG3 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG3, default_reg_val.bist_ext_pat_job_reg3, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG4, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG4:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg4){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG4 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG4, default_reg_val.bist_ext_pat_job_reg4, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG5, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG5:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg5){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG5 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG5, default_reg_val.bist_ext_pat_job_reg5, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG6, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG6:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg6){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG6 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG6, default_reg_val.bist_ext_pat_job_reg6, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG7, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG7:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg7){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG7 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG7, default_reg_val.bist_ext_pat_job_reg7, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG8, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG8:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg8){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG8 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG8, default_reg_val.bist_ext_pat_job_reg8, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG9, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG9:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg9){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG9 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG9, default_reg_val.bist_ext_pat_job_reg9, value);
							ret = 1;

						}//0x0

						uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_EXP_PAT_JOB_REG10, 4, &value);
						rand_log(LOG_INFO, "board:%d asic:%d BIST_EXP_PAT_JOB_REG10:%08x\n", b, a, value);
						if(value!=default_reg_val.bist_ext_pat_job_reg10){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for BIST_EXP_PAT_JOB_REG10 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", BIST_EXP_PAT_JOB_REG10, default_reg_val.bist_ext_pat_job_reg10, value);
							ret = 1;

						}//0x1

					}

					uint8_t vec = LOCAL_REG_ENG_VEC1;
					for(uint8_t row = 0; row < 13; row++){
						// if(vec == 0xff){
						//         break;
						// }
						val = 0;
						value = 1;
						uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_ENG_SOFT_RESET, 4, &value);
						usleep(1000);
						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, vec, 1, &val);
						rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_ENG_VEC(row:%d offset:%xh): %02x\n", b, a, row, vec, val);
						if(val!=default_reg_val.default_value_zero_8){
							rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for LOCAL_REG_ENG_VEC (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", vec, default_reg_val.default_value_zero_8, value);
							ret = 1;

						}
						vec = vec +( 1 << 1);
					}
				}
				//asic_global_reset(0);
				//asic_soft_reset(0, 0xFF);
				//asic_discovery();
				if(bzm_params.cfg.enginecnt_for_testing !=0)
				{
					for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
						for (int c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
							if (bzm_params.engine_exist[b][a][r][c] == 0)
								continue;


							rand_log(LOG_INFO,"=====================================================================\n");
							val= 0;

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_STATUS, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_STATUS:0x%x\n", b, a, r, c, val);
							//rand_log(LOG_INFO,"frm reg : 0x%x\n",default_reg_val.default_value_zero_8);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_STATUS (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_STATUS, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &val);
							//rand_log(LOG_INFO,"frm reg : 0x%x\n",default_reg_val.eng_reg_config_8);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_CONFIG:0x%x\n", b, a, r, c, val);
							if(bzm_params.cfg.prj == BZM2)
							{
								uint8_t exp = 0x77;
								if(val!=exp){
									rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_CONFIG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_CONFIG, exp, val);
									ret = 1;
								}

							}
							else
							{
								if(val!=default_reg_val.eng_reg_config_8){
									if(val!=0x1){
										rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_CONFIG (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_CONFIG, default_reg_val.eng_reg_config_8, val);
										ret = 1;
									}
								}
							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_DELAY + 0x00, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_DELAY:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_DELAY (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_DELAY, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x00, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{0-31}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x04, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{32-63}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x08, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE {64-95}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x0C, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{96-127}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x10, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{128-159}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x14, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{160-191}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x18, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{192-223}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}

							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MIDSTATE + 0x1C, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MIDSTATE{223-255}:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MIDSTATE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MIDSTATE, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_MRRESIDUE, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_MRRESIDUE:0x%x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_MRRESIDUE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_MRRESIDUE, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_START_TIMESTAMP, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_START_TIMESTAMP:0x%x\n", b, a, r, c,  value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_START_TIMESTAMP (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_START_TIMESTAMP, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_SEQUENCE_ID, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_SEQUENCE_ID:0x%x\n", b, a, r, c, val);
							if(value!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_SEQUENCE_ID (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_SEQUENCE_ID, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_JOB_CONTROL:0x%x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_JOB_CONTROL (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_JOB_CONTROL, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_START_NONCE, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_START_NONCE:0x%x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_START_NONCE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_START_NONCE, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_END_NONCE, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_END_NONCE:0x%x\n", b, a, r, c, value);
							if(value!=default_reg_val.eng_reg_end_nonce){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_END_NONCE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_END_NONCE, default_reg_val.eng_reg_end_nonce, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_TARGET, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_TARGET:0x%x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_TARGET (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_TARGET, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_TIMESTAMP_COUNT, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_TIMESTAMP_COUNT:0x%x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_TIMESTAMP_COUNT (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_TIMESTAMP_COUNT, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_ZEROS_TO_FIND:0x%x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_ZEROS_TO_FIND (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_ZEROS_TO_FIND, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_VALID, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_VALID:%08x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_VALID (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_VALID, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_PART1, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_PART1:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_PART1 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_PART1, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_SEQUENCE, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_SEQUENCE:0x%x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_SEQUENCE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_SEQUENCE, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_TIME, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_TIME:%08x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_TIME, (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_TIME, default_reg_val.default_value_zero_8, val);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_NONCE, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_NONCE:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_NONCE (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_NONCE, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_PART2, 4, &value);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_PART2:%08x\n", b, a, r, c, value);
							if(value!=default_reg_val.default_value_zero){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_PART2 (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_PART2, default_reg_val.default_value_zero, value);
								ret = 1;

							}
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_POP, 1, &val);
							rand_log(LOG_INFO, "board:%d asic:%d row:%d column:%d ENGINE_REG_RESULT_POP:0x%x\n", b, a, r, c, val);
							if(val!=default_reg_val.default_value_zero_8){
								rand_log(LOG_ERROR,"[ERROR] - Default Value Mismatch for ENGINE_REG_RESULT_POP (offset : %xh): Expected: 0x%x, Observed: 0x%x\n", ENGINE_REG_RESULT_POP, default_reg_val.default_value_zero_8, val);
								ret = 1;

								rand_log(LOG_INFO,"=====================================================================\n");
							}


							//===================================================

						}
					}
				}

				rand_log(LOG_INFO,"=====================================================================\n");
			}
		}
		if(ret)
			break; //breaking regression loop on failure
	}
	END:
	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);
	return ret;
}


int test_noop_without_asicreset(void)
{
	int ret=SUCCESS;
	char buf[3];
	uint32_t asic_per_board[BOARD_PER_DEVICE];
	uint32_t asic_cnt=0;

	memset(bzm_params.board_exist, 0, sizeof(bzm_params.board_exist));


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);


		}
	}


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		asic_per_board[b]=0;
		rand_log(LOG_INFO, "Finding asic in board %d..\n",b);
		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			memset(buf, '\0', 3);

			ret=uart_command_noop(bzm_params.uart_dev, b, a, buf);
			if(ret)
			{
				rand_log(LOG_INFO, "NOOP Response of [b:%d] [a:%d] = %c %c %c\n", b, a, buf[0], buf[1], buf[2]);

				if(strncmp(buf,bzm_params.expected_noop_resp,3) == 0)
				{
					asic_cnt++;
					asic_per_board[b]++;
				}
			}

		}
		rand_log(LOG_INFO,"\n\nNo. of asic found in [b:%d] = %d\n\n",b,asic_per_board[b]);
	}
	if(asic_cnt==0)
	{
		rand_log(LOG_ERROR,"[ERROR] - No asic found\n");
		ret=ERR_NO_ASIC_FOUND;

	}
	else
	{
		rand_log(LOG_INFO,"Total no. of asic found = %d\n\n",asic_cnt);
		ret=SUCCESS;
	}

	//uart_dev_close();
	return ret;

}

int test_uart_notch_write_reg(void)
{
	int ret=SUCCESS;
	uint32_t value=0, readvalue=0;
	uint32_t b=0,a=0;
	uint32_t offset=0, loopcnt;

	char input[50];
	char *endptr;

	printf("\nEnter Board and Asic number for write : ");
	fgets(input, sizeof input, stdin);

	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);

	printf("\nEnter Write offset in hex : ");
	fgets(input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);

#if 0
	if(a ==BROADCAST_ASIC)
	{
		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
			if (bzm_params.asic_exist[b][a] == 0)
				continue;
			readvalue=0;
			if(bzm_params.tdm_enabled ==true)
			{
				uart_enable_tmd(bzm_params.uart_dev,b, true);
				uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &readvalue);
			}
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &readvalue);
			applog(LOG_INFO,"\nValue read before write in [b:%d][a:%d][offset:0x%x] = 0x%x\n",b,a,offset,readvalue);
		}
	}

#endif

	printf("\nEnter Write value in hex : ");
	fgets(input, sizeof input, stdin);
	value= (uint32_t)strtoul(input, NULL, 16);
	printf("value = 0x%x\n",value);

	printf("\nEnter iteration count to run : ");
	fgets(input, sizeof input, stdin);
	loopcnt = (uint32_t)strtoul(input, NULL, 16);
	printf("loopcnt = 0x%x\n",loopcnt);

	for(uint32_t i=0;i<loopcnt;i++)
	{

		uart_command_writereg(bzm_params.uart_dev, b, a,NOTCH_REG , offset, 4, &value);

		if(a ==BROADCAST_ASIC)
		{
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				readvalue=0;
				if(bzm_params.tdm_enabled==true)
				{
					uart_enable_tmd(bzm_params.uart_dev,b, true);
					uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &readvalue);
				}
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &readvalue);

				applog(LOG_INFO,"Value read after write in [b:%d][a:%d][offset:0x%x] = 0x%x\n",b,a,offset,readvalue);
				if(readvalue!=value)
				{
					applog(LOG_ERROR, "[ERROR] - Value not written. Expected=0x%x ReadValue=0x%x\n",value,readvalue);
					ret|=ERR_READVALUE_MISMATCH;
					goto END;
				}


			}
		}
	}

END:
	return ret;
}

int test_uart_notch_read_reg(void)
{
	uint32_t value=0;
	uint32_t b=0,a=0;
	uint32_t offset=0;
	int ret=SUCCESS;

	char input[50];
	char *endptr;

	printf("\nEnter Board and Asic ID for read : ");
	fgets(input, sizeof input, stdin);
	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);

	printf("\nEnter Read offset in hex : ");
	fgets(input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);


	if(bzm_params.tdm_enabled==true)
	{
		uart_enable_tmd(bzm_params.uart_dev,b, true);
		ret=uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &value);
	}
	else
		ret=uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, offset, 4, &value);
	if(ret==true)
		applog(LOG_INFO,"Value read in [b:%d][a:%d][offset:0x%x] = 0x%x\n",b,a,offset,value);
	else
		applog(LOG_INFO,"[ERROR] - ReadReg failed\n");
	return ret;
}


int test_engine_read_reg(void)
{
	uint32_t value=0;
	uint32_t b=0,a=0,r=0,c=0;
	uint32_t offset=0, engine_id=0;

	char input[50];
	char *endptr;

	rand_log(LOG_INFO, "\nEnter Board Asic Row and Column ID for read : ");
	fgets (input, sizeof input, stdin);

	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);



	rand_log(LOG_INFO, "\nEnter Read offset in hex : ");
	fgets (input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);

	engine_id= (c << 6) | r;

	if(bzm_params.tdm_enabled==true)
	{
		uart_enable_tmd(bzm_params.uart_dev,b, true);
		uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, engine_id, offset, 4, &value);
	}
	else
		uart_command_readreg(bzm_params.uart_dev, b, a, engine_id, offset, 4, &value);

	rand_log(LOG_INFO,"Value read in [b:%d][a:%d][r:%d][c%d][offset:0x%x] = 0x%x\n",b,a,r,c,offset,value);

	return SUCCESS;
}

int test_engine_write_reg(void)
{
	int ret=SUCCESS;
	uint32_t value=0,readvalue=0;
	uint32_t b=0,a=0,r=0,c=0;
	uint32_t offset=0,engine_id=0;

	char input[50];
	char *endptr;

	rand_log(LOG_INFO, "\nEnter Board Asic Row and Column ID for write : ");
	fgets(input, sizeof input, stdin);

	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);


	rand_log(LOG_INFO, "\nEnter Write offset in hex : ");
	fgets(input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);

	engine_id= (c << 6) | r;

	rand_log(LOG_INFO, "\nEnter Write value in hex : ");
	fgets(input, sizeof input, stdin);
	value= (uint32_t)strtoul(input, NULL, 16);


	uart_command_writereg(bzm_params.uart_dev, b, a,engine_id , offset, 4, &value);


	readvalue=0;
	if(bzm_params.tdm_enabled==true)
	{
		uart_enable_tmd(bzm_params.uart_dev,b, true);
		uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, engine_id, offset, 4, &readvalue);
	}
	else
		uart_command_readreg(bzm_params.uart_dev, b, a, engine_id, offset, 4, &readvalue);

	rand_log(LOG_INFO,"Value read after write in [b:%d][a:%d][r:%d][c:%d][offset:0x%x] = 0x%x\n",b,a,r,c,offset,readvalue);
	if(readvalue!=value)
	{
		rand_log(LOG_ERROR, "[ERROR] - Value not written. Expected=0x%x ReadValue=0x%x\n",value,readvalue);
		ret=ERR_READVALUE_MISMATCH;
	}

	return ret;
}


int test_engine_register_dump(void)
{

	uint32_t b=0,a=0,r=0,c=0;

	char input[50];
	char *endptr;

	rand_log(LOG_INFO, "\nEnter Board Asic Row and Column ID for write : ");
	fgets(input, sizeof input, stdin);

	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);

	engine_register_dump(b,a,r,c);
	return SUCCESS;

}


int test_notch_register_dump(void)
{

	uint32_t b=0,a=0;

	char input[50];
	char *endptr;

	printf("\nEnter Board and Asic ID for read : ");
	fgets(input, sizeof input, stdin);
	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);

	notch_register_dump(b,a);
	return SUCCESS;

}

#if defined(ASIC_BZM2)
int test_effbst_tdm_jobsubmit_to_1engine()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	bzm_params.sw_timeout= bzm_params.sw_timeout*bzm_params.cfg.jobcnt;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		uint32_t b=0, a=0, r=0, c=0;

		if(bzm_params.cfg.boardcount>1)
		{
			b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[b],bzm_params.asic_count);
			a=bzm_params.active_asic_id[b][0];
		}
		else
		{
			a=bzm_params.active_asic_id[b][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[b][a],bzm_params.enginecount_per_asic);
			r = bzm_params.active_row_id[b][a][0];
			randomize(bzm_params.active_col_id[b][a][r],bzm_params.enginecount_per_asic);
			c =  bzm_params.active_col_id[b][a][r][0];
		}
		else
		{
			r = bzm_params.active_row_id[b][a][0];
			c = bzm_params.active_col_id[b][a][r][0];
		}

		bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
		bzm_params.job_submit+=subjobcnt;


		if(bzm_params.cfg.jobcnt==2)
		{
			seq_id+=subjobcnt;
			bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

			bzm_params.job_submit+=subjobcnt;
			seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
		}
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			goto END;
		ret=check_1engine_status(b,a,r,c,bzm_params.sw_timeout);
		if(ret)
			goto END;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			goto END;
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}





int test_effbst_tdm_jobsubmit_with_writejobcmd()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
                         init_engine_stack(b,a);
                            while(1)
                          {
                              err=get_next_engine_for_jobsubmit(b,a);
                               if(err)
                                break;
                             r=bzm_params.next_r[b][a];
                             c=bzm_params.next_c[b][a];
						  
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_effbst_tdm_jobsubmit_with_writeregcmd()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif						
						uint32_t r = 0,c=0,err=0;
                        init_engine_stack(b,a);
                         while(1)
                       {
                               err=get_next_engine_for_jobsubmit(b,a);
                               if(err)
                                 break;
                         r=bzm_params.next_r[b][a];
                         c=bzm_params.next_c[b][a];
						
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}





int test_effbst_tdm_jobsubmit_with_multicastwrite()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif						
						uint32_t r = 0,c=0,err=0;
                        init_engine_stack(b,a);
                         while(1)
                    {
                                    err=get_next_row_for_jobsubmit(b,a);
                                  if(err)
                                  break;
                                   r=bzm_params.next_r[b][a];
                                   c=bzm_params.next_c[b][a];
						
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
						break; /* break column loop since job sent to all columns */
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_broadcastcmd()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

			if(bzm_params.cfg.jobcnt==2)
			{
				seq_id+=subjobcnt;
				bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
				seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
			}

		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_nontdm_jobsubmit_with_writejobcmd_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 1);


	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif			
                         uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
							err=get_next_engine_for_jobsubmit(b,a);
								if(err)
								break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];   
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_nontdm_jobsubmit_with_writeregcmd_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 1);


	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];

						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_nontdm_jobsubmit_with_multicastwrite_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 1);


	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_row_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
						break;
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_nontdm_jobsubmit_with_broadcastcmd_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 1);


	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

			if(bzm_params.cfg.jobcnt==2)
			{
				seq_id+=subjobcnt;
				bzm_params.exp_noncecnt+=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
				seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
			}

		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_nontdm_jobsubmit_with_writejobcmd_frf0()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a] =0;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];


						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;


						nonce_cnt=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;


						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							nonce_cnt=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=nonce_cnt;
							bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_resultfsm_frf0(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"\nJOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_nontdm_jobsubmit_with_writeregcmd_frf0()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a] =0;
#if 0

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];


						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;


						nonce_cnt=effbst_write_bch_data(false, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;


						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							nonce_cnt=effbst_write_bch_data(false, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=nonce_cnt;
							bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_resultfsm_frf0(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"\nJOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_nontdm_jobsubmit_with_multicastwrite_frf0()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a] =0;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_row_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];

						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;


						nonce_cnt=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;


						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							nonce_cnt=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=nonce_cnt;
							bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
						break;
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_resultfsm_frf0(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"\nJOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}


		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_nontdm_jobsubmit_with_broadcastcmd_frf0()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t nonce_cnt=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			nonce_cnt=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
			bzm_params.exp_noncecnt+=nonce_cnt;

			if(bzm_params.cfg.jobcnt==2)
			{
				seq_id+=subjobcnt;
				nonce_cnt=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
				bzm_params.exp_noncecnt+=nonce_cnt;

				seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
			}
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a] = bzm_params.exp_noncecnt/bzm_params.asic_count_per_board[b];
			}

		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=nontdm_readresult_from_resultfsm_frf0(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"\nJOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_effbst_engine_fifofull_check()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t noncecnt=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.cfg.nonce_count=2;
	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 1);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{





	if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						noncecnt=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt +=noncecnt;

					}
				}
			}
		}
		seq_id+= subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/subjobcnt;

		uint32_t job_processing_time = (((uint32_t)bzm_params.jobprocessingtime));

		rand_log(LOG_INFO, "\n Sleep for %d sec for 4 jobs to complete  ...\n",job_processing_time);


		sleep(job_processing_time);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{



						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						uint32_t  result_fifo_full = 0;
						uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_RESULT_VALID, 1, &result_fifo_full);
						rand_log(LOG_INFO, "b:%d a:%d r:%d c:%d - ENGINE_REG_RESULT_VALID : 0x%x\n", b,a,r,c, result_fifo_full);
						//result_fifo_full = (result_fifo_full >> 2) & 1;
						if ((result_fifo_full>>3) & 0x1) // if job done bit is set
							bzm_params.total_job_done_sts_cnt+=1;
						if ((result_fifo_full>>2) & 0x1) {
							rand_log(LOG_INFO, "\nb:%d a:%d r:%d c:%d - Result FIFO is full\n", b,a,r,c);
						} else {
							rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d r:%d c:%d - Result FIFO is not full\n",b,a,r,c);
							ret = ERR_ENG_RESULT_FIFO_NOT_FULL;
							goto END;

						}

					}

				}
			}
		}
		bzm_params.poll_eng_idle=true;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		if(bzm_params.job_done_sts_enabled)
		{
			if( bzm_params.exp_jobdone_sts_cnt == bzm_params.total_job_done_sts_cnt )
				rand_log(LOG_INFO,"Received the expected job done %d\n",bzm_params.exp_jobdone_sts_cnt);
			else
			{
				rand_log(LOG_ERROR,"[ERROR] Job done status count mismatch. Expected=%d Received=%d\n",bzm_params.exp_jobdone_sts_cnt,bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
				goto END;
			}
		}

	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_disable_enable_engine()
{


	int ret = SUCCESS;

	uint8_t seq_id=0;


	//int disable_seq_id =1;
	uint32_t disabled_b=0,disabled_a=0,disabled_r=0,disabled_c=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t exp_jobs_for_disabled_eng = 0;
	uint32_t exp_jobs_per_engine=0;
	bool engine_disabled = false;


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1,0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {

		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,BROADCAST_ASIC,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		engine_disabled = false;

		if(bzm_params.cfg.boardcount>1)
		{
			disabled_b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			disabled_b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[disabled_b],bzm_params.asic_count);
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		else
		{
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[disabled_b][disabled_a],bzm_params.enginecount_per_asic);
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			randomize(bzm_params.active_col_id[disabled_b][disabled_a][disabled_r],bzm_params.enginecount_per_asic);
			disabled_c =  bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}
		else
		{
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			disabled_c = bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						


						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						if((b==disabled_b) && (a==disabled_a) && (r==disabled_r) && (c==disabled_c))
						{
							//if(seq_id == disable_seq_id){
							rand_log(LOG_INFO, "Disabling engine id with b:%d a:%d r:%d c:%d\n", b, a, r, c );
							uint32_t engine_offset = 0x80;
							uint32_t row_offset = (r) << 1;
							uint32_t col_offset = 0; //MSB of Column
							uint32_t value = (1<<c);
							engine_offset = engine_offset | row_offset | col_offset;
							uart_command_writereg(bzm_params.uart_dev, b,a,NOTCH_REG,engine_offset,4,&value);
							engine_disabled = true;
						}

						exp_jobs_per_engine=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						bzm_params.exp_noncecnt+= exp_jobs_per_engine;
						if(engine_disabled == true)
						{
							exp_jobs_for_disabled_eng = exp_jobs_per_engine;
							engine_disabled = false;
						}


					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		bzm_params.exp_noncecnt = bzm_params.exp_noncecnt - exp_jobs_for_disabled_eng;
		bzm_params.exp_jobdone_sts_cnt = (bzm_params.job_submit/bzm_params.subjobcnt)-1;


		rand_log(LOG_INFO, "JOB_SUBMITTED=%d EXPECTED_NONCE_COUNT = %d\n",bzm_params.job_submit,bzm_params.exp_noncecnt);


		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		if((bzm_params.job_submit/bzm_params.subjobcnt==1) && (bzm_params.engine_count==1))
		{

			bzm_params.poll_eng_idle=true;
			ret=check_all_engine_status(bzm_params.sw_timeout);
			if(ret)
				break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;
		}



		rand_log(LOG_INFO, "Enabling engine id with b:%d a:%d r:%d c:%d\n",  disabled_b,disabled_a,disabled_r,disabled_c);
		bzm_params.collected_noncecnt=0;
		uint32_t engine_offset = 0x80;
		uint32_t row_offset = (disabled_r) << 1;
		uint32_t col_offset = 0; //MSB of Column
		uint32_t value = (0<<disabled_c);
		engine_offset = engine_offset | row_offset | col_offset;
		uart_command_writereg(bzm_params.uart_dev, disabled_b,disabled_a,NOTCH_REG,engine_offset,4,&value);

		bzm_params.poll_eng_idle=true;
		rand_log(LOG_INFO, "\nWait for b:%d a:%d r:%d c:%d engine fifo to become empty...\n",disabled_b,disabled_a,disabled_r,disabled_c);
		ret=check_1engine_status(disabled_b,disabled_a,disabled_r,disabled_c,bzm_params.sw_timeout);
		if(ret)
			break;
		if(bzm_params.asic_count_per_board[disabled_b] >4)
			sleep(5);

		rand_log(LOG_INFO,"JOB_DONE after enabling engine = %d\n",bzm_params.collected_noncecnt);
		if(bzm_params.collected_noncecnt == exp_jobs_for_disabled_eng){
			ret = SUCCESS;
		}
		else
		{
			if((exp_jobs_for_disabled_eng>8) && (bzm_params.collected_noncecnt == 8))
			{
				rand_log(LOG_ERROR, "[ERROR-EXPECTED] -EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d. DROPPED_OFF_RESULTS=%d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt,(exp_jobs_for_disabled_eng-bzm_params.collected_noncecnt));
				ret = SUCCESS;
			}
			else
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				break;
			}
		}

		if(bzm_params.job_done_sts_enabled)
		{
			//if(exp_jobs_for_disabled_eng <=4)
			bzm_params.exp_jobdone_sts_cnt+=1;
			if( bzm_params.exp_jobdone_sts_cnt == bzm_params.total_job_done_sts_cnt )
				rand_log(LOG_INFO,"Received the expected job done %d\n",bzm_params.exp_jobdone_sts_cnt);
			else
			{
				rand_log(LOG_ERROR,"[ERROR] Job done status count mismatch. Expected=%d Received=%d\n",bzm_params.exp_jobdone_sts_cnt,bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
				goto END;
			}
		}



	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_effbst_tdm_shuffle_seq_id()
{

	int ret = SUCCESS;
	uint8_t seq_id[4];



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{


						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						generate_random_seq_id(seq_id);
						rand_log(LOG_INFO, "Random seq id generated = %d %d %d %d\n", seq_id[0],seq_id[1],seq_id[2],seq_id[3]);
						bzm_params.exp_noncecnt+=effbst_write_job(b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

					}
				}
			}
		}
		//seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_readreg_inbetween_readresult()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					

					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{



						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		/* removed wait_for_tdmresult so that read status command will be sent while getting results */

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}



		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_readreg_inbetween_readresult()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		/* removed wait_for_tdmresult so that read status command will be sent while getting results */

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_incomplete_jobsubmit()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,0xff,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];


						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						effbst_write_bch_data_incomplete(b,a,c,r,seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;

						if((ret=startnonce_reg_write_read_verify(b,a,c,r))!=0)
						{
							rand_log(LOG_ERROR,"[ERROR] - incomplete job failed due to expected packets are not dropped\n");
							goto END;
						}
					}
				//}
			}
		}

		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;
	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_timestamp1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	bzm_params.cfg.timestampcount = 1;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);
	bzm_params.verify_nonce_received = false; //making it false since more nonce will be generated for timestamp1


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{



						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
#if 0
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

#endif
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt*2); //*2 for timestamp1

		if(ret)
			break;

		if(bzm_params.collected_noncecnt < bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

	}

	/*ret|= verify_noncecollected(true); */


	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_resultfsm_overflow()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t timeout=180;

	uint8_t mode = 1;
	time_t start_tt, end_tt, diff_tt;
	uint32_t overflow_asic_count = 0;
	uint32_t status=0xAA;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	//bzm_params.cfg.regression_count=2; /* fixing the regression count to 2 */

	bzm_params.disable_noncecopy_to_mem=true;
	bzm_params.tdm_counter_updated=true;
	bzm_params.tdm_counter=0xFF; //fixing to 0xFF so that results will not be received on tdm line when more slots avaiable.

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		overflow_asic_count = 0;bzm_params.collected_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{



						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.cfg.timestampcount = 127;
						effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
					}
				}
			}

			time(&start_tt);
			rand_log(LOG_INFO,"ResultFSM FIFO check...\n");
			for (int a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				while(1)
				{
					status=0xAA;
					time(&end_tt);
					diff_tt=difftime(end_tt, start_tt);
					if(diff_tt>=timeout){
						rand_log(LOG_INFO,"checking for overflow b:%d a:%d\n",b,a);
						time(&start_tt);
					}

					while(!uart_command_readreg_tdm_async(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_RESULT_STS_CTL, 4,tdm_readreg_callback,&status));

					if ((status & 0x4) == 0x4)
					{
						rand_log(LOG_INFO, "[ResultFSM FIFO FULL] b:%d a:%d status:0x%x\n", b, a, status);
						overflow_asic_count++;
						break;
					}

				}
			}

		}
		seq_id+=2*subjobcnt;  /* updating seq id for next iteration */

		if (overflow_asic_count != bzm_params.asic_count)
		{
			rand_log(LOG_ERROR, "[ERROR] All ASICS Did Not achieved Overflow");
			ret = ERR_RESULTFSM_OVERFLOW_NOT_HIT;
		}
		mode = 2;
		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			sleep(1);
			rand_log(LOG_INFO, "Cancelling all the jobs\n");
			uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_JOB_CONTROL, 1, &mode);

		}
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*2);
		if(ret)
			break;

	}


	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;



}


int test_effbst_tdm_softreset()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id  */
		/* issuing soft-reset */
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			asic_soft_reset(b, BROADCAST_ASIC);
		}

		/* clk ungate engines and enable effbst */
		if((ret=enable_effbst()))
			goto END;

		/* clear all the nonce collected so far */
		init_eng_nonce_list();
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		/* submit new jobs */
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}






int test_effbst_tdm_canceljob()
{
	int ret=SUCCESS;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	uint32_t mode0_result=0 ,mode2_result=0,mode3_result=0;

	initialize_board(1, 0);

	if((ret=enable_effbst()))
		goto END;


	mode0_result = load_and_cancel_job(CANCEL_PENDING_JOB, false, false);
	rand_log(LOG_INFO,"CANCEL_PENDING_JOB - Mode0 Result=%d \n",mode0_result);

	usleep(2000);
	mode2_result = load_and_cancel_job(CANCEL_CUR_PENDING_JOB,false, false);
	rand_log(LOG_INFO,"CANCEL_CUR_PENDING_JOB - Mode2 Result=%d \n",mode2_result);

	usleep(2000);
	mode3_result = load_and_cancel_job(CANCEL_CURRENT_JOB,false, false);
	rand_log(LOG_INFO,"CANCEL_CURRENT_JOB - Mode3 Result=%d \n",mode3_result);

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	if( (mode0_result == 0) && (mode2_result == 0) && (mode3_result == 0) )
	{
		ret= SUCCESS;
	}
	else
	{
		ret= ERR_CANCELJOB_MODE_FAILURE;
	}

	END:
	return ret;
}



int test_effbst_thermal_trip()
{


	int ret = SUCCESS;
	uint32_t value;
	uint32_t sw_timeout_thermal_trip=0;
	uint32_t timetaken=0,timetaken1=0;
	uint8_t timeout = 10;
	uint8_t seq_id=0;
	uint32_t effbst_data_index;

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	effbst_data_index = bzm_params.effbst_data_index;
	initialize_voltage_thermal_thershold_and_resolution();

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{

		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		// Using multiple boards
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
			ret=asic_global_reset(b,false);
			if(ret)
				return ret;
			ret=engine_init(b);
			if(ret)
				return ret;
		}

		initialize_board(1, 0);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);

		}

		if((ret=enable_effbst()))
			goto END;


		sw_timeout_thermal_trip = bzm_params.sw_timeout;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			uint32_t a=0;

			if(bzm_params.asic_count>1)
			{
				randomize(bzm_params.active_asic_id[b],bzm_params.asic_count);
				a=bzm_params.active_asic_id[b][0];
			}
			else
			{
				a=bzm_params.active_asic_id[b][0];
			}


			uint32_t r=0,c=0;
			value = 0x00;
			uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_TUNE_CODE, 4, &value);
			value = (bzm_params.therm_threshold<<1) | 0x01; //enable and set threshold value

			uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_TUNE_CODE, 4, &value);

			value = 0;
			while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_TUNE_CODE, 4, &value));
			rand_log(LOG_INFO, "1. board:%d asic:%d LOCAL_REG_TEMPSENSOR_TUNE_CODE:0x%x\n", b, a, value);

			while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TRIP_STATUS, 4, &value));
			rand_log(LOG_INFO, "1. board:%d asic:%d LOCAL_REG_THERMAL_TRIP_STATUS:0x%x\n", b, a, value);
			if(value!=0)
			{
				rand_log(LOG_ERROR, "[ERROR] trip triggered before setting threshold to low value board:%d asic:%d LOCAL_REG_THERMAL_TRIP_STATUS:0x%x\n", b, a, value);

			}

			while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TEMP_CODE, 4, &value));
			rand_log(LOG_INFO, "1. board:%d asic:%d LOCAL_REG_THERMAL_TEMP_CODE:0x%x\n", b, a, value);

			ret=effbst_submitjob_getresults_1engine(b,a,r,c,seq_id,bzm_params.effbst_data_index,&timetaken);
			if(ret)
				goto END;
			seq_id+=bzm_params.effbst_max_subjobs;

			rand_log(LOG_INFO, "Time taken for jobs submitted before thermal trip = %ds\n",timetaken);

			uint32_t temp =0;
			while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TEMP_CODE, 4, &temp));
			rand_log(LOG_INFO, "2. b:%d a:%d LOCAL_REG_THERMAL_TEMP_CODE:0x%x\n", b, a, temp);

			temp =((temp-20)<<1) | 0x01;
			uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TEMPSENSOR_TUNE_CODE, 4, &temp); // set threshold low than current temp
			timeout = 10;
			while(1)
			{
				value = 0;
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TRIP_STATUS, 4, &value));
				rand_log(LOG_INFO, "2. board:%d asic:%d LOCAL_REG_THERMAL_TRIP_STATUS:0x%x\n", b, a, value);
				if(value == 0x1)
				{
					rand_log(LOG_INFO,"Thermal Trip Triggered\n");
					break;
				}
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_INFO, "Thermal Trip not Triggered. Timeout occured\n");
					ret=1;
					break;
				}
			}
			if(ret)
				goto END;
			while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TEMP_CODE, 4, &temp));

			bzm_params.sw_timeout = sw_timeout_thermal_trip * 2;
			bzm_params.effbst_data_index = effbst_data_index;
			ret= effbst_submitjob_getresults_1engine(b,a,r,c,seq_id,bzm_params.effbst_data_index,&timetaken1);
			if(ret)
				goto END;
			seq_id+=bzm_params.effbst_max_subjobs;
			rand_log(LOG_INFO, "Time taken for jobs submitted after thermal trip = %d s\n",timetaken1);

			if(bzm_params.cfg.env == POSTSILICON)
			{
				if(timetaken1>timetaken)
				{
					rand_log(LOG_INFO,"Time difference without trip and with trip = %d\n", (timetaken1-timetaken));
					ret=SUCCESS;
				}
				else
				{
					ret=ERR_EXPECTED_TIME_NOTMET;
				}
			}


		}
		END:
		disable_tdm();
		if(ret)
			break;

	}
	bzm_params.sw_timeout = sw_timeout_thermal_trip;
	return ret;
}




int test_effbst_tdm_jobsubmit_with_diff_merkelrootresidue()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];						
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_job_hacked_diff_mrr(b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.job_submit+=subjobcnt;

					}
				//}
			}
		}

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if (bzm_params.engine_exist[b][a][r][c] == 0){
							continue;
						}
						for(uint32_t i=seq_id;i<seq_id+3;i++)
						{
							bzm_params.eng_nonce_list[b][a][r][c][i]->jobsubmitted=0;
						}
					}

				//}
			}
		}


		seq_id+=subjobcnt;  /* updating seq id for next iteration */

		ret |= verify_noncecollected(true);
		if(ret)
			break;

	}



	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobsubmit_with_same_subjobs()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_job_hacked_same_subjobs(b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.job_submit+=subjobcnt;

						}
				//}
			}
		}
		seq_id+=subjobcnt;  /* updating seq id for next iteration */
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/bzm_params.engine_count));

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_autoclockgating()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t timestampcount=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}



	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);


					}
				}
			}
		}

		seq_id++;
		bzm_params.job_submit = bzm_params.engine_count;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);


		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			if(bzm_params.eng_type == FAKE_ENGINE)
				sleeptime=1;
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*2);
				loopcnt = 1;
			}

			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}
				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;

			break;

		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);
					}
				}
			}
		}
		seq_id++;
		bzm_params.job_submit += bzm_params.engine_count;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/bzm_params.engine_count));


		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}


	}

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_autoclockgating()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t timestampcount=0;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);

					}
				}
			}
		}
		seq_id+=subjobcnt;  // updating seq id for next iteration
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);


		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*2);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);


					}

				}

			}
		}
		seq_id+=subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit += bzm_params.engine_count*subjobcnt;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/(bzm_params.engine_count*subjobcnt)));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}


	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}




int test_tdm_autoclockgating_b2b()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t timestampcount=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;

	get_next_static_data_index();

	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);
						seq_id++;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,timestampcount);
						seq_id--;

					}
				}
			}
		}
		seq_id+=2;
		bzm_params.job_submit = bzm_params.engine_count*2;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2*2)/sleeptime; /* *2 for 2jobs, and *2 to extend time for 1 more loop to collect more result */
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*2*2);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);




			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);
					}
				}
			}
		}
		seq_id++;
		bzm_params.job_submit += bzm_params.engine_count;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/bzm_params.engine_count));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}


	}

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_autoclockgating_b2b()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t timestampcount=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1<<7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);
						seq_id+=subjobcnt;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);

						seq_id-=subjobcnt;  // subtracting back to use same seq ids for all engines
					}
				}
			}
		}

		seq_id+=subjobcnt*2;  // updating seq id for next iteration
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt*2;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);


		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2*2)/sleeptime;/* *2 for 2jobs, and *2 to extend time for 1 more loop to collect more result */
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*2*2);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d\n",loopcnt);

			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);


					}
				}
			}
		}
		seq_id+=subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit += bzm_params.engine_count*subjobcnt;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/(bzm_params.engine_count*subjobcnt)));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


int test_tdm_autoclockgating_update_timestamp_inbetween()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t timestampcount=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) | bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);


					}
				}
			}
			sleep(1);
			uint32_t time=0;
			rand_log(LOG_INFO, "Updating timestamp register inbetween jobs\n");
			uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_TIMESTAMP_COUNT, 1, &time);

		}
		seq_id++;
		bzm_params.job_submit = bzm_params.engine_count;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
			bool usleep_enable=false;
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d\n",loopcnt);

			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*2);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);



			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}



		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);
					}
				}
			}
		}
		seq_id++;
		bzm_params.job_submit += bzm_params.engine_count;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/bzm_params.engine_count));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}


	}

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_engine_recovery_with_1tce()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t value = 0;
	long timetaken_2tce_secs, timetaken_1tce_secs;
	long timetaken_2tce_ns, timetaken_1tce_ns;
	uint32_t static_data_index=0;
	uint32_t sw_timeout;
	uint32_t default_timeout;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();
	static_data_index = bzm_params.static_data_index;

	if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
		bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}
	default_timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.sw_timeout = default_timeout;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;



			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				value = 0;
				engine_config(b, a, value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						value = 0;
						uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
						rand_log(LOG_INFO, "b:%d a:%d r:%d c:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, r, c, value);
					}
				}
			}
		}
		static_data_index = bzm_params.static_data_index ;
		bzm_params.exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_NORMAL;

		rand_log(LOG_INFO,"JOB_SUBMIT with Both even and old TCE are on\n");

		sw_timeout = bzm_params.sw_timeout;
		ret=submitjob_getresults_allengines(seq_id,bzm_params.static_data_index);
		if(ret)
			break;
		seq_id++;

		timetaken_2tce_secs = bzm_params.timetaken_secs;
		timetaken_2tce_ns = bzm_params.timetaken_ns;

		//second stage of code
		bzm_params.tce_selected = rand() % 2;

		if(bzm_params.tce_selected == ODD_TCE)
		{
			rand_log(LOG_INFO,"Testing JOBS with Enable even TCE 0 and keep odd TCE 1 off\n");
			value=2 | (1<<4);
		}
		else
		{
			rand_log(LOG_INFO,"Testing JOBS with Enable Odd TCE 1 and keep even TCE 0 off\n");
			value=1 | (1<<4);
		}

		bzm_params.exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_1TCE_NORMAL;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_soft_reset(b,BROADCAST_ASIC);
			sleep(1);

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				engine_config(b, a, value);

			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t readvalue=0;
						uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue);
						rand_log(LOG_INFO, "b:%d a:%d c:%d r:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , readvalue);
						if(readvalue!=value)
						{
							ret= ERR_READVALUE_MISMATCH;
							rand_log(LOG_ERROR, "[ERROR] -ENGINE_REG_CONFIG not updated. Write value=0x%x, readvalue=0x%x\n",value,readvalue);
							goto END;
						}
					}
				}
			}
		}


		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;


		bzm_params.static_data_index = static_data_index;
		bzm_params.sw_timeout = sw_timeout*2;
		ret=submitjob_getresults_allengines(seq_id,bzm_params.static_data_index);
		if(ret)
			break;
		seq_id++;
		timetaken_1tce_secs = bzm_params.timetaken_secs;
		timetaken_1tce_ns = bzm_params.timetaken_ns;
		uint32_t timetaken_1tce, timetaken_2tce;
		if((timetaken_2tce_secs>0) || (timetaken_1tce_secs>0))
		{
			timetaken_1tce = timetaken_1tce_secs;
			timetaken_2tce = timetaken_2tce_secs;
		}
		else
		{
			timetaken_1tce = timetaken_1tce_ns;
			timetaken_2tce = timetaken_2tce_ns;
		}
		if(bzm_params.eng_type != FAKE_ENGINE){
			if(timetaken_1tce>timetaken_2tce)
			{
				rand_log(LOG_INFO,"Time taken with 2TCE=%d and 1TCE=%d. Diff= %d\n",timetaken_2tce,timetaken_1tce, (timetaken_1tce-timetaken_2tce));
				ret = SUCCESS;
			}
			else
			{
				rand_log(LOG_ERROR,"[ERROR] Time taken is not double. Time taken with 2TCE=%d and 1TCE=%d. Diff= %d\n",timetaken_2tce,timetaken_1tce, (timetaken_1tce-timetaken_2tce));
				ret = ERR_EXPECTED_TIME_NOTMET;
			}
		}
	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}



int test_effbst_tdm_engine_recovery_with_disabletce()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t value = 0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t tcelist[MAX_EFFBST_SUBJOBS]={0,1,2,3};
	uint8_t tce_gated_cnt;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();



	//if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
	//	bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		return ret;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();



		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_soft_reset(b,BROADCAST_ASIC);
			sleep(1);



			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						for(uint32_t t=0;t<MAX_EFFBST_SUBJOBS;t++)
							bzm_params.tce_clkgated[b][a][r][c][t]=0;

						value=(1<<EFFBST_ENABLE_BITPOS) |(1<<4);

						tce_gated_cnt = rand()%4; //no. of TCEs to disable

						randomize(tcelist,MAX_EFFBST_SUBJOBS); //Shuffling the TCE number list

						for(uint32_t i=0;i<tce_gated_cnt;i++)
						{
							if(tcelist[i] == 0)
							{
								rand_log(LOG_INFO,"b:%d a:%d c:%d r:%d Testing JOBS with TCE 0 off\n",b ,a, c, r);
								value|= 1<<0;
								bzm_params.tce_clkgated[b][a][r][c][0] = 1;
							}
							else if(tcelist[i] == 1)
							{
								rand_log(LOG_INFO,"b:%d a:%d c:%d r:%d Testing JOBS with TCE 1 off\n",b ,a, c, r);
								value|= 1<<1;
								bzm_params.tce_clkgated[b][a][r][c][1] = 1;
							}
							else if(tcelist[i] == 2)
							{
								rand_log(LOG_INFO,"b:%d a:%d c:%d r:%d Testing JOBS with TCE 2 off\n",b ,a, c, r);
								value|=1<<5;
								bzm_params.tce_clkgated[b][a][r][c][2] = 1;
							}
							else if(tcelist[i] == 3)
							{
								rand_log(LOG_INFO,"b:%d a:%d c:%d r:%d Testing JOBS with TCE 3 off\n",b ,a, c, r);
								value|=1<<6;
								bzm_params.tce_clkgated[b][a][r][c][3] = 1;
							}
						}
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
						uint8_t readvalue=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue));
						rand_log(LOG_INFO, "b:%d a:%d c:%d r:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , readvalue);
						if(readvalue!=value)
						{
							ret= ERR_READVALUE_MISMATCH;
							rand_log(LOG_ERROR, "[ERROR] -ENGINE_REG_CONFIG not updated. Write value=0x%x, readvalue=0x%x\n",value,readvalue);

							goto END;
						}
					}
				}
			}
		}

		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			//break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			break; /*breaking regression loop on failure */
		}

	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;


}

int test_effbst_tdm_engine_recovery_with_1tce()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t value = 0;
	long timetaken_2tce_secs, timetaken_1tce_secs;
	long timetaken_2tce_ns, timetaken_1tce_ns;
	uint32_t effbst_data_index=0;
	uint32_t sw_timeout;
	uint32_t default_timeout;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	effbst_data_index = bzm_params.effbst_data_index ;


	//if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
	//	bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if((ret=enable_effbst()))
		return ret;

	default_timeout = bzm_params.sw_timeout;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.sw_timeout = default_timeout;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				value=1<<EFFBST_ENABLE_BITPOS | 0 | (1<<4);
				engine_config(b, a, value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						value = 0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value));
						rand_log(LOG_INFO, "b:%d a:%d r:%d c:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, r, c, value);
					}
				}
			}
		}
		effbst_data_index = bzm_params.effbst_data_index ;
		bzm_params.effbst_exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_EFFBST;

		//rand_log(LOG_INFO,"JOB_SUBMIT with Both even and old TCE are on\n");

		rand_log(LOG_INFO,"JOB_SUBMIT with all TCE on\n");

		sw_timeout = bzm_params.sw_timeout;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

		timetaken_2tce_secs = bzm_params.timetaken_secs;
		timetaken_2tce_ns = bzm_params.timetaken_ns;

		//second stage of code
		bzm_params.tce_selected = rand() % 2;


		if(bzm_params.tce_selected == ODD_TCE)
		{
			rand_log(LOG_INFO,"Testing JOBS with Enable even TCE 0 and keep odd TCE 1 off\n");
			value|=(1<<EFFBST_ENABLE_BITPOS) | 2 | (1<<4);
		}
		else
		{
			rand_log(LOG_INFO,"Testing JOBS with Enable Odd TCE 1 and keep even TCE 0 off\n");
			value|=(1<<EFFBST_ENABLE_BITPOS) | 1 | (1<<4);
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_soft_reset(b,BROADCAST_ASIC);
			sleep(1);



			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				engine_config(b, a, value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t readvalue=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue));
						rand_log(LOG_INFO, "b:%d a:%d c:%d r:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , readvalue);
						if(readvalue!=value)
						{
							ret= ERR_READVALUE_MISMATCH;
							rand_log(LOG_ERROR, "[ERROR] -ENGINE_REG_CONFIG not updated. Write value=0x%x, readvalue=0x%x\n",value,readvalue);

							goto END;
						}
					}
				}
			}
		}

		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;

		bzm_params.effbst_data_index = effbst_data_index;
		bzm_params.effbst_exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_1TCE_EFFBST;
		bzm_params.sw_timeout = sw_timeout*2;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

		timetaken_1tce_secs = bzm_params.timetaken_secs;
		timetaken_1tce_ns = bzm_params.timetaken_ns;

		uint32_t timetaken_1tce, timetaken_2tce;
		if((timetaken_2tce_secs>0) || (timetaken_1tce_secs>0))
		{
			timetaken_1tce = timetaken_1tce_secs;
			timetaken_2tce = timetaken_2tce_secs;
		}
		else
		{
			timetaken_1tce = timetaken_1tce_ns;
			timetaken_2tce = timetaken_2tce_ns;
		}


		if(bzm_params.eng_type != FAKE_ENGINE){
			if(timetaken_1tce>timetaken_2tce)
			{
				rand_log(LOG_INFO,"Time taken with 2TCE=%d and 1TCE=%d. Diff= %d\n",timetaken_2tce,timetaken_1tce, (timetaken_1tce-timetaken_2tce));
				ret = SUCCESS;
			}
			else{
				rand_log(LOG_ERROR," [ERROR] Time taken with 2TCE=%d and 1TCE=%d. Diff= %d\n",timetaken_2tce,timetaken_1tce, (timetaken_1tce-timetaken_2tce));
				ret = ERR_EXPECTED_TIME_NOTMET;
			}
		}
	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;


}

int test_tdm_selectable_leadingzeros()
{
	uint32_t bch_data_index = bzm_params.cfg.bch_data_index%32;
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t value = 0;
	bzm_params.leadingzeros_to_find = 32 + bch_data_index;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);
	bzm_params.verify_nonce_received=false;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.leadingzeros_enabled=true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
						rand_log(LOG_INFO,"\nFind ZEROS  = %d\n",bzm_params.leadingzeros_to_find);

						value=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
						rand_log(LOG_INFO,"\nValue of ENGINE_REG_ZEROS_TO_FIND = %d\n",value);
						if(value!=wrvalue)
						{
							ret= ERR_READVALUE_MISMATCH;
							goto END;
						}

						bzm_params.exp_noncecnt+=leadingzeros_write_bch_data(false,false,false,true, b, a, c, r, seq_id,bch_data_index,bzm_params.cfg.timestampcount);
						//bzm_params.exp_noncecnt+=leadingzeros_write_bch_data(false,true,false,true, b, a, c, r, seq_id,bch_data_index,bzm_params.cfg.timestampcount);

						bzm_params.job_submit++;
						bch_data_index++;

						bzm_params.leadingzeros_to_find++;
						if(bzm_params.leadingzeros_to_find >= MAX_LEADING_ZEROS )
						{
							bzm_params.leadingzeros_to_find = MIN_LEADING_ZEROS;
							bch_data_index=0;
						}

					}
				}
			}
		}
		seq_id++;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;

		ret|= verify_noncecollected(true);
		if(ret)
			break;
		if(bzm_params.hw_sha256_fail)
		{
			rand_log(LOG_ERROR, "SHA FAILURE COUNT = %d\n",bzm_params.hw_sha256_fail);
			ret=ERR_SHA_FAILURE;
			break;
		}

	}



	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_tdm_selectable_leadingzeros_update_zerotofind_inbetween()
{
	uint32_t bch_data_index = bzm_params.cfg.bch_data_index%32;
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t value = 0;
	bzm_params.leadingzeros_to_find = 32+bch_data_index;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);
	bzm_params.verify_nonce_received=false;
	value=0;
	uart_command_readreg(bzm_params.uart_dev, 0, 0, 0, ENGINE_REG_ZEROS_TO_FIND, 1, &value);
	rand_log(LOG_INFO,"\nInitial value of ENGINE_REG_ZEROS_TO_FIND = 0x%x\n",value);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.leadingzeros_enabled=true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.test_updated_leading0=false;

		uint32_t board=0, asic=0, row=0, col=0;

		if(bzm_params.cfg.boardcount>1)
		{
			board = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			board=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[board],bzm_params.asic_count);
			asic=bzm_params.active_asic_id[board][asic];
		}
		else
		{
			asic=bzm_params.active_asic_id[board][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[board][asic],bzm_params.enginecount_per_asic);
			row = bzm_params.active_row_id[board][asic][0];
			randomize(bzm_params.active_col_id[board][asic][row],bzm_params.enginecount_per_asic);
			col =  bzm_params.active_col_id[board][asic][row][0];
		}
		else
		{
			row = bzm_params.active_row_id[board][asic][0];
			col = bzm_params.active_col_id[board][asic][row][0];
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);

						value=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
						rand_log(LOG_INFO,"b:%d a%d r:%d c:%d - Value of ENGINE_REG_ZEROS_TO_FIND = %d, No.of zeros=%d\n",b,a,r,c,value,bzm_params.leadingzeros_to_find);
						if(value!=wrvalue)
						{
							ret= ERR_READVALUE_MISMATCH;
							goto END;
						}

						bzm_params.exp_noncecnt+=leadingzeros_write_bch_data(false,true,false,true, b, a, c, r, seq_id,bch_data_index,bzm_params.cfg.timestampcount);


						if((b==board) && (a==asic) && (r==row) && (c==col))
						{
							uint32_t lower_limit,upper_limit;
							uint32_t no_of_zeros=0;
							no_of_zeros = bzm_params.leadingzeros_to_find-32;
							if(no_of_zeros > 33)
							{
								if((l%2)==1)
								{
									/* selecting a value higher than the already programmed value */
									lower_limit = (no_of_zeros+1)%32; /* +1 is not to select the already written value and %32 to roll over*/
									upper_limit = 31;
								}
								else
								{
									/* selecting a value lower than the already programmed value */
									lower_limit = 0;
									upper_limit = (no_of_zeros-1)%32; /* -1 is not to select the already written value and %32 to rollover*/

								}
							}
							else
							{
								/* selecting a value higher than the already programmed value */
								lower_limit = (no_of_zeros+1)%32; /* +1 is not to select the already written value and %32 to roll over*/
								upper_limit = 31;
							}


							no_of_zeros = ((rand() % ((upper_limit - lower_limit)+1)) + lower_limit) ;

							bzm_params.test_updated_leading0=true;
							uint8_t wrvalue=no_of_zeros;
							uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
							rand_log(LOG_INFO,"b:%d a%d r:%d c:%d - Updating ENGINE_REG_ZEROS_TO_FIND from %d to %d\n",b,a,r,c,bzm_params.leadingzeros_to_find-32,wrvalue);
							bzm_params.data_index_with_leading0_updated = bch_data_index;
							bzm_params.updated_leading0 = no_of_zeros;
							value=0;
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
							rand_log(LOG_INFO,"b:%d a%d r:%d c:%d - Value of ENGINE_REG_ZEROS_TO_FIND = %d\n",b,a,r,c,value);
							if(value!=wrvalue)
							{
								ret= ERR_READVALUE_MISMATCH;
								goto END;
							}
						}
						bzm_params.job_submit++;
						bch_data_index++;
						bzm_params.leadingzeros_to_find++;
						if(bzm_params.leadingzeros_to_find >= MAX_LEADING_ZEROS )
						{
							bzm_params.leadingzeros_to_find = MIN_LEADING_ZEROS;
							bch_data_index=0;
						}

					}
				}
			}

		}
		seq_id++;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
#if 0
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
#endif

		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;
#if 0
		ret|= verify_noncecollected(true);
		if(ret)
			break;
#endif
		if(bzm_params.hw_sha256_fail)
		{
			rand_log(LOG_ERROR, "SHA FAILURE COUNT = %d\n",bzm_params.hw_sha256_fail);
			ret=ERR_SHA_FAILURE;
			break;
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if (bzm_params.engine_exist[b][a][r][c] == 0){
							continue;
						}
						for(uint32_t i=0;i<MAX_SEQ_ID;i++)
						{
							if(bzm_params.eng_nonce_list[b][a][r][c][i]->jobsubmitted ==1)
							{
								uint32_t collected_noncecnt;
								uint32_t collected_nonce[MAX_NONCE];
								collected_noncecnt= bzm_params.eng_nonce_list[b][a][r][c][i]->noncecount;
								uint32_t static_data_index=bzm_params.eng_nonce_list[b][a][r][c][i]->static_data_index;
								rand_log(LOG_INFO, "b:%d a:%d r:%d c:%d seq_id:%d bch_data_index:%d noncecount:%d, leading_zeros_noncecnt=%d, collected nonce : [ ",b,a,r,c,i,static_data_index,bzm_params.eng_nonce_list[b][a][r][c][i]->leadingzeros_noncecnt, collected_noncecnt);

								for(uint32_t j=0;j<collected_noncecnt;j++)
								{
									collected_nonce[j] = bzm_params.eng_nonce_list[b][a][r][c][i]->noncecollected[j];
									printf("0x%x ", collected_nonce[j]);  //from index 2 we hav the nonce

								}
								printf("]\n");

							}

						}
					}
				}
			}
		}

	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_effbst_tdm_selectable_leadingzeros()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;

	//uint32_t skip_leading0s[14] = {43, 44, 45, 46, 47, 48, 49, 50, 51, 59, 60, 61, 62, 63}; //vector not available for the list

	uint8_t value = 0;
	bzm_params.leadingzeros_to_find = (bzm_params.cfg.effbst_bch_data_index%32) + 32;

	bzm_params.cfg.nonce_count=MAX_NONCE-1; // setting it -1 to go into while loop in get_next_effbst_data_index

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.leadingzeros_enabled=true;

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);
	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
						rand_log(LOG_INFO,"\nFind ZEROS  = %d\n",bzm_params.leadingzeros_to_find);

						value=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
						rand_log(LOG_INFO,"\nValue of ENGINE_REG_ZEROS_TO_FIND = %d\n",value);
						if(value!=wrvalue)
						{
							ret= ERR_READVALUE_MISMATCH;
							goto END;
						}
						bzm_params.effbst_index_leading0s[bzm_params.effbst_data_index]=bzm_params.leadingzeros_to_find;
						uint32_t exp_noncecnt=0;
						exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						rand_log(LOG_INFO, "Leading 0s=%d Expected Nonce count= %d\n",bzm_params.leadingzeros_to_find-1,exp_noncecnt);
						if(exp_noncecnt==0)
						{
							rand_log(LOG_ERROR, "[ERROR] - Job not found for %d leading 0s\n",bzm_params.leadingzeros_to_find);
							goto END;

						}
						bzm_params.exp_noncecnt+=exp_noncecnt;


					}
				}
			}
		}
		seq_id+=bzm_params.effbst_max_subjobs;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*bzm_params.effbst_max_subjobs;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;
#if 1
		ret|= verify_noncecollected(true);
		if(ret)
			break;
		if(bzm_params.hw_sha256_fail)
		{
			rand_log(LOG_ERROR, "SHA FAILURE COUNT = %d\n",bzm_params.hw_sha256_fail);
			ret=ERR_SHA_FAILURE;
			break;
		}
#endif
	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_effbst_tdm_selectable_leadingzeros_update_zerotofind_inbetween()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t value = 0;
	bzm_params.leadingzeros_to_find = 32;
	uint32_t bch_data_index_to_update = 164;
	uint32_t prev_bch_data=0;

	bzm_params.cfg.nonce_count=MAX_NONCE-1; // setting it -1 to go into while loop in get_next_effbst_data_index


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);


	//bzm_params.cfg.effbst_bch_data_index = 164;//bzm_params.cfg.effbst_bch_data_index;
	//get_next_effbst_data_index();
	//bzm_params.cfg.same_job=1;

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	//bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);
	if((ret=enable_effbst()))
		goto END;

	bzm_params.leadingzeros_enabled=true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.test_updated_leading0=false;

		uint32_t board=0, asic=0, row=0, col=0;

		if(bzm_params.cfg.boardcount>1)
		{
			board = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			board=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[board],bzm_params.asic_count);
			asic=bzm_params.active_asic_id[board][asic];
		}
		else
		{
			asic=bzm_params.active_asic_id[board][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[board][asic],bzm_params.enginecount_per_asic);
			row = bzm_params.active_row_id[board][asic][0];
			randomize(bzm_params.active_col_id[board][asic][row],bzm_params.enginecount_per_asic);
			col =  bzm_params.active_col_id[board][asic][row][0];
		}
		else
		{
			row = bzm_params.active_row_id[board][asic][0];
			col = bzm_params.active_col_id[board][asic][row][0];
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{

						
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);

						value=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
						rand_log(LOG_INFO,"b:%d a%d r:%d c:%d - Value of ENGINE_REG_ZEROS_TO_FIND = %d, No.of zeros=%d\n",b,a,r,c,value,bzm_params.leadingzeros_to_find);
						if(value!=wrvalue)
						{
							ret= ERR_READVALUE_MISMATCH;
							goto END;
						}
						if((b==board) && (a==asic) && (r==row) && (c==col))
						{
							prev_bch_data=bzm_params.effbst_data_index;
							bzm_params.effbst_data_index = bch_data_index_to_update;
						}

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if((b==board) && (a==asic) && (r==row) && (c==col))
						{
							bzm_params.effbst_data_index = prev_bch_data;
							uint32_t lower_limit,upper_limit;
							uint32_t no_of_zeros=0;
#if 0
							no_of_zeros = bzm_params.leadingzeros_to_find-32;

							if(no_of_zeros > 33)
							{
								if((l%2)==1)
								{
									/* selecting a value higher than the already programmed value */
									lower_limit = (no_of_zeros+1)%32; /* +1 is not to select the already written value and %32 to roll over*/
									upper_limit = 31;
								}
								else
								{
									/* selecting a value lower than the already programmed value */
									lower_limit = 0;
									upper_limit = (no_of_zeros-1)%32; /* -1 is not to select the already written value and %32 to rollover*/

								}
							}
							else
							{
								/* selecting a value higher than the already programmed value */
								lower_limit = (no_of_zeros+1)%32; /* +1 is not to select the already written value and %32 to roll over*/
								upper_limit = 31;
							}

#endif
							upper_limit=20; //index 164 has 52 zeros. So keeping upper limit=20 (52-32)
							lower_limit=0;
							no_of_zeros = ((rand() % ((upper_limit - lower_limit)+1)) + lower_limit) ;

							bzm_params.test_updated_leading0=true;
							uint8_t wrvalue=no_of_zeros;
							uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
							rand_log(LOG_INFO,"b:%d a%d r:%d c:%d - Updating ENGINE_REG_ZEROS_TO_FIND from %d to %d\n",b,a,r,c,bzm_params.leadingzeros_to_find-32,wrvalue);
							bzm_params.data_index_with_leading0_updated = bch_data_index_to_update;
							bzm_params.updated_leading0 = no_of_zeros;
							value=0;
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
							rand_log(LOG_INFO,"b:%d a%d r:%d c:%d - Value of ENGINE_REG_ZEROS_TO_FIND = %d\n",b,a,r,c,value);
							if(value!=wrvalue)
							{
								ret= ERR_READVALUE_MISMATCH;
								goto END;
							}
						}


#if 0
						bch_data_index++;
						bzm_params.leadingzeros_to_find++;
						if(bzm_params.leadingzeros_to_find >= MAX_LEADING_ZEROS )
						{
							bzm_params.leadingzeros_to_find = MIN_LEADING_ZEROS;
							bch_data_index=0;
						}
#endif

					}
				}
			}



		}
		seq_id+=bzm_params.effbst_max_subjobs;
		bzm_params.job_submit = bzm_params.engine_count*bzm_params.effbst_max_subjobs;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
#if 0
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
#endif

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;
#if 0
		ret|= verify_noncecollected(true);
		if(ret)
			break;
#endif
		if(bzm_params.hw_sha256_fail)
		{
			rand_log(LOG_ERROR, "SHA FAILURE COUNT = %d\n",bzm_params.hw_sha256_fail);
			ret=ERR_SHA_FAILURE;
			break;
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						

						if (bzm_params.engine_exist[b][a][r][c] == 0){
							continue;
						}
						for(uint32_t i=0;i<MAX_SEQ_ID;i++)
						{
							if(bzm_params.eng_nonce_list[b][a][r][c][i]->jobsubmitted ==1)
							{
								uint32_t collected_noncecnt;
								uint32_t collected_nonce[MAX_NONCE];
								collected_noncecnt= bzm_params.eng_nonce_list[b][a][r][c][i]->noncecount;
								uint32_t static_data_index=bzm_params.eng_nonce_list[b][a][r][c][i]->static_data_index;
								rand_log(LOG_INFO, "b:%d a:%d r:%d c:%d seq_id:%d bch_data_index:%d noncecount:%d, leading_zeros_noncecnt=%d, collected nonce : [ ",b,a,r,c,i,static_data_index,bzm_params.eng_nonce_list[b][a][r][c][i]->leadingzeros_noncecnt, collected_noncecnt);

								for(uint32_t j=0;j<collected_noncecnt;j++)
								{
									collected_nonce[j] = bzm_params.eng_nonce_list[b][a][r][c][i]->noncecollected[j];
									printf("0x%x ", collected_nonce[j]);  //from index 2 we hav the nonce

								}
								printf("]\n");

							}

						}
					}
				}
			}
		}

	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_effbst_tdm_writejob_readresult_pnp()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	static int fncallcnt=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	if(bzm_params.notch_initialized==false)
		initialize_board(1, 0);


	bzm_params.tdm_divider_value = 0xFF;//125;
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);


	if(fncallcnt==0)
	{
		bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
		get_next_effbst_data_index();
		if((ret=enable_effbst()))
			goto END;
	}

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if(bzm_params.asic_exist[b][a] == 0)
				continue;

			uint32_t div_index = rand() % bzm_params.no_of_sensor_clkdiv;
			uint32_t clk_div = bzm_params.sensor_clkdiv_list[div_index];

			uint32_t status1, status2;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status1));
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status1);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS before clk update =0x%x\n",b,a,status1);

			thermal_sensor_clk_update(b, a, clk_div);
			sleep(1);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status2));
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status2);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS after clk update =0x%x\n",b,a,status2);

			if(status1 != status2)
			{
				rand_log(LOG_INFO, "[ERROR] - Temperature data before and after clock setting is not same. Before=0x%x. After=0x%x\n", status1, status2);
				ret=FAILURE;
				goto END;
			}
		}
	}

	/** Time Initialization START **/
	double var_total_execution_time;
	struct timespec var_start_time= {0,0}, var_end_time= {0,0};
	/** Time Initialization END **/

	/** Execution Time START**/
	clock_gettime(CLOCK_MONOTONIC, &var_start_time);


	bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
	clear_jobdone_status_counters();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if(bzm_params.asic_exist[b][a] == 0)
				continue;

			for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
			{
				for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
				{

					if(bzm_params.engine_exist[b][a][r][c] == 0)
						continue;

					bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

				}
			}
		}
	}
	seq_id+=subjobcnt;  /* updating seq id for next iteration */

	bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
	bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

	rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
	/** Execution Time END **/
	/** Time Calculation START **/
	clock_gettime(CLOCK_MONOTONIC, &var_end_time);
	var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
			((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
	rand_log(LOG_INFO, "Time taken to send %d write jobs is: %.5f seconds ( OR %f minutes )\n",
			bzm_params.job_submit, var_total_execution_time, var_total_execution_time/60);
	/** Time Calculation END **/


	/** Execution Time START **/
	clock_gettime(CLOCK_MONOTONIC, &var_start_time);


	rand_log(LOG_INFO, "\nWait for TDM results....\n");
	ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
	rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

	if(ret)
		goto END;


	ret=check_all_engine_status(bzm_params.sw_timeout);

	if(ret)
		goto END;

	if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
	{
		rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		ret = ERR_NONCE_CNT_MISMATCH;
		goto END;
	}

	ret |= verify_noncecollected(true);
	if(ret)
		goto END;

	END:
	/** Execution Time END **/
	/** Time Calculation START **/
	clock_gettime(CLOCK_MONOTONIC, &var_end_time);
	var_total_execution_time=((double)var_end_time.tv_sec + 1.0e-9*var_end_time.tv_nsec) -
			((double)var_start_time.tv_sec + 1.0e-9*var_start_time.tv_nsec);
	rand_log(LOG_INFO, "Time taken to get PASS:%d NONCE is: %.5f seconds ( OR %f minutes )\n",
			bzm_params.collected_noncecnt,
			var_total_execution_time, var_total_execution_time/60);
	/** Time Calculation END **/

	fncallcnt=1;

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}
//*********


int test_effbst_fpga_baudrate_validation()
{
	int ret=SUCCESS;


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	/**
       -------------------------------------
       P1a.6       : TDM with varied BAUD rate for each ASIC in efficiency boost mode
       -------------------------------------
       FPGA Baud Rate Validation START
       Max Execution Time: 17 * 8 = 136 Minutes
       -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] TDM with varied BAUD rate for each ASIC in eff mode\n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	//sleep(3);

	for(uint32_t fpga_baudrate=0; fpga_baudrate<bzm_params.no_of_baud_rates; fpga_baudrate++)
	{
		/**
            possible values are
                DEC: 0 to 7
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - FPGA-BaudRate:%d \n",fpga_baudrate);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(0,0x2,fpga_baudrate);
		if(ret==SUCCESS)
		{
			ret = test_effbst_tdm_writejob_readresult_pnp();
		}

		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - FPGA-BaudRate:%d -  status: %s\n",fpga_baudrate,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		//sleep(5);

		//rand_log(LOG_DEBUG,"waiting for 5 seconds before starting next test \n");
		//sleep(5);
	}

	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P1a.7 \n");


	/** FPGA Baud Rate Validation END **/


	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

//****************


int test_eff_stop_bit_validation()
{

	int ret=0;


	rand_log(LOG_INFO,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	/**
        -------------------------------------
        P1a.7       : TDM with different STOP Bit variations in each ASIC
        -------------------------------------
        NANO & FPGA Stop Bit Validation START
        Execution Time:
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P1a.7 \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] TDM with different STOP Bit variations in each ASIC in eff boost mode\n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int stopbit=0; stopbit<=1; stopbit++)
	{
		/**
            possible values are
                DEC: 0 and 1
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - StopBit:%d \n",stopbit);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(stopbit,0x2,0);
		if(ret==SUCCESS)
		{
			ret = test_effbst_tdm_writejob_readresult_pnp();

		}

		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - StopBit:%d -  status: %s\n",stopbit,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		sleep(5);

		//rand_log(LOG_INFO,"waiting for 10 seconds before starting next test \n");
		//sleep(10);
	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P1a.7 \n");


	/** NANO & FPGA Stop Bit Validation END **/


	rand_log(LOG_INFO,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


//**************

int test_effbst_slowclk_baudrate_stopbit_variation()
{
	/**

 Project    : BZM
 Code Base  : bzm_bzmd/vicesv
 code file  : test.c


 Programming Code w.r.t. Test Plan:

    P1.8        : uart_validation- baud-rate change wrt refclk [+/- 2%] in eff boost mode

    P1a.6       : TDM with varied BAUD rate for each ASIC in eff boost mode
    P1a.7       : TDM with different STOP Bit variations in each ASIC in eff boost mode
    P1a..11     : UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops in eff boost mode

    P1b.5       : POR pll freq range - 1.8GHz to 2.2GHz :uart_refclock to fastclk ratio in eff boost mode
    P1b.6       : uart_pll frequency range step-up & step-down to engine behaves normal w/o reset in eff boost mode

 Master Function Name   :

        int test_eff_performance()

 Support Function Names :

        int test_uart_parameter_settings(int stop_bit, uint32_t slowclk, uint32_t FPGA_baud, int NANO_baudrate)
        int test_effbst_tdm_writejob_readresult_pnp()

 Description    : Check UART Performance / Functional Parameters

     (1) FPGA / NANO Stop bit
     (2) FPGA Slow Clock
     (3) FPGA Baud rate
     (4) NANO Baud rate / Ref Clock

 Validation Test Code Authors:

     Ashish     : ashishx.sinha@intel.com
     Vishal     : vishal.t.viradia@intel.com
     Tercina     : tercina.t@intel.com
 Validation Code Reviewer:

    Tatt Hee    : tatt.hee.oong@intel.com
    Tercina     : tercina.t@intel.com
    Vishal      : vishal.t.viradia@intel.com

 Validation Document Reviewer:

    Anita       : anita.harapanahalli.kulkarni@intel.com

 FPGA Image: 4x2 ( Real Engines )

	 **/

	int ret=SUCCESS;

	rand_log(LOG_INFO,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	/* int test_uart_parameter_settings_NANO(int stop_bit, uint32_t slowclk, uint32_t FPGA_baud, int NANO_baudrate) */

	/** testing only **/
	//test_uart_parameter_settings(0,0x2,0);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();

	//test_uart_parameter_settings_fpga(0,0x2,1);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();
	//    return 0;

	/*** Fast Clock PLL1_2 = 25MHz, Ref Clock PLL1_3 = 5MHz ( HAPS GUI - Manually ), NANO : B_50_3125000 ( Divisor 10 ) --> Verdict : PASS ***/
	//Default Configuration is : test_uart_baudrate_configuration(0,0x2,0,0);
	//test_uart_parameter_settings_NANO(0,0x2,0);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();
	//return 0;

	/*** Fast Clock PLL1_2 = 25MHz, Ref Clock PLL1_3 = 1MHz ( HAPS GUI - Manually ), NANO : B_50_625000 ( Divisor 50 ) --> Verdict : PASS ***/
	//test_uart_parameter_settings_NANO(0,0x2,4);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();

	/*** Fast Clock PLL1_2 = 25MHz, Ref Clock PLL1_3 = 2.5MHz ( HAPS GUI - Manually ), NANO : B_50_1563000 ( Divisor 20 ) --> Verdict : PASS ***/
	//test_uart_parameter_settings_NANO(0,0x2,1);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();

	/*** Fast Clock PLL1_2 = 25MHz, Ref Clock PLL1_3 = 0.5MHz ( HAPS GUI - Manually ), NANO : B_50_312500 ( Divisor 100 ) --> Verdict : PASS ***/
	//test_uart_parameter_settings_NANO(0,0x2,9);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();

	/*** Fast Clock PLL1_2 = 25MHz, Ref Clock PLL1_3 = 5MHz ( HAPS GUI - Manually ), NANO : B_50_3125000 ( Divisor 10 ), Stop Bit 1 ( 2 stop bits ) --> Verdict : PASS ***/
	//Default Configuration is : test_uart_baudrate_configuration(0,0x2,0,0);
	//test_uart_parameter_settings_NANO(1,0x2,0);
	//test_uart_WriteJob_ReadResultThread_TDM_Enabled_PnP();


	/**
        -------------------------------------
        P1a..11     : UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops
        -------------------------------------
        Stop Bit / FPGA Baud Rate / Slow Clock Validation START
        Execution Time: 17 * 8 * 5 * 2 = 1360 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST START ] : P1a.7, P1a.11, P1a.6  \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.7] TDM with different STOP Bit variations in each ASIC\n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.11] UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.6] TDM with varied BAUD rate for each ASIC \n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(uint32_t stopbit=0; stopbit<=1; stopbit++)
	{
		for(uint32_t fpga_baudrate=0; fpga_baudrate<bzm_params.no_of_baud_rates; fpga_baudrate++)
		{

			for(uint32_t slowclk=1; slowclk<=16; slowclk = slowclk * 2)

			{
				/**
                    StopBit: possible values are
                        DEC: 0 and 1

                    fpga_baudrate: possible values are
                        DEC: 0 to 7

                    slowclk: possible values are
                        HEX: 0x2, 0x4, 0x8, 0x10
                        DEC: 2, 4, 8, 16
				 **/
				if(((fpga_baudrate==1) ||(fpga_baudrate==0)) && ((slowclk==8) || (slowclk==16)))
				{
					rand_log(LOG_INFO, "Slowclk=%d Not supported with baudrate div=%d. skipping it...\n",slowclk,fpga_baudrate);
					continue;
				}
				if(bzm_params.cfg.env == PRESILICON)
				{

					unsigned long slowclk_hz=bzm_params.refclk/slowclk;
					unsigned long engclk_hz = bzm_params.cfg.fastclk*1000000;
					double clkratio = engclk_hz/slowclk_hz;
					rand_log(LOG_INFO,"CRI:Engine Clk ratio = %.3f\n",clkratio);
					if(clkratio <= 12)
					{
						rand_log(LOG_INFO,"CRI:Engine Clk ratio %.3f not supported. skipping slowclk %d\n",clkratio, slowclk);
						continue;
					}
				}


				rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
				rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - StopBit:%d, FPGA-BaudRate:%d, SlowClk:%d \n",stopbit,fpga_baudrate,slowclk);
				rand_log(LOG_INFO,"=========================================================================\n\n\n" );

				ret = test_uart_parameter_settings_fpga(stopbit,slowclk,fpga_baudrate);
				if(ret==SUCCESS)
				{
					ret = test_effbst_tdm_writejob_readresult_pnp();
				}

				char status[20];
				if(ret==SUCCESS)
					strcpy(status,"PASSED");
				else
					strcpy(status,"FAILED");

				rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
				rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - StopBit:%d, FPGA-BaudRate:%d, SlowClk:%d ( or 0x%x )-  status: %s\n",stopbit, fpga_baudrate,slowclk,slowclk,status);
				rand_log(LOG_INFO,"=========================================================================\n\n\n" );

				//rand_log(LOG_INFO,"waiting for 5 seconds before starting next test \n");
				//sleep(5);
			}
		}
	}
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST END ] : P1a.7, P1a.11, P1a.6 \n");



	/**  Stop Bit / FPGA Baud Rate / Slow Clock Validation END **/

	/**
        -------------------------------------
        P1a..11     : UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops
        -------------------------------------
        FPGA Baud Rate / Slow Clock Validation START
        Execution Time: 17 * 8 * 5 =  680 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST START ] : P1a.11, P1a.6  \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.11] UART baud rate variation for SLOWEST rate with EngineClk at SLOWEST rate to check for CRI drops \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] [P1a.6] TDM with varied BAUD rate for each ASIC \n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int fpga_baudrate=0; fpga_baudrate<bzm_params.no_of_baud_rates; fpga_baudrate++)
	{
		for(int slowclk=1; slowclk<=16; slowclk = slowclk * 2)
		{
			/**
                fpga_baudrate: possible values are
                    DEC: 0 to 7

                slowclk: possible values are
                    HEX: 0x2, 0x4, 0x8, 0x10
                    DEC: 2, 4, 8, 16
			 **/

			if(((fpga_baudrate==1) ||(fpga_baudrate==0)) && ((slowclk==8) || (slowclk==16)))
			{
				rand_log(LOG_INFO, "Slowclk=%d Not supported with baudrate div=%d. skipping it...\n",slowclk,fpga_baudrate);
				continue;
			}
			if(bzm_params.cfg.env == PRESILICON)
			{

				unsigned long slowclk_hz=bzm_params.refclk/slowclk;
				unsigned long engclk_hz = bzm_params.cfg.fastclk*1000000;
				double clkratio = engclk_hz/slowclk_hz;
				rand_log(LOG_INFO,"CRI:Engine Clk ratio = %.3f\n",clkratio);
				if(clkratio <= 12)
				{
					rand_log(LOG_INFO,"CRI:Engine Clk ratio %.3f not supported. skipping slowclk %d\n",clkratio,slowclk);
					continue;
				}
			}

			rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
			rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - FPGA-BaudRate:%d, SlowClk:%d \n",fpga_baudrate,slowclk);
			rand_log(LOG_INFO,"=========================================================================\n\n\n" );

			ret = test_uart_parameter_settings_fpga(0,slowclk,fpga_baudrate);
			if(ret==SUCCESS)
			{
				ret = test_effbst_tdm_writejob_readresult_pnp();

			}

			char status[20];
			if(ret==SUCCESS)
				strcpy(status,"PASSED");
			else
				strcpy(status,"FAILED");

			rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
			rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - FPGA-BaudRate:%d, SlowClk:%d ( or 0x%x )-  status: %s\n",fpga_baudrate,slowclk,slowclk,status);
			rand_log(LOG_INFO,"=========================================================================\n\n\n" );


			//rand_log(LOG_INFO,"waiting for 5 seconds before starting next test \n");
			//sleep(5);
		}
	}
	rand_log(LOG_INFO,"[ BZM UART FOCUS TEST END ] : P1a.11, P1a.6 \n");

	/**  FPGA Baud Rate / Slow Clock Validation END **/

	//return ret_master;

	/**
       -------------------------------------
       P1a.6       : TDM with varied BAUD rate for each ASIC
       -------------------------------------
       FPGA Baud Rate Validation START
       Max Execution Time: 17 * 8 = 136 Minutes
       -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P1a.6 \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] TDM with varied BAUD rate for each ASIC \n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	sleep(3);

	for(uint32_t fpga_baudrate=0; fpga_baudrate<bzm_params.no_of_baud_rates; fpga_baudrate++)
	{
		/**
            possible values are
                DEC: 0 to 7
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - FPGA-BaudRate:%d \n",fpga_baudrate);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );


		ret = test_uart_parameter_settings_fpga(0,bzm_params.slowclk_div,fpga_baudrate);
		if(ret==SUCCESS)
		{
			ret = test_effbst_tdm_writejob_readresult_pnp();
		}

		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - FPGA-BaudRate:%d -  status: %s\n",fpga_baudrate,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		sleep(5);

		//rand_log(LOG_INFO,"waiting for 5 seconds before starting next test \n");
		//sleep(5);
	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P1a.6 \n");


	/**  FPGA Baud Rate Validation END **/


	/**
        -------------------------------------
        P1a.7       : TDM with different STOP Bit variations in each ASIC
        -------------------------------------
        NANO & FPGA Stop Bit Validation START
        Execution Time: 17 * 2 = 34 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P1a.7 \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] TDM with different STOP Bit variations in each ASIC\n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int stopbit=0; stopbit<=1; stopbit++)
	{
		/**
            possible values are
                DEC: 0 and 1
		 **/

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - StopBit:%d \n",stopbit);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(stopbit,bzm_params.slowclk_div,bzm_params.baudrate);
		if(ret==SUCCESS)
		{
			ret = test_effbst_tdm_writejob_readresult_pnp();
		}

		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - StopBit:%d -  status: %s\n",stopbit,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		//sleep(5);

		//rand_log(LOG_INFO,"waiting for 10 seconds before starting next test \n");
		//sleep(10);
	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P1a.7 \n");


	/** NANO & FPGA Stop Bit Validation END **/

	/**
        -------------------------------------
        P??.?? [ LOCAL_REG_SLOW_CLK_DIV ]
        -------------------------------------
        FPGA Slow Clock Validation START
        Execution Time: 17 * 5 = 85 Minutes
        -------------------------------------
	 **/

	rand_log(LOG_INFO,"\n\n******************************************\n\n");
	rand_log(LOG_INFO,"[ START BZM UART Focus TEST ] : P??.?? [ LOCAL_REG_SLOW_CLK_DIV ] \n");
	rand_log(LOG_INFO,"[ TEST DESCRIPTION ] Slow Clock variations in each ASIC\n");
	rand_log(LOG_INFO,"\n\n******************************************\n\n");

	for(int slowclk=1; slowclk<=16; slowclk = slowclk * 2)
	{
		/**
            possible values are
                HEX: 0x2, 0x4, 0x8, 0x10
                DEC: 2, 4, 8, 16
		 **/
		if(((bzm_params.baudrate==1) ||(bzm_params.baudrate==0)) && ((slowclk==8) || (slowclk==16)))
		{
			rand_log(LOG_INFO, "Slowclk=%d Not supported with baudrate div=%d. skipping it...\n",slowclk,bzm_params.baudrate);
			continue;
		}
		if(bzm_params.cfg.env == PRESILICON)
		{
			unsigned long slowclk_hz=bzm_params.refclk/slowclk;
			unsigned long engclk_hz = bzm_params.cfg.fastclk*1000000;
			double clkratio = engclk_hz/slowclk_hz;
			rand_log(LOG_INFO,"CRI:Engine Clk ratio = .3%f\n",clkratio);
			if(clkratio <= 12)
			{
				rand_log(LOG_INFO,"CRI:Engine Clk ratio .3%f not supported. skipping slowclk %d\n",clkratio,slowclk);
				continue;
			}
		}

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST START - SlowClock:%d ( or 0x%x ) \n",slowclk,slowclk);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );

		ret = test_uart_parameter_settings_fpga(0,slowclk,bzm_params.baudrate);
		if(ret==SUCCESS)
		{
			ret = test_effbst_tdm_writejob_readresult_pnp();
			if(ret!=SUCCESS)
			{
				rand_log(LOG_ERROR,"[INTERMEDIATE] TEST FAILED - SlowClock:%d ( or 0x%x ) at test_effbst_tdm_writejob_readresult_pnp\n",slowclk,slowclk);
			}
		}
		else
		{
			rand_log(LOG_ERROR,"[INTERMEDIATE] TEST FAILED - SlowClock:%d ( or 0x%x ) at test_uart_parameter_settings_NANO\n",slowclk,slowclk);
		}


		char status[20];
		if(ret==SUCCESS)
			strcpy(status,"PASSED");
		else
			strcpy(status,"FAILED");

		rand_log(LOG_INFO,"\n\n\n=======================================================================\n" );
		rand_log(LOG_INFO,"[INTERMEDIATE] TEST END - SlowClock:%d ( or 0x%x ) -  status: %s\n",slowclk,slowclk,status);
		rand_log(LOG_INFO,"=========================================================================\n\n\n" );
		//sleep(5);

		//rand_log(LOG_INFO,"waiting for 5 seconds before starting next test \n");
		//sleep(5);

	}
	rand_log(LOG_INFO,"[ END BZM UART Focus TEST ] : P??.?? [ LOCAL_REG_SLOW_CLK_DIV ] \n");

	/** FPGA Slow Clock Validation END **/

	rand_log(LOG_INFO,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	return ret;
}

int test_tdm_engine_recovery_with_oddtce_on()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t value = 0;
	uint32_t static_data_index=0;

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();
	static_data_index = bzm_params.static_data_index;


	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);



		rand_log(LOG_INFO,"*****Test with odd TCE on******\n");

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;



			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				value = ODDEVEN_2TCE_NORMAL_ON | (1<<4);
				engine_config(b, a, value);
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t rdvalue = 0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &rdvalue));
						rand_log(LOG_INFO, "board_id %d asic_id %d col = %d row = %d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , rdvalue);
						if(rdvalue!=value)
						{
							rand_log(LOG_ERROR, "[ERROR] - Config value not updated. wrvalue=0x%x rdvalue=0x%x\n",value,rdvalue);
							ret=ERR_READVALUE_MISMATCH;
							goto END;
						}
					}
				}
			}
		}


		rand_log(LOG_INFO,"JOB_SUBMIT with Both even and old TCE are on. Expect only odd nonce. Even nonce will not be recieved\n");

		static_data_index = bzm_params.static_data_index;
		bzm_params.exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_NORMAL;
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		uint32_t noncecnt = get_noncelist_for_index(bzm_params.static_data_index);

		for(uint32_t i=0;i<noncecnt;i++)
		{
			if((bzm_params.exp_noncelist[i] & 0x1) == 1) //only odd nonce will be received since even TCE is bad
				bzm_params.exp_noncecnt+=1;
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			write_bch_data(false,false,true,true, b, BROADCAST_ASIC, 0, 0, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

		}
		bzm_params.exp_noncecnt=bzm_params.exp_noncecnt*bzm_params.engine_count;
		bzm_params.job_submit=bzm_params.engine_count;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d instead of %d since only odd nonce will be collected\n",bzm_params.job_submit, bzm_params.exp_noncecnt,noncecnt*bzm_params.engine_count);

		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job Submitted=%d Expected= %d. But bzm_params.collected_noncecnt= %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

		//second stage of code

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_soft_reset(b,BROADCAST_ASIC);
			sleep(1);




			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				// Odd TCE on and even TCE off
				value = EVEN_1TCE_NORMAL_OFF | (1<<4);
				engine_config(b, a, value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t rdvalue = 0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &rdvalue));
						rand_log(LOG_INFO, "board_id %d asic_id %d col = %d row = %d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , rdvalue);
						if(rdvalue!=value)
						{
							rand_log(LOG_ERROR, "[ERROR] - Config value not updated. wrvalue=0x%x rdvalue=0x%x\n",value,rdvalue);
							ret=ERR_READVALUE_MISMATCH;
							goto END;
						}
					}
				}
			}
		}

		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		rand_log(LOG_INFO,"JOB SUBMIT with Enable Odd TCE 1 and keep even TCE 0 off\n");
		bzm_params.static_data_index = static_data_index;
		bzm_params.exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_1TCE_NORMAL;
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			bzm_params.exp_noncecnt+=write_bch_data(false,false,true,true, b, BROADCAST_ASIC, 0, 0, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

		}
		bzm_params.job_submit=bzm_params.engine_count;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout*2);

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job Submitted=%d Expected= %d. But bzm_params.collected_noncecnt= %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

		ret|= verify_noncecollected(false);
		seq_id++;
	}
	END:
	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);
	return ret;
}


int test_tdm_engine_recovery_with_eventce_on()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t value = 0;
	uint32_t static_data_index=0;

	rand_log(LOG_DEBUG,"%s: *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();
	static_data_index = bzm_params.static_data_index;

	if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
		bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);



		rand_log(LOG_INFO,"*****Test with Even TCE on******\n");

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				value = ODDEVEN_2TCE_NORMAL_ON | (1<<4);
				engine_config(b, a, value);
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t rdvalue = 0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &rdvalue));
						rand_log(LOG_INFO, "board_id %d asic_id %d col = %d row = %d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , rdvalue);
						if(rdvalue!=value)
						{
							rand_log(LOG_ERROR, "[ERROR] - Config value not updated. wrvalue=0x%x rdvalue=0x%x\n",value,rdvalue);
							ret=ERR_READVALUE_MISMATCH;
							goto END;
						}
					}
				}
			}
		}

		rand_log(LOG_INFO,"JOB_SUBMIT with Both even and old TCE are on. Expect only even nonce. Odd nonce will not be recieved\n");

		static_data_index = bzm_params.static_data_index;
		bzm_params.exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_NORMAL;
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		uint32_t noncecnt = get_noncelist_for_index(bzm_params.static_data_index);

		for(uint32_t i=0;i<noncecnt;i++)
		{
			if((bzm_params.exp_noncelist[i] & 0x1) == 0) // will get only even nonce since odd tce is bad
				bzm_params.exp_noncecnt+=1;
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			write_bch_data(false,false,true,true, b, BROADCAST_ASIC, 0, 0, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
		}
		bzm_params.exp_noncecnt=bzm_params.exp_noncecnt*bzm_params.engine_count;
		bzm_params.job_submit=bzm_params.engine_count;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d instead of %d since only even nonce will be collected\n",bzm_params.job_submit, bzm_params.exp_noncecnt,noncecnt*bzm_params.engine_count);

		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job Submitted=%d Expected= %d. But bzm_params.collected_noncecnt= %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

		//second stage of code

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_soft_reset(b,BROADCAST_ASIC);
			sleep(1);



			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				// Even TCE on and odd TCE off
				value = ODD_1TCE_NORMAL_OFF | (1<<4);
				engine_config(b, a, value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t rdvalue = 0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &rdvalue));
						rand_log(LOG_INFO, "board_id %d asic_id %d col = %d row = %d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , rdvalue);
						if(rdvalue!=value)
						{
							rand_log(LOG_ERROR, "[ERROR] - Config value not updated. wrvalue=0x%x rdvalue=0x%x\n",value,rdvalue);
							ret=ERR_READVALUE_MISMATCH;
							goto END;
						}
					}
				}
			}
		}

		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		rand_log(LOG_INFO,"JOB SUBMIT with Enable Even TCE 1 and keep odd TCE 0 off\n");
		bzm_params.static_data_index = static_data_index;
		bzm_params.exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_1TCE_NORMAL;

		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			bzm_params.exp_noncecnt+=write_bch_data(false,false,true,true, b, BROADCAST_ASIC, 0, 0, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

		}
		bzm_params.job_submit=bzm_params.engine_count;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		ret=check_all_engine_status(bzm_params.sw_timeout*2);

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job Submitted=%d Expected= %d. But bzm_params.collected_noncecnt= %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

		ret|= verify_noncecollected(false);
		seq_id++;
	}
	END:
	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);
	return ret;
}



/*BIST INTERNAL UNICAST */


/*BIST INTERNAL UNICAST */
int test_bist_internal_pattern_unicast()
{
	int ret = SUCCESS;
	bzm_params.bist_mode = BIST_UNICAST_MODE;
	uint32_t bist_job_count = 1;
	uint32_t eng_cnt = 1;

	uint32_t val = 0x0;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;



			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						// first argument => job_count : 1 to 10
						rand_log(LOG_INFO," bist_job_count = %d\n", bist_job_count);
						ret = bist_internal_pattern(bist_job_count,a,r,r,c,c,eng_cnt);
						if(ret)
							break;
					}
				}
				if(ret) // break from Asic loop if fail
					break;
			}
			if(ret) // break from Board loop if fail
				break;
		}
		if(ret) // break from Regr count loop if fail
			break;
	}

	return ret;
}

/*BIST INTERNAL MULTICAST */

int test_bist_internal_pattern_multicast()
{
	int ret = SUCCESS;
	bzm_params.bist_mode = BIST_MULTICAST_MODE;
	uint32_t bist_job_count = 1;

	uint32_t val = 0x0;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					uint32_t eng_cnt = 0;
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						eng_cnt++;
					}
					if ( eng_cnt ) { //Send job if atleast 1 engine exist in a row
						//job_count : 1 to 10
						ret = bist_internal_pattern(bist_job_count,a,r,r,0,ENGINE_COLUMN_PER_ASIC-1,eng_cnt);
						if(ret)
							break;
					} else {
						continue;
					}

				}
				if(ret) // break from Asic loop if fail
					break;

			}
			if(ret) // break from Board loop if fail
				break;
		}
		if(ret) // break from Regression count loop if fail
			break;
	}

	return ret;
}

/* BIST INTERNAL BROADCAST */
int test_bist_internal_pattern_broadcast()
{
	int ret = SUCCESS;
	bzm_params.bist_mode = BIST_BROADCAST_MODE;
	uint32_t bist_job_count = bzm_params.cfg.jobcnt;


	uint32_t val = 0x0;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				//First arg => job_count : 1 to 10
				ret = bist_internal_pattern(bist_job_count,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);

				if(ret)
					break;

			}
			if(ret) //break for board
				break;
		}
		if(ret) //break for regression loop
			break;
	}
	return ret;
}



/* BIST EXTERNAL UNICAST */

int test_bist_external_pattern_unicast()
{
	int ret = SUCCESS;
	int ret2 = SUCCESS;
	bzm_params.bist_mode = BIST_UNICAST_MODE;

	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	uint32_t val = 0x0;
	uint32_t job_count = 0x1;
	uint32_t eng_cnt = bzm_params.enginecount_per_asic;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				ret2 = bist_external_pattern(job_count,b,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,eng_cnt);
				//ret2 = bist_external_pattern(job_count,b,a,0,0,0,0,eng_cnt);

				get_next_effbst_data_index();
				if(ret2)
					ret = FAILURE;

			}
		}
		if(ret)
			break;

	}


	return ret;
}

/* BIST EXTERNAL MULTICAST */
int test_bist_external_pattern_multicast()
{
	int ret = SUCCESS;
	int ret2 = SUCCESS;
	bzm_params.bist_mode = BIST_MULTICAST_MODE;

	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 for bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	uint32_t val = 0x0;
	uint32_t job_count = 0x1;
	uint32_t eng_cnt = bzm_params.enginecount_per_asic;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				/////
				ret2 = bist_external_pattern(job_count,b,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1, eng_cnt);
				get_next_effbst_data_index();
				if(ret2)
					ret = FAILURE;

			}
		}
		if(ret)
			break;
	}

	return ret;
}

/* BIST EXTERNAL BROADCAST */
int test_bist_external_pattern_broadcast()
{
	int ret = SUCCESS;
	int ret2 = SUCCESS;
	bzm_params.bist_mode = BIST_BROADCAST_MODE;

	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 for bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	uint32_t val = 0x0;
	uint32_t job_count = 0x1;
	uint32_t eng_cnt = bzm_params.enginecount_per_asic;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				ret2 = bist_external_pattern(job_count, b, a, 0, ENGINE_ROW_PER_ASIC-1, 0, ENGINE_COLUMN_PER_ASIC-1, eng_cnt);
				get_next_effbst_data_index();
				if(ret2)
					ret = FAILURE;

			}
		}
		if(ret)
			break;
	}

	return ret;
}



int test_register_read_during_bist()
{
	int ret = SUCCESS;
	bzm_params.bist_mode = BIST_UNICAST_MODE;
	uint32_t bist_job_count = 1;
	uint32_t eng_cnt = 1;
	bzm_params.readreg_bist = false;

	uint32_t val = 0x0;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{

		bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						// first argument => job_count : 1 to 10
						rand_log(LOG_INFO," bist_job_count = %d\n", bist_job_count);

						bzm_params.readreg_bist = true;
						ret = bist_internal_pattern(bist_job_count,a,r,r,c,c,eng_cnt);
						if(ret)
							break;
					}
				}
				if(ret) // break from Asic loop if fail
					break;
			}
			if(ret) // break from Board loop if fail
				break;
		}
		if(ret) // break from Regr count loop if fail
			break;
	}

	return ret;
}



int test_effbst_tdm_autoclockgating_withcanceljob()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t timestampcount=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.verify_nonce_received = true;
	bzm_params.leadingzeros_enabled = true;
	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		bzm_params.expected_nonce_not_found=0;
		bzm_params.expected_nonce_found=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);

					}
				}
			}
		}
		seq_id+=subjobcnt;  // updating seq id for next iteration
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);


		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				loopcnt = (bzm_params.jobprocessingtime_us*2)/sleeptime;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d\n",loopcnt);

			for (uint32_t loop = 0; loop < loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt == bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}
		rand_log(LOG_INFO,"Cancelling all jobs..\n");
		uint8_t cancel_job = 0x2;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			//uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_JOB_CONTROL, 1, &cancel_job);
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						uart_command_writereg(bzm_params.uart_dev, b, a,  (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &cancel_job);
					}
				}
			}

		}
		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/(bzm_params.engine_count*subjobcnt)));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d, expected_nonce_found=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.expected_nonce_found);

		if(bzm_params.collected_noncecnt == bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}
		if(bzm_params.expected_nonce_not_found)
		{
			ret=ERR_NONCE_NOT_FOUND;
			rand_log(LOG_ERROR,"[ERROR] - expected nonce not found\n");
			break;
		}


	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	return ret;
}



int test_effbst_tdm_autoclockgating_withcanceljob_1engine()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t timestampcount=0;


	uint32_t b=0,a=0,r=0,c=0;
#if 0
	char input[50];
	char *endptr;

	printf("\nEnter Asic Row and Column ID  : ");
	fgets(input, sizeof input, stdin);


	a = (uint32_t)strtoul(input, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);
#endif

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.verify_nonce_received = true;
	bzm_params.leadingzeros_enabled = true;
	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		bzm_params.expected_nonce_not_found=0;
		bzm_params.expected_nonce_found=0;
		clear_jobdone_status_counters();

		//	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		//	{
		//	if (bzm_params.board_exist[b] == 0)
		//		continue;

		timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
		bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);

		//	}
		seq_id+=subjobcnt;  // updating seq id for next iteration
		bzm_params.job_submit +=subjobcnt;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);


		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				loopcnt = (bzm_params.jobprocessingtime_us*2)/sleeptime;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d\n",loopcnt);

			for (uint32_t loop = 0; loop < loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			int counter = bzm_params.cfg.idle_time;
			uint32_t sleeptime=5; //5 secs
			while(1)
			{
				sleep(sleeptime);

				if(bzm_params.expected_nonce_not_found >=2)
				{
					engine_register_dump(b,a,r,c);
					goto END;
				}
				if(counter<=0)
					break;
				counter -= sleeptime;
			}

		}

		if (bzm_params.collected_noncecnt == bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}
		rand_log(LOG_INFO,"Cancelling all jobs..\n");
		uint8_t cancel_job = 0x2;
		//for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		//{
		//	if (bzm_params.board_exist[b] == 0)
		//		continue;
		bzm_params.poll_eng_idle=true;

		uart_command_writereg(bzm_params.uart_dev, b, a,  (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &cancel_job);
		ret=check_1engine_status(b,a,r,c,bzm_params.sw_timeout);
		if(ret)
			goto END;

		//}
		sleep(bzm_params.cfg.idle_time*2);

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d, expected_nonce_found=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.expected_nonce_found);

		if(bzm_params.collected_noncecnt == bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}
		if(bzm_params.expected_nonce_not_found)
		{
			ret=ERR_NONCE_NOT_FOUND;
			rand_log(LOG_ERROR,"[ERROR] - expected nonce not found\n");
			break;
		}


	}


	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	return ret;
}




int test_tdm_autoclockgating_withcanceljob_1engine()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint8_t timestampcount=0;

	uint32_t a=0,r=0,c=0;

	char input[50];
	char *endptr;

	printf("\nEnter Asic Row and Column ID  : ");
	fgets(input, sizeof input, stdin);


	a = (uint32_t)strtoul(input, &endptr, 10);
	r = (uint32_t)strtoul(endptr, &endptr, 10);
	c = (uint32_t)strtoul(endptr, NULL, 10);


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.cfg.nonce_count=1;
	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
			bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);

			seq_id++;
			bzm_params.job_submit++;
		}
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{
			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				loopcnt = (bzm_params.jobprocessingtime_us*2)/sleeptime;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d\n",loopcnt);

			for (uint32_t loop = 0; loop < loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt > bzm_params.exp_noncecnt){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if (bzm_params.collected_noncecnt == bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}
		rand_log(LOG_INFO,"Cancelling all jobs..\n");
		uint8_t cancel_job = 0x2;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			bzm_params.poll_eng_idle=true;

			uart_command_writereg(bzm_params.uart_dev, b, a,  (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &cancel_job);
			ret=check_1engine_status(b,a,r,c,bzm_params.sw_timeout);
			if(ret)
				goto END;

		}
		sleep(bzm_params.cfg.idle_time*4);
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d, expected_nonce_found=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.expected_nonce_found);

		if(bzm_params.collected_noncecnt == bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}
		if(bzm_params.expected_nonce_not_found)
		{
			ret=ERR_NONCE_NOT_FOUND;
			rand_log(LOG_ERROR,"[ERROR] - expected nonce not found\n");
			break;
		}


	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_asic_reset_stress()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{

		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		//srand(time(0));
		//index = rand() %100;

		for (int b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
			ret=asic_global_reset(b,false);
			if(ret)
				goto END;

			ret=engine_init(b);
			if(ret)
				goto END;
		}


		initialize_board(1, 0);

		bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
		get_next_effbst_data_index();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
		}

		uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

		if((ret=enable_effbst()))
			goto END;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;
		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;

		disable_tdm();
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_jobdone_status_with_resultvalid()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.rstvld_job_stat_indicator=true;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=writejob(b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=writejob(b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;


		if( bzm_params.job_submit != (bzm_params.rstvld_job_done_sts_cnt + bzm_params.dummy_job_done_stst_cnt) ) //Pass if bzm_params.job_submit == rstvld_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Result valid Job status done is not as expected. EXPECTED_RESULTVALID+JOBDONE_STATUS_CNT : %d but RESULTVALID+JOBDONE_STATUS_CNT : %d\n",bzm_params.job_submit, (bzm_params.rstvld_job_done_sts_cnt+ bzm_params.dummy_job_done_stst_cnt));
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


#if 0
		if( bzm_params.dummy_job_done_stst_cnt ) //Fail if dummy_job_done_sts_cnt present
		{
			rand_log(LOG_ERROR, "[ERROR] - Dummy packet job status present i.e DUMMY_JOB_STATUS_DONE count : %d\n", bzm_params.dummy_job_done_stst_cnt);
			ret = ERR_DUMY_JOB_DONE_STS_CNT_PRESENT;
			break;
		}
#endif

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobdone_status_with_resultvalid()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	bzm_params.rstvld_job_stat_indicator=true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2) {
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		if( ((bzm_params.job_submit)/bzm_params.subjobcnt) != (bzm_params.rstvld_job_done_sts_cnt + bzm_params.dummy_job_done_stst_cnt) ) //Pass if bzm_params.job_submit == rstvld_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Result valid Job status done is not as expected. EXPECTED_RESULTVALID+JOBDONE_STATUS_CNT : %d but RESULTVALID+JOBDONE_STATUS_CNT : %d\n",(bzm_params.job_submit/bzm_params.subjobcnt), (bzm_params.rstvld_job_done_sts_cnt+ bzm_params.dummy_job_done_stst_cnt));
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}

#if 0
		if( bzm_params.dummy_job_done_stst_cnt ) //Fail if dummy_job_done_sts_cnt present
		{
			rand_log(LOG_ERROR, "[ERROR] - Dummy packet job status present i.e DUMMY_JOB_STATUS_DONE count : %d\n", bzm_params.dummy_job_done_stst_cnt);
			ret = ERR_DUMY_JOB_DONE_STS_CNT_PRESENT;
			break;
		}
#endif

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_jobdone_status_without_resultvalid()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=writejob(b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=writejob(b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		if(bzm_params.job_submit != bzm_params.dummy_job_done_stst_cnt ) //Pass if bzm_params.job_submit == dummy_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Dummy job done status count is not as expected. EXPECTED_DUMMY_JOBDONE_STATUS_CNT : %d but DUMMY_JOBDONE_STATUS_CNT : %d\n",(bzm_params.job_submit/bzm_params.subjobcnt), bzm_params.dummy_job_done_stst_cnt);
			ret = ERR_DUMY_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobdone_status_without_resultvalid()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						if(bzm_params.cfg.jobcnt==2) {
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(ret)
			break;

		if( ((bzm_params.job_submit)/bzm_params.subjobcnt) != bzm_params.dummy_job_done_stst_cnt ) //Pass if bzm_params.job_submit == dummy_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Dummy job done status count is not as expected. EXPECTED_DUMMY_JOBDONE_STATUS_CNT : %d but DUMMY_JOBDONE_STATUS_CNT : %d\n",(bzm_params.job_submit/bzm_params.subjobcnt), bzm_params.dummy_job_done_stst_cnt);
			ret = ERR_DUMY_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_tdm_jobdone_status_enable_autoclockgating()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t timestampcount=0;
	uint32_t reruncnt=2;
	uint32_t expected_jobdone_sts_cnt=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		expected_jobdone_sts_cnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);


					}
				}
			}
		}

		seq_id++;
		bzm_params.job_submit = bzm_params.engine_count;

		/* wait for job done status count for re-runcnt times */

		expected_jobdone_sts_cnt = bzm_params.job_submit*reruncnt;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, Expected_JOB_DONE_STATUS_CNT=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt,expected_jobdone_sts_cnt);
		//long double sleeptime=5; /*5 secs */
		uint32_t sleeptime=5; /*5 secs */
		uint32_t loopcnt = (bzm_params.jobprocessingtime*reruncnt)/sleeptime;
		bool usleep_enable=false;

		if(loopcnt==0)
		{
			usleep_enable=true;
			sleeptime = (bzm_params.jobprocessingtime_us*reruncnt);
			loopcnt=1;
		}
		rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			//rand_log(LOG_INFO, "loop = %d\n",loop);
			if (bzm_params.total_job_done_sts_cnt >= expected_jobdone_sts_cnt){
				rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);
				break;

			}
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}
		//fail the test if expected job done sts cnt is not met
		if (bzm_params.total_job_done_sts_cnt < expected_jobdone_sts_cnt)
		{
			rand_log(LOG_ERROR,"[ERROR] - JOB_DONE_STS_CNT mismatch. JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}
		// jobdone should be equal to expected bzm_params.collected_noncecnt* rerunrun, if not fail the test.
		if (bzm_params.collected_noncecnt < bzm_params.exp_noncecnt*reruncnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}

		/* submit next job to disable autoclkgate */

		bzm_params.total_job_done_sts_cnt=0; //clear all the counters
		bzm_params.exp_noncecnt=bzm_params.job_submit=bzm_params.collected_noncecnt=0;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);
					}
				}
			}
		}
		seq_id++;
		bzm_params.job_submit += bzm_params.engine_count;
		expected_jobdone_sts_cnt=bzm_params.job_submit;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

#if 0
		/* wait for tdm result and get the job done sts count */

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.total_job_done_sts_cnt);

		rand_log(LOG_INFO, "\nWait for TDM results.... Expected_jod_done=%d\n",bzm_params.exp_noncecnt);
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);

		if(ret)
		{
			break;
		}
#endif

		/* confirm if engines has turned idle */
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(2*bzm_params.sw_timeout*(bzm_params.job_submit/bzm_params.engine_count));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		/* check for expected nonce count */
		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

		/* compare the job done status count */
		if (bzm_params.total_job_done_sts_cnt >= expected_jobdone_sts_cnt)
		{
			rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);
		}
		else
		{
			rand_log(LOG_ERROR,"[ERROR] - JOB_DONE_STS_CNT mismatch. JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


	}

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_effbst_tdm_jobdone_status_enable_autoclockgating()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t timestampcount=0;
	uint8_t reruncnt=2;
	uint32_t expected_jobdone_sts_cnt=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		expected_jobdone_sts_cnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);

					}
				}
			}
		}
		seq_id+=subjobcnt;  // updating seq id for next iteration
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		/* wait for job done status count for re-runcnt times */

		expected_jobdone_sts_cnt = (bzm_params.job_submit/subjobcnt)*reruncnt;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, Expected_JOB_DONE_STATUS_CNT=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt,expected_jobdone_sts_cnt);

		uint32_t sleeptime=5; /*5 secs */
		uint32_t loopcnt = (bzm_params.jobprocessingtime*reruncnt)/sleeptime;
		bool usleep_enable=false;


		if(loopcnt==0)
		{
			usleep_enable=true;
			sleeptime = (bzm_params.jobprocessingtime_us*reruncnt);
			loopcnt=1;
		}

		rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);


		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if (bzm_params.total_job_done_sts_cnt >= expected_jobdone_sts_cnt){
				rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);
				break;

			}
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}
		//fail the test if expected job done sts cnt is not met
		if (bzm_params.total_job_done_sts_cnt < expected_jobdone_sts_cnt)
		{
			rand_log(LOG_ERROR,"[ERROR] - JOB_DONE_STS_CNT mismatch. JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}
		// jobdone should be equal to expected bzm_params.collected_noncecnt* rerunrun, if not fail the test.
		if (bzm_params.collected_noncecnt < bzm_params.exp_noncecnt*reruncnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}

		/* submit next job to disable autoclkgate */

		bzm_params.total_job_done_sts_cnt=0; //clear all the counters
		bzm_params.exp_noncecnt=bzm_params.job_submit=bzm_params.collected_noncecnt=0;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);


					}
				}
			}
		}
		seq_id+=subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit += bzm_params.engine_count*subjobcnt;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		expected_jobdone_sts_cnt=bzm_params.exp_jobdone_sts_cnt;

#if 0
		/* wait for tdm result and get the job done sts count */

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.total_job_done_sts_cnt);

		rand_log(LOG_INFO, "\nWait for TDM results.... Expected_jod_done=%d\n",bzm_params.exp_noncecnt);
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		//rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);

		if(ret)
		{
			rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt);

			break;
		}
#endif
		/* confirm if engines has turned idle */
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(2*bzm_params.sw_timeout*(bzm_params.job_submit/(bzm_params.engine_count*subjobcnt)));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}

		/* compare the job done status count */
		if (bzm_params.total_job_done_sts_cnt >= expected_jobdone_sts_cnt)
		{
			rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d expected_jobdone_sts_cnt=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt,expected_jobdone_sts_cnt);
		}
		else
		{
			rand_log(LOG_ERROR,"[ERROR] - JOB_DONE_STS_CNT mismatch. JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d total_job_done_sts_cnt: %d expected_jobdone_sts_cnt=%d \n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt,bzm_params.total_job_done_sts_cnt,expected_jobdone_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


int test_tdm_jobdone_status_disable_autoclockgating()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t timestampcount=0;
	uint8_t reruncnt=2;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	/* Disable job done status indicator by setting job_done_status_en 0. initialize_board will update the register*/
	bzm_params.cfg.job_done_status_en=0;
	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);


					}
				}
			}
		}

		seq_id++;
		bzm_params.job_submit = bzm_params.engine_count;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{

			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*reruncnt)/sleeptime;
			bool usleep_enable=false;

			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*reruncnt);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);


			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt >= (bzm_params.exp_noncecnt*reruncnt)){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}
				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if(bzm_params.total_job_done_sts_cnt!=0)
		{
			rand_log(LOG_ERROR, "[ERROR] - Job done status counter should be 0. but it is %d\n",bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}
		else
		{
			rand_log(LOG_INFO, "Job done status counter as expected with value 0\n");
		}


		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,timestampcount);
					}
				}
			}
		}
		seq_id++;
		bzm_params.job_submit += bzm_params.engine_count;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/bzm_params.engine_count));


		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(bzm_params.total_job_done_sts_cnt!=0)
		{
			rand_log(LOG_ERROR, "[ERROR] - Job done status counter should be 0. but it is %d\n",bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}
		else
		{
			rand_log(LOG_INFO, "Job done status counter as expected with value 0\n");
		}

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}


	}

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_effbst_tdm_jobdone_status_disable_autoclockgating()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t timestampcount=0;
	uint8_t reruncnt=2;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	/* Disable job done status indicator by setting job_done_status_en 0. initialize_board will update the register*/
	bzm_params.cfg.job_done_status_en=0;


	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = (1 << 7) |bzm_params.cfg.timestampcount;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);

					}
				}
			}
		}
		seq_id+=subjobcnt;  // updating seq id for next iteration
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;

		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		if(bzm_params.cfg.idle_time==IDLE_TIME_DEFAULT)
		{

			uint32_t sleeptime=5; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime*reruncnt)/sleeptime;
			bool usleep_enable=false;

			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us*reruncnt);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if (bzm_params.collected_noncecnt >= (bzm_params.exp_noncecnt*reruncnt)){
					rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
					break;

				}

				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
			}
		}
		else
		{
			rand_log(LOG_INFO, "Wait for %d secs for engine to re-run job with autoclkgate...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
		}

		if(bzm_params.total_job_done_sts_cnt!=0)
		{
			rand_log(LOG_ERROR, "[ERROR] - Job done status counter should be 0. but it is %d\n",bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}
		else
		{
			rand_log(LOG_INFO, "Job done status counter as expected with value 0\n");
		}


		if (bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;

		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						timestampcount = 0;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,timestampcount);


					}
				}
			}
		}

		seq_id+=subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit += bzm_params.engine_count*subjobcnt;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*(bzm_params.job_submit/(bzm_params.engine_count*subjobcnt)));

		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMIT: %d,  Expected_JOB_DONE: %d, JOB_DONE: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(bzm_params.total_job_done_sts_cnt!=0)
		{
			rand_log(LOG_ERROR, "[ERROR] - Job done status counter should be 0. but it is %d\n",bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}
		else
		{
			rand_log(LOG_INFO, "Job done status counter as expected with value 0\n");
		}

		if(bzm_params.collected_noncecnt <= bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. bzm_params.collected_noncecnt=%d, bzm_params.exp_noncecnt=%d\n",bzm_params.collected_noncecnt,bzm_params.exp_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; //breaking regression loop on failure
		}


	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_tdm_jobdone_status_disable()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_DEBUG,"Disabling Job status indicator\n");
	bzm_params.cfg.job_done_status_en = 0;
	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.total_job_done_sts_cnt) {
			rand_log(LOG_ERROR, "[ERROR] - Job status indicator did not disabled and total_job_done_sts_cnt is not zero i.e current count:%d\n",bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_STS_NOT_DISABLED;
			break;
		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobdone_status_disable()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_DEBUG,"Disabling Job status indicator\n");
	bzm_params.cfg.job_done_status_en = 0;
	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;


		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.total_job_done_sts_cnt) {
			rand_log(LOG_ERROR, "[ERROR] - Job status indicator did not disabled and total_job_done_sts_cnt is not zero i.e current count:%d\n",bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_STS_NOT_DISABLED;
			break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}


	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_jobdone_status_disable_enable_stress()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t job_stat_enbl_dsbl = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			job_stat_enbl_dsbl = rand()%2; // 0 or 1
			if(job_stat_enbl_dsbl)//Enable Job status indicator
			{
				rand_log(LOG_INFO,"Current Job status indicator : Enable\n");
			}
			else  //Disable Job status indicator
			{
				rand_log(LOG_INFO,"Current Job status indicator : Disable\n");
			}
			job_status_indicator_cfg(b,job_stat_enbl_dsbl);
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;
		rand_log(LOG_INFO, "TOTAL_JOB_DONE_STATUS_COUNT: %d\n", bzm_params.total_job_done_sts_cnt);

		if(job_stat_enbl_dsbl) {
			if( ((bzm_params.job_submit)/bzm_params.subjobcnt) != bzm_params.total_job_done_sts_cnt ) //Pass if bzm_params.job_submit == total_job_done_sts_cnt
			{
				rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOB_STATUS_DONE  %d but TOTAL_JOB_STATUS_DONE%d\n",(bzm_params.job_submit/bzm_params.subjobcnt), bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
				break;
			}

		} else {
			if(bzm_params.total_job_done_sts_cnt) {
				rand_log(LOG_ERROR, "[ERROR] - Job status indicator did not disabled and total_job_done_sts_cnt is not zero i.e current count:%d\n",bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_STS_NOT_DISABLED;
				break;
			}
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobdone_status_disable_enable_stress()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t job_stat_enbl_dsbl = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;



	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();



		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			job_stat_enbl_dsbl = rand()%2; // 0 or 1
			if(job_stat_enbl_dsbl) //Enable Job status indicator
			{
				rand_log(LOG_INFO,"Current Job status indicator : Enable\n");
			}
			else  //Disable Job status indicator
			{
				rand_log(LOG_INFO,"Current Job status indicator : Disable\n");
			}
			job_status_indicator_cfg(b,job_stat_enbl_dsbl);

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		if(ret)
			break;
		rand_log(LOG_INFO, "TOTAL_JOB_DONE_STATUS_COUNT: %d\n", bzm_params.total_job_done_sts_cnt);
		if(job_stat_enbl_dsbl) {
			if( ((bzm_params.job_submit)/bzm_params.subjobcnt) != bzm_params.total_job_done_sts_cnt ) //Pass if bzm_params.job_submit == total_job_done_sts_cnt
			{
				rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOB_STATUS_DONE  %d but TOTAL_JOB_STATUS_DONE%d\n",(bzm_params.job_submit/bzm_params.subjobcnt), bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
				break;
			}

		} else {
			if(bzm_params.total_job_done_sts_cnt) {
				rand_log(LOG_ERROR, "[ERROR] - Job status indicator did not disabled and total_job_done_sts_cnt is not zero i.e current count:%d\n",bzm_params.total_job_done_sts_cnt);
				ret = ERR_JOB_STS_NOT_DISABLED;
				break;
			}
		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}


	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_nontdm_jobdone_status_disable_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_DEBUG,"Disabling Job status indicator\n");
	bzm_params.cfg.job_done_status_en = 0;
	initialize_board(1, 1);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true,b,a,c,r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}

					}
				}

			}
		}

		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		bzm_params.poll_eng_idle=true;
		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		rand_log(LOG_INFO, "Total JOBDONE_STATUS_CNT : %d\n",bzm_params.total_job_done_sts_cnt);


		if(bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if bzm_params.job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Jobdone status is not as expected. EXPECTED_JOBDONE_STATUS_CNT : %d but JOBDONE_STATUS_CNT : %d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_effbst_nontdm_jobdone_status_disable_frf1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	rand_log(LOG_DEBUG,"Disabling Job status indicator\n");
	bzm_params.cfg.job_done_status_en = 0;

	initialize_board(1, 1);


	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		bzm_params.poll_eng_idle=true;
		ret=nontdm_readresult_from_allengines_frf1(bzm_params.job_submit, bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		rand_log(LOG_INFO, "Total JOBDONE_STATUS_CNT : %d\n",bzm_params.total_job_done_sts_cnt);

		if(bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if bzm_params.job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Jobdone status is not as expected. EXPECTED_JOBDONE_STATUS_CNT : %d but JOBDONE_STATUS_CNT : %d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_jobdone_status_dropoff_with_disable_engine()
{

	int ret = SUCCESS;

	uint8_t seq_id=0;


	uint32_t disabled_b=0,disabled_a=0,disabled_r=0,disabled_c=0;

	uint32_t exp_jobs_for_disabled_eng = 0;
	uint32_t exp_jobs_per_engine=0;
	bool engine_disabled = false;

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1,0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {

		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		engine_disabled = false;
		if(bzm_params.cfg.boardcount>1)
		{
			disabled_b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			disabled_b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[disabled_b],bzm_params.asic_count);
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		else
		{
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[disabled_b][disabled_a],bzm_params.enginecount_per_asic);
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			randomize(bzm_params.active_col_id[disabled_b][disabled_a][disabled_r],bzm_params.enginecount_per_asic);
			disabled_c =  bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}
		else
		{
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			disabled_c = bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						if((b==disabled_b) && (a==disabled_a) && (r==disabled_r) && (c==disabled_c))
						{
							rand_log(LOG_INFO, "Disabling engine id with b:%d a:%d r:%d c:%d\n", b, a, r, c );
							uint32_t engine_offset = 0x80;
							uint32_t row_offset = (r) << 1;
							uint32_t col_offset = 0; //MSB of Column
							uint32_t value = (1<<c);
							engine_offset = engine_offset | row_offset | col_offset;
							uart_command_writereg(bzm_params.uart_dev, b,a,NOTCH_REG,engine_offset,4,&value);
							engine_disabled = true;
						}
						exp_jobs_per_engine=write_bch_data(false, true, false,true, b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						bzm_params.exp_noncecnt+= exp_jobs_per_engine;
						if(engine_disabled == true) {
							exp_jobs_for_disabled_eng = exp_jobs_per_engine;
							engine_disabled = false;
						}
					}
				}
			}
		}
		seq_id++;
		bzm_params.job_submit = bzm_params.engine_count;

		//bzm_params.job_submit--;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit-1;


		bzm_params.exp_noncecnt = bzm_params.exp_noncecnt - exp_jobs_for_disabled_eng;
		rand_log(LOG_INFO, "JOB_SUBMITTED=%d EXPECTED_NONCE_COUNT = %d\n",bzm_params.job_submit,bzm_params.exp_noncecnt);


		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		if((bzm_params.job_submit==1) && (bzm_params.engine_count==1))
		{
			bzm_params.poll_eng_idle=true;
			ret=check_all_engine_status(bzm_params.sw_timeout);
			if(ret)
				break;

		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;
		}


		if( bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if bzm_params.job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOB_STATUS_DONE  %d but TOTAL_JOB_STATUS_DONE%d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


		rand_log(LOG_INFO, "Initializing total_job_done_sts_cnt = 0 before enabling disabled engine\n");
		bzm_params.total_job_done_sts_cnt = 0;
		rand_log(LOG_INFO, "Enabling engine id with b:%d a:%d r:%d c:%d\n",  disabled_b,disabled_a,disabled_r,disabled_c);
		bzm_params.collected_noncecnt=0;
		uint32_t engine_offset = 0x80;
		uint32_t row_offset = (disabled_r) << 1;
		uint32_t col_offset = 0; //MSB of Column
		uint32_t value = (0<<disabled_c);
		engine_offset = engine_offset | row_offset | col_offset;
		uart_command_writereg(bzm_params.uart_dev, disabled_b,disabled_a,NOTCH_REG,engine_offset,4,&value);

		rand_log(LOG_INFO, "\nWait for b:%d a:%d r:%d c:%d engine fifo to become empty...\n",disabled_b,disabled_a,disabled_r,disabled_c);
		bzm_params.poll_eng_idle = true;
		ret=check_1engine_status(disabled_b,disabled_a,disabled_r,disabled_c,bzm_params.sw_timeout);
		if(ret)
			break;

		rand_log(LOG_INFO,"JOB_DONE after enabling engine = %d\n",bzm_params.collected_noncecnt);
		if(bzm_params.collected_noncecnt == exp_jobs_for_disabled_eng){
			ret = SUCCESS;

		}
		else
		{
			if((exp_jobs_for_disabled_eng>4) && (bzm_params.collected_noncecnt == 4))
			{
				rand_log(LOG_ERROR, "[ERROR-EXPECTED] -EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d. DROPPED_OFF_RESULTS=%d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt,(exp_jobs_for_disabled_eng-bzm_params.collected_noncecnt));
				ret = SUCCESS;

			}
			else
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				break;
			}
		}


		bzm_params.exp_jobdone_sts_cnt=1;
		if( bzm_params.exp_jobdone_sts_cnt == bzm_params.total_job_done_sts_cnt )
			rand_log(LOG_INFO,"Received the expected job done %d\n",bzm_params.exp_jobdone_sts_cnt);
		else
		{
			rand_log(LOG_ERROR,"[ERROR] Job done status count mismatch. Expected=%d Received=%d\n",bzm_params.exp_jobdone_sts_cnt,bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}



	}
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobdone_status_dropoff_with_disable_engine()
{


	int ret = SUCCESS;

	uint8_t seq_id=0;


	uint32_t disabled_b=0,disabled_a=0,disabled_r=0,disabled_c=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t exp_jobs_for_disabled_eng = 0;
	uint32_t exp_jobs_per_engine=0;
	bool engine_disabled = false;


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1,0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {

		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,BROADCAST_ASIC,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		engine_disabled = false;
		if(bzm_params.cfg.boardcount>1)
		{
			disabled_b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			disabled_b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[disabled_b],bzm_params.asic_count);
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		else
		{
			disabled_a=bzm_params.active_asic_id[disabled_b][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[disabled_b][disabled_a],bzm_params.enginecount_per_asic);
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			randomize(bzm_params.active_col_id[disabled_b][disabled_a][disabled_r],bzm_params.enginecount_per_asic);
			disabled_c =  bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}
		else
		{
			disabled_r = bzm_params.active_row_id[disabled_b][disabled_a][0];
			disabled_c = bzm_params.active_col_id[disabled_b][disabled_a][disabled_r][0];
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						if((b==disabled_b) && (a==disabled_a) && (r==disabled_r) && (c==disabled_c))
						{
							rand_log(LOG_INFO, "Disabling engine id with b:%d a:%d r:%d c:%d\n", b, a, r, c );
							uint32_t engine_offset = 0x80;
							uint32_t row_offset = (r) << 1;
							uint32_t col_offset = 0; //MSB of Column
							uint32_t value = (1<<c);
							engine_offset = engine_offset | row_offset | col_offset;
							uart_command_writereg(bzm_params.uart_dev, b,a,NOTCH_REG,engine_offset,4,&value);
							engine_disabled = true;
						}

						exp_jobs_per_engine=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						bzm_params.exp_noncecnt+= exp_jobs_per_engine;
						if(engine_disabled == true) {
							exp_jobs_for_disabled_eng = exp_jobs_per_engine;
							engine_disabled = false;
						}
					}
				}
			}
		}
		seq_id+=subjobcnt;
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;

		//bzm_params.job_submit = bzm_params.job_submit - 1*subjobcnt;//1 engine * subjobcnt

		bzm_params.exp_jobdone_sts_cnt = (bzm_params.job_submit/bzm_params.subjobcnt)-1;

		bzm_params.exp_noncecnt = bzm_params.exp_noncecnt - exp_jobs_for_disabled_eng;
		rand_log(LOG_INFO, "JOB_SUBMITTED=%d EXPECTED_NONCE_COUNT = %d\n",bzm_params.job_submit,bzm_params.exp_noncecnt);


		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		if((bzm_params.job_submit/bzm_params.subjobcnt==1) && (bzm_params.engine_count==1))
		{

			bzm_params.poll_eng_idle=true;
			ret=check_all_engine_status(bzm_params.sw_timeout);
			if(ret)
				break;


		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;
		}


		if( bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if bzm_params.job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOB_STATUS_DONE  %d but TOTAL_JOB_STATUS_DONE%d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


		rand_log(LOG_INFO, "Initializing total_job_done_sts_cnt = 0 before enabling disabled engine\n");
		bzm_params.total_job_done_sts_cnt = 0;
		rand_log(LOG_INFO, "Enabling engine id with b:%d a:%d r:%d c:%d\n",  disabled_b,disabled_a,disabled_r,disabled_c);
		bzm_params.collected_noncecnt=0;
		uint32_t engine_offset = 0x80;
		uint32_t row_offset = (disabled_r) << 1;
		uint32_t col_offset = 0; //MSB of Column
		uint32_t value = (0<<disabled_c);
		engine_offset = engine_offset | row_offset | col_offset;
		uart_command_writereg(bzm_params.uart_dev, disabled_b,disabled_a,NOTCH_REG,engine_offset,4,&value);

		bzm_params.poll_eng_idle = true;
		rand_log(LOG_INFO, "\nWait for b:%d a:%d r:%d c:%d engine fifo to become empty...\n",disabled_b,disabled_a,disabled_r,disabled_c);
		ret=check_1engine_status(disabled_b,disabled_a,disabled_r,disabled_c,bzm_params.sw_timeout);
		if(ret)
			break;

		rand_log(LOG_INFO,"JOB_DONE after enabling engine = %d\n",bzm_params.collected_noncecnt);
		if(bzm_params.collected_noncecnt == exp_jobs_for_disabled_eng){
			ret = SUCCESS;

		}
		else
		{
			if((exp_jobs_for_disabled_eng>8) && (bzm_params.collected_noncecnt == 8))
			{
				rand_log(LOG_ERROR, "[ERROR-EXPECTED] -EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d. DROPPED_OFF_RESULTS=%d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt,(exp_jobs_for_disabled_eng-bzm_params.collected_noncecnt));
				ret = SUCCESS;

			}
			else
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				break;
			}
		}

		bzm_params.exp_jobdone_sts_cnt=1;
		if( bzm_params.exp_jobdone_sts_cnt == bzm_params.total_job_done_sts_cnt )
			rand_log(LOG_INFO,"Received the expected job done %d\n",bzm_params.exp_jobdone_sts_cnt);
		else
		{
			rand_log(LOG_ERROR,"[ERROR] Job done status count mismatch. Expected=%d Received=%d\n",bzm_params.exp_jobdone_sts_cnt,bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_jobdone_status_dropoff_with_fsm_overflow()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t timeout=60;

	time_t start_tt, end_tt, diff_tt;
	uint32_t status=0xAA;
	uint32_t b=0,a=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.cfg.nonce_count=MAX_NONCE;
	bzm_params.cfg.same_job=0;

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	//bzm_params.cfg.regression_count=2; /* fixing the regression count to 2 */

	bzm_params.disable_noncecopy_to_mem=true;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		if(bzm_params.cfg.boardcount>1)
		{
			b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[b],bzm_params.asic_count);
			a=bzm_params.active_asic_id[b][0];
		}
		else
		{
			a=bzm_params.active_asic_id[b][0];
		}

		rand_log(LOG_INFO, "Disable ReadResult in UART TX control in b:%d a:%d\n",b,a);
		uint32_t control = 0xB; //Disable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);

		uint32_t min_noncecount=1;
		// *2 below since b2b. +1 extra if min becomes 4 (eg in 4x2). if 4 we may get jobdone. intent is to drop off jobdone
		//if((bzm_params.enginecount_per_asic*2) < RESULT_FSM_FIFO_DEPTH)
		//	min_noncecount = (RESULT_FSM_FIFO_DEPTH/(bzm_params.enginecount_per_asic*2)) + 1;
		if((bzm_params.cfg.env == PRESILICON) && (bzm_params.cfg.fpga == FPGA_4x2))
			min_noncecount =6;

		for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
		{
			for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
			{
				if(bzm_params.engine_exist[b][a][r][c] == 0)
					continue;
				get_static_data_index_with_totalnoncecount(min_noncecount);
				bzm_params.exp_noncecnt+=write_bch_data(false, true, false, true, b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);
				seq_id++;
				bzm_params.job_submit++;
				get_static_data_index_with_totalnoncecount(min_noncecount);
				bzm_params.exp_noncecnt+=write_bch_data(false, true, false,true, b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);
				seq_id--;  /* subtracting back to use same seq ids for all engines */
				bzm_params.job_submit++;
			}
		}

		seq_id+=2;  /* updating seq id for next iteration */



		uint32_t sleeptime=5; /*5 secs */
		uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
		bool usleep_enable=false;

		rand_log(LOG_INFO, "Sleep for first job to complete...\n");
		if(loopcnt==0)
		{
			usleep_enable=true;
			sleeptime = (bzm_params.jobprocessingtime_us*2);
			loopcnt=1;
		}

		rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}



		rand_log(LOG_INFO,"ResultFSM FIFO check...\n");
		time(&start_tt);

		while(1)
		{
			status=0xAA;
			time(&end_tt);
			diff_tt=difftime(end_tt, start_tt);
			if(diff_tt>=timeout){
				rand_log(LOG_ERROR,"[ERROR] - FSM FifoFull not hit b:%d a:%d\n",b,a);
				ret=ERR_RESULTFSM_OVERFLOW_NOT_HIT;
				goto END;
			}

			while(!uart_command_readreg_tdm_async(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_RESULT_STS_CTL, 4,tdm_readreg_callback,&status));

			if ((status & 0x4) == 0x4)
			{
				rand_log(LOG_INFO, "[ResultFSM FIFO FULL] b:%d a:%d status:0x%x\n", b, a, status);
				break;
			}

		}
		rand_log(LOG_INFO, "Enable back ReadResult in UART TX control\n");
		control = 0xF; //Enable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*2);
		if(ret)
			break;
		if(bzm_params.job_done_sts_enabled)
		{
			if(bzm_params.total_job_done_sts_cnt!=bzm_params.job_submit)
				rand_log(LOG_INFO, "Job done status bits dropped off as expected. total_job_done_sts_cnt=%d\n",bzm_params.total_job_done_sts_cnt);
			else
			{
				rand_log(LOG_ERROR, "[ERROR] - Received all job done without drop which is not expected. total_job_done_sts_cnt=%d\n",bzm_params.total_job_done_sts_cnt);
				ret =ERR_JOB_DONE_STS_CNT_MISMATCH;
			}
		}


	}


	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;


}

int test_effbst_tdm_jobdone_status_dropoff_with_fsm_overflow()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t timeout=60;


	time_t start_tt, end_tt, diff_tt;
	uint32_t status=0xAA;
	uint32_t b=0,a=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.cfg.nonce_count=MAX_NONCE;
	//bzm_params.cfg.same_job=0;

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	//bzm_params.cfg.regression_count=2; /* fixing the regression count to 2 */

	bzm_params.disable_noncecopy_to_mem=true;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		if(bzm_params.cfg.boardcount>1)
		{
			b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[b],bzm_params.asic_count);
			a=bzm_params.active_asic_id[b][0];
		}
		else
		{
			a=bzm_params.active_asic_id[b][0];
		}

		rand_log(LOG_INFO, "Disable ReadResult in UART TX control in b:%d a:%d\n",b,a);
		uint32_t control = 0xB; //Disable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);

		uint32_t min_noncecount=4;
		// *2 below since b2b. +1 extra if min becomes 4 (eg in 4x2). if 4 we may get jobdone. intent is to drop off jobdone
		if((bzm_params.enginecount_per_asic) < RESULT_FSM_FIFO_DEPTH)
			min_noncecount = RESULT_FSM_FIFO_DEPTH/(bzm_params.enginecount_per_asic);

		for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
		{
			for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
			{
				if(bzm_params.engine_exist[b][a][r][c] == 0)
					continue;
				get_effbst_data_index_with_totalnoncecount(min_noncecount);
				bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
				seq_id+=subjobcnt;
				bzm_params.job_submit++;
				get_effbst_data_index_with_totalnoncecount(min_noncecount);
				bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
				seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
				bzm_params.job_submit++;
			}
		}

		seq_id+=2*subjobcnt;  /* updating seq id for next iteration */


		uint32_t sleeptime=5; /*5 secs */
		uint32_t loopcnt = (bzm_params.jobprocessingtime*2)/sleeptime;
		bool usleep_enable=false;

		rand_log(LOG_INFO, "Sleep for first job to complete...\n");
		if(loopcnt==0)
		{
			usleep_enable=true;
			sleeptime = (bzm_params.jobprocessingtime_us*2);
			loopcnt=1;
		}

		rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}

		rand_log(LOG_INFO,"ResultFSM FIFO check...\n");
		time(&start_tt);

		while(1)
		{
			status=0xAA;
			time(&end_tt);
			diff_tt=difftime(end_tt, start_tt);
			if(diff_tt>=timeout){
				rand_log(LOG_ERROR,"[ERROR] - FSM FifoFull not hit b:%d a:%d\n",b,a);
				ret=ERR_RESULTFSM_OVERFLOW_NOT_HIT;
				goto END;
			}

			while(!uart_command_readreg_tdm_async(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_RESULT_STS_CTL, 4,tdm_readreg_callback,&status));

			if ((status & 0x4) == 0x4)
			{
				rand_log(LOG_INFO, "[ResultFSM FIFO FULL] b:%d a:%d status:0x%x\n", b, a, status);
				break;
			}

		}
		rand_log(LOG_INFO, "Enable back ReadResult in UART TX control\n");
		control = 0xF; //Enable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*2);
		if(ret)
			break;
		if(bzm_params.job_done_sts_enabled)
		{
			if(bzm_params.total_job_done_sts_cnt!=bzm_params.job_submit)
				rand_log(LOG_INFO, "Job done status bits dropped off as expected. total_job_done_sts_cnt=%d\n",bzm_params.total_job_done_sts_cnt);
			else
			{
				rand_log(LOG_ERROR, "[ERROR] - Received all job done without drop which is not expected. total_job_done_sts_cnt=%d\n",bzm_params.total_job_done_sts_cnt);
				ret =ERR_JOB_DONE_STS_CNT_MISMATCH;
			}
		}


	}


	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;



}



int test_tdm_pendingjob_status_for_b2b()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t exp_pendingjob_sts_cnt = 0;

	uint32_t noncecnt=0;

	bzm_params.cfg.jobcnt=2;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		exp_pendingjob_sts_cnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						noncecnt=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=noncecnt;
						exp_pendingjob_sts_cnt+=noncecnt;

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d EXPECTED_PENDING_STS_CNT=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt,exp_pendingjob_sts_cnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;
		if(bzm_params.total_pendingjob_sts_cnt!=exp_pendingjob_sts_cnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Pending job status count is not as expected. EXPECTED_PENDINGJOB_STS_CNT: %d. But COLLECTED_PENDINGJOB_STS_CNT: %d\n",exp_pendingjob_sts_cnt, bzm_params.total_pendingjob_sts_cnt);
			ret = ERR_PENDING_JOB_STS_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		else
		{
			rand_log(LOG_INFO, "Received all Pending job status count. EXPECTED_PENDINGJOB_STS_CNT: %d. COLLECTED_PENDINGJOB_STS_CNT: %d\n",exp_pendingjob_sts_cnt, bzm_params.total_pendingjob_sts_cnt);
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_pendingjob_status_for_b2b()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t noncecnt=0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t exp_pendingjob_sts_cnt = 0;
	bzm_params.cfg.jobcnt=2;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		exp_pendingjob_sts_cnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						noncecnt=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=noncecnt;
						exp_pendingjob_sts_cnt+=noncecnt;

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;


		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d EXPECTED_PENDING_STS_CNT=%d\n",bzm_params.job_submit, bzm_params.exp_noncecnt,exp_pendingjob_sts_cnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.total_pendingjob_sts_cnt!=exp_pendingjob_sts_cnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Pending job status count is not as expected. EXPECTED_PENDINGJOB_STS_CNT: %d. But COLLECTED_PENDINGJOB_STS_CNT: %d\n",exp_pendingjob_sts_cnt, bzm_params.total_pendingjob_sts_cnt);
			ret = ERR_PENDING_JOB_STS_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		else
		{
			rand_log(LOG_INFO, "Received all Pending job status count. EXPECTED_PENDINGJOB_STS_CNT: %d. COLLECTED_PENDINGJOB_STS_CNT: %d\n",exp_pendingjob_sts_cnt, bzm_params.total_pendingjob_sts_cnt);
		}

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}


	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_continuous_b2b_jobs()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	uint32_t jobcnt=2;


	bzm_params.cfg.jobcnt=2;
	bzm_params.verify_nonce_received = true;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						if(jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for current job complete...\n");
		if (bzm_params.eng_type!=FAKE_ENGINE){
			while(1)
			{
				if(bzm_params.total_job_done_sts_cnt == bzm_params.engine_count)
				{
					rand_log(LOG_INFO, "All engines have completed current job\n");
					break;
				}
				usleep(1);
			}
		}
		else{
			while (bzm_params.job_submit!= bzm_params.exp_noncecnt)
				usleep(1);
		}
		jobcnt=1;

	}
	//making poll_eng_idle true to wait for all engines to turn idle to complete pending job at the end of iteration
	bzm_params.poll_eng_idle=true;
	ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
	ret|= verify_noncecollected(true);

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_continuous_b2b_jobs()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t jobcnt=2;

	bzm_params.cfg.jobcnt=2;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit=bzm_params.collected_noncecnt=bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						if(jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(jobcnt==2)
			bzm_params.job_submit *=2;


		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for current job complete...\n");
		while(1)
		{
			if(bzm_params.total_job_done_sts_cnt == bzm_params.engine_count)
			{
				rand_log(LOG_INFO, "All engines have completed current job\n");
				break;
			}
			usleep(1);
		}

		jobcnt=1;

	}

	//making poll_eng_idle true to wait for all engines to turn idle to complete pending job at the end of iteration
	bzm_params.poll_eng_idle=true;
	ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
	ret|= verify_noncecollected(true);

	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_thermal_resolution_variation()
{
	//uint8_t ret = SUCCESS;
	uint8_t ret = FAILURE;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		bzm_params.cfg.idle_time = 10;


	//initialize_voltage_thermal_thershold_and_resolution();

	initialize_board(1, 0);

	if((ret=enable_effbst()))
		goto END;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		for(uint8_t resolution=0; resolution<=2; resolution++)
		{

			if(resolution == 2)
				bzm_params.cfg.therm_resolution_bit = 8;
			else if(resolution == 1)
				bzm_params.cfg.therm_resolution_bit = 10;
			else if(resolution == 0)
				bzm_params.cfg.therm_resolution_bit = 12;

			rand_log(LOG_INFO,"Intermediate Test - THERMAL RESOLUTION:%d \n",bzm_params.cfg.therm_resolution_bit);
			initialize_voltage_thermal_thershold_and_resolution();
			//enable_thermal_sensor(bzm_params.cfg.ts_clk_div, bzm_params.therm_resolution, CONVERSION_MODE, bzm_params.therm_threshold);

			sleep(bzm_params.cfg.idle_time);
			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				uint32_t control=0;
				/*********** disable sensor **************/
				rand_log(LOG_INFO, "Disabling TS to update cfg0 for resolution=%d..\n",bzm_params.cfg.therm_resolution_bit);
				control = (bzm_params.therm_threshold << 1) ;
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &control);

				/********** update sensor configuration with mode and resolution***************/
				control = bzm_params.therm_resolution;
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_TEMPSENSOR_CFG, 4, &control);

				rand_log(LOG_INFO, "Enabling TS back after cfg0 update\n");
				/*********** configure thermal sensor threshold and enable sensor **************/
				control = (bzm_params.therm_threshold << 1) | 0x1;
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &control);
			}
			rand_log(LOG_INFO,"System entering idle for %d s...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
			rand_log(LOG_INFO,"Exiting sleep\n");
			rand_log(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					if(bzm_params.cfg.therm_resolution_bit == 8)
					{
						if(((bzm_params.tune_code_data[b][a]<<28)>>28)==0)
							ret = SUCCESS;
						else
							goto END;
					}
					else if(bzm_params.cfg.therm_resolution_bit == 10)
					{

						if(((bzm_params.tune_code_data[b][a]<<30)>>30)==0)
							ret = SUCCESS;
						else
							goto END;
					}
					else if(bzm_params.cfg.therm_resolution_bit == 12)
					{

						ret = SUCCESS;
					}
				}
			}
			rand_log(LOG_INFO," Intermediate Test End -  THERMAL RESOLUTION:%d\n",bzm_params.cfg.therm_resolution_bit);
			//sleep(5);

		}
	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

int test_voltage_resolution_variation()
{
	uint8_t ret = FAILURE;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		bzm_params.cfg.idle_time = 10;

	initialize_board(1, 0);




	initialize_voltage_thermal_thershold_and_resolution();

	if((ret=enable_effbst()))
		goto END;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		for(uint8_t resolution=0; resolution<=3; resolution++)
		{

			if(resolution == 3)
				bzm_params.cfg.vol_resolution_bit = 8;
			else if(resolution == 2)
				bzm_params.cfg.vol_resolution_bit = 10;
			else if(resolution == 1)
				bzm_params.cfg.vol_resolution_bit = 12;
			else if(resolution == 0)
				bzm_params.cfg.vol_resolution_bit = 14;


			initialize_voltage_thermal_thershold_and_resolution();
			//enable_voltage_sensor(bzm_params.cfg.vs_clk_div, bzm_params.vol_resolution, CONVERSION_MODE, bzm_params.vol_threshold, 0);


			rand_log(LOG_INFO,"Intermediate Test Start - VOLTAGE RESOLUTION:%d \n",bzm_params.cfg.vol_resolution_bit);
			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				uint32_t control=0;
				/*********** disable sensor **************/
				rand_log(LOG_INFO, "Disabling VS to update cfg0 for resolution=%d..\n",bzm_params.cfg.vol_resolution_bit);
				control = (bzm_params.therm_threshold << 1) ;
				control =  (bzm_params.vol_threshold<<16) ;// | (vol_shutdown<<15);
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &control);

				/********** update sensor configuration with mode and resolution***************/
				control = bzm_params.vol_resolution;
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_VSENSOR_CFG, 4, &control);

				rand_log(LOG_INFO, "Enabling VS back after cfg0 update\n");
				/********** enable voltage sensor : set bit 0******/
				control =  (bzm_params.vol_threshold<<16) | 0x1;// | (vol_shutdown<<15);
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &control);

			}

			applog(LOG_INFO,"System entering idle for %d s...\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());

			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					if(bzm_params.cfg.vol_resolution_bit == 8)
					{
						if(((bzm_params.ch0_volt_code_data[b][a]<<26)>>26)==0)
							ret = SUCCESS;
						else
							goto END;
					}
					else if(bzm_params.cfg.vol_resolution_bit == 10)
					{

						if(((bzm_params.ch0_volt_code_data[b][a]<<28)>>28)==0)
							ret = SUCCESS;
						else
							goto END;
					}
					else if(bzm_params.cfg.vol_resolution_bit == 12)
					{

						if(((bzm_params.ch0_volt_code_data[b][a]<<30)>>30)==0)
							ret = SUCCESS;
						else
							goto END;
					}
					else if(bzm_params.cfg.vol_resolution_bit == 14)
					{

						ret = SUCCESS;
					}
				}
			}

			rand_log(LOG_INFO,"Intermediate Test -  VOLTAGE RESOLUTION:%d \n",bzm_params.cfg.vol_resolution_bit);


		}
	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}



int test_voltage_threshold_exceeds_inbetween_jobprocessing()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t backdoor_vol_val = 0;
	//uint32_t backdoor_temp_val = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	initialize_voltage_thermal_thershold_and_resolution();
	enable_voltage_sensor(bzm_params.cfg.ts_clk_div, bzm_params.vol_resolution, CONVERSION_MODE, bzm_params.vol_threshold, 0);
	backdoor_vol_val = bzm_params.vol_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		bzm_params.cfg.idle_time = 5;

		wait_for_backdoor_prog_normal_temp_volt();
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		asic_id = rand() % bzm_params.cfg.asiccount;
		backdoor_vol_val = bzm_params.vol_threshold + 0x40;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program voltage backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_vol_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		}
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
				{
					rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, a, bzm_params.vol_shutdown_status[b][asic_id]);
					ret = FAILURE;
					goto END;
				}
				else
					rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, a, bzm_params.vol_shutdown_status[b][asic_id]);

			}
		}
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;

	}

	END:

	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

int test_voltage_threshold_exceeds_at_beginning()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t backdoor_vol_val = 0;
	//uint32_t backdoor_temp_val = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	enable_voltage_sensor(bzm_params.cfg.vs_clk_div, bzm_params.vol_resolution, CONVERSION_MODE, bzm_params.vol_threshold, 0);
	initialize_voltage_thermal_thershold_and_resolution();
	backdoor_vol_val = bzm_params.vol_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		bzm_params.cfg.idle_time = 5;

		asic_id = rand()%bzm_params.cfg.asiccount;
		wait_for_backdoor_prog_normal_temp_volt();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			backdoor_vol_val= bzm_params.vol_threshold + 0x40;
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program voltage backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_vol_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		}
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
				{
					rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, a, bzm_params.vol_shutdown_status[b][asic_id]);
					ret = FAILURE;
					goto END;
				}
				else
					rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, a, bzm_params.vol_shutdown_status[b][asic_id]);
			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;


		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;


	}
	END:
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

int test_thermal_threshold_exceeds_inbetween_jobprocessing()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	//uint32_t backdoor_vol_val = 0;
	uint32_t backdoor_temp_val = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	initialize_voltage_thermal_thershold_and_resolution();
	enable_thermal_sensor(bzm_params.cfg.ts_clk_div, bzm_params.therm_resolution, CONVERSION_MODE, bzm_params.therm_threshold);
	backdoor_temp_val = bzm_params.therm_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	uint32_t timeout=bzm_params.sw_timeout;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;


		clear_jobdone_status_counters();

		bzm_params.cfg.idle_time = 5;
		wait_for_backdoor_prog_normal_temp_volt();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		asic_id = rand() % bzm_params.cfg.asiccount;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			backdoor_temp_val=bzm_params.therm_threshold + 0x20;
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program thermal backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_temp_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		}
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				if(a!=asic_id)
					continue;
				if(bzm_params.therm_trip_status [b][asic_id] != 1)
				{
					rand_log(LOG_ERROR,"[ERROR] trip not triggered for b:%d a:%d \n value in bzm_params.therm_trip_status: %d\n",b, a, bzm_params.therm_trip_status [b][asic_id] );
					ret = FAILURE;
					goto END;
				}
				else
					rand_log(LOG_INFO,"Thermal trip Triggered for b:%d, a:%d value in bzm_params.therm_trip_status: %d\n", b, a, bzm_params.therm_trip_status [b][asic_id]);
			}
		}

		bzm_params.sw_timeout = timeout * 2;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;

	}

	END:
	/**********setting temp(75) and vol(.395) back to normal **************/
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	return ret;

}

int test_thermal_threshold_exceeds_at_beginning()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	//uint32_t backdoor_vol_val = 0;
	uint32_t backdoor_temp_val = 0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	initialize_voltage_thermal_thershold_and_resolution();
	enable_thermal_sensor(bzm_params.cfg.ts_clk_div, bzm_params.therm_resolution, CONVERSION_MODE, bzm_params.therm_threshold);
	backdoor_temp_val = bzm_params.therm_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;



	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();


		bzm_params.cfg.idle_time = 5;
		asic_id = rand()%bzm_params.cfg.asiccount;
		wait_for_backdoor_prog_normal_temp_volt();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			backdoor_temp_val= bzm_params.therm_threshold + 0x20;
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program thermal backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_temp_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				if(a!=asic_id)
					continue;
				if(bzm_params.therm_trip_status [b][asic_id] != 1)
				{
					rand_log(LOG_ERROR,"[ERROR] trip not triggered for b:%d a:%d \n value in bzm_params.therm_trip_status: %d\n",b, a, bzm_params.therm_trip_status [b][asic_id] );
					ret = FAILURE;
					goto END;
				}
				else
					rand_log(LOG_INFO,"Thermal trip Triggered for b:%d, a:%d value in bzm_params.therm_trip_status: %d\n", b, a, bzm_params.therm_trip_status [b][asic_id]);
			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.sw_timeout = timeout * 2;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
		asic_id = rand ()% bzm_params.cfg.asiccount;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			backdoor_temp_val = bzm_params.normal_temp;
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program thermal backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_temp_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		}
	}
	END:
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}

int test_voltage_shutdown_disabled()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t backdoor_vol_val = 0;
	//uint32_t backdoor_temp_val = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	enable_voltage_sensor(bzm_params.cfg.vs_clk_div, bzm_params.vol_resolution, CONVERSION_MODE, bzm_params.vol_threshold, 1);
	backdoor_vol_val = bzm_params.vol_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		bzm_params.cfg.idle_time = 5;
		asic_id = rand ()% bzm_params.cfg.asiccount;
		wait_for_backdoor_prog_normal_temp_volt();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			backdoor_vol_val = bzm_params.vol_threshold + 0x40;
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program voltage backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_vol_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
		}
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				if(bzm_params.vol_shutdown_status[b][asic_id] == 1)
				{
					rand_log(LOG_ERROR,"[ERROR] voltage shutdown triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, a, bzm_params.vol_shutdown_status[b][asic_id]);
					ret = FAILURE;
					goto END;
				}
				else
					rand_log(LOG_INFO,"Thermal voltage shutdown disabled for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, a, bzm_params.vol_shutdown_status[b][asic_id]);
			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;
		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;

	}
	END:
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_tdm_dutycycle_variation()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;




	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);



	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		uint32_t dc_variation=rand()%5;
		if(dc_variation==0)
		{
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 50_50\n");
			bzm_params.cfg.dll0_dutycycle_hcnt=50;
			bzm_params.cfg.dll1_dutycycle_hcnt=50;
		}
		else if(dc_variation==1)
		{
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 75_25\n");
			bzm_params.cfg.dll0_dutycycle_hcnt=75;
			bzm_params.cfg.dll1_dutycycle_hcnt=75;
		}
		if(dc_variation==2)
		{
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 60_40\n");
			bzm_params.cfg.dll0_dutycycle_hcnt=60;
			bzm_params.cfg.dll1_dutycycle_hcnt=60;
		}
		if(dc_variation==3)
		{
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 55_45\n");
			bzm_params.cfg.dll0_dutycycle_hcnt=55;
			bzm_params.cfg.dll1_dutycycle_hcnt=55;
		}
		if(dc_variation==4)
		{
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 25_75\n");
			bzm_params.cfg.dll0_dutycycle_hcnt=25;
			bzm_params.cfg.dll1_dutycycle_hcnt=25;
		}

		bzm_params.dll_enable_0=true;
		bzm_params.dll_enable_1=true;
		bzm_params.nde_dll_0 = bzm_params.dutycycle_cfg_0[dc_variation][0];
		bzm_params.nde_clk_0 = bzm_params.dutycycle_cfg_0[dc_variation][1];
		bzm_params.npi_clk_0 = bzm_params.dutycycle_cfg_0[dc_variation][2];

		bzm_params.nde_dll_1 = bzm_params.dutycycle_cfg_1[dc_variation][0];
		bzm_params.nde_clk_1 = bzm_params.dutycycle_cfg_1[dc_variation][1];
		bzm_params.npi_clk_1 = bzm_params.dutycycle_cfg_1[dc_variation][2];

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				rand_log(LOG_INFO, "Disabling the DLL before setting new duty cycle..\n");
				ret=dll0_config(b,a,false);
				if(ret)
					goto END;
				ret=dll1_config(b,a,false);
				if(ret)
					goto END;
				rand_log(LOG_INFO, "Enabling the DLL with new duty cycle..\n");
				ret=dll0_config(b,a,true);
				if(ret)
					goto END;
				ret=dll1_config(b,a,true);
				if(ret)
					goto END;
			}
		}
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_dutycycle_variation()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();



	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		uint32_t dc_variation=rand()%5;
		if(dc_variation==0)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 50_50\n");
		else if(dc_variation==1)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 75_25\n");
		if(dc_variation==2)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 60_40\n");
		if(dc_variation==3)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 55_45\n");
		if(dc_variation==4)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 25_75\n");

		bzm_params.dll_enable_0=true;
		bzm_params.dll_enable_1=true;
		bzm_params.nde_dll_0 = bzm_params.dutycycle_cfg_0[dc_variation][0];
		bzm_params.nde_clk_0 = bzm_params.dutycycle_cfg_0[dc_variation][1];
		bzm_params.npi_clk_0 = bzm_params.dutycycle_cfg_0[dc_variation][2];

		bzm_params.nde_dll_1 = bzm_params.dutycycle_cfg_1[dc_variation][0];
		bzm_params.nde_clk_1 = bzm_params.dutycycle_cfg_1[dc_variation][1];
		bzm_params.npi_clk_1 = bzm_params.dutycycle_cfg_1[dc_variation][2];

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				rand_log(LOG_INFO, "Disabling the DLL before setting new duty cycle..\n");
				ret=dll0_config(b,a,false);
				if(ret)
					goto END;
				ret=dll1_config(b,a,false);
				if(ret)
					goto END;
				rand_log(LOG_INFO, "Enabling the DLL with new duty cycle..\n");
				ret=dll0_config(b,a,true);
				if(ret)
					goto END;
				ret=dll1_config(b,a,true);
				if(ret)
					goto END;
			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}


	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_tdm_internalfastclk_dcdll_enabled()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t fastclk[7] = {400,500,600,700,800,900,1000};


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "Enable PLL and Enable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=true;
	bzm_params.dll_enable_1=true;
	bzm_params.cfg.pll_bypass=0;

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for(uint32_t i=0;i<7;i++)
		{
			bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
			clear_jobdone_status_counters();

			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				ret=set_fast_clk(b, BROADCAST_ASIC, fastclk[i],bzm_params.cfg.post1_divider);

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
						{
							if(bzm_params.engine_exist[b][a][r][c] == 0)
								continue;

							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

							if(bzm_params.cfg.jobcnt==2)
							{
								seq_id++;
								bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
								seq_id--;
							}
						}
					}
				}
			}
			seq_id+=bzm_params.cfg.jobcnt;

			bzm_params.job_submit = bzm_params.engine_count;
			if(bzm_params.cfg.jobcnt==2)
				bzm_params.job_submit *=2;

			rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

			rand_log(LOG_INFO, "\nWait for TDM results....\n");
			ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
			rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

			if(ret)
				goto END;

			ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

			if(ret)
				goto END;

			if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				goto END; /*breaking regression loop on failure */
			}
			ret|= verify_noncecollected(true);
			if(ret)
				goto END;


		}
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_internalfastclk_dcdll_enabled()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t fastclk[7] = {400,500,600,700,800,900,1000};

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "Enable PLL and Enable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=true;
	bzm_params.dll_enable_1=true;
	bzm_params.cfg.pll_bypass=0;

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for(uint32_t i=0;i<7;i++)
		{
			bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
			clear_jobdone_status_counters();

			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				ret=set_fast_clk(b, BROADCAST_ASIC, fastclk[i],bzm_params.cfg.post1_divider);
				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
						{
							if(bzm_params.engine_exist[b][a][r][c] == 0)
								continue;

							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

							if(bzm_params.cfg.jobcnt==2)
							{
								seq_id+=subjobcnt;
								bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
								seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
							}
						}
					}
				}
			}
			seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

			bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
			if(bzm_params.cfg.jobcnt==2)
				bzm_params.job_submit *=2;
			bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

			rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

			rand_log(LOG_INFO, "\nWait for TDM results....\n");
			ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
			rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

			if(ret)
				goto END;


			ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

			if(ret)
				goto END;

			if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				goto END; /*breaking regression loop on failure */
			}

			ret |= verify_noncecollected(true);
			if(ret)
				goto END;

		}
	}


	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


int test_tdm_internalfastclk_dcdll_disabled()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t fastclk[7] = {400,500,600,700,800,900,1000};


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "Enable PLL and disable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=false;
	bzm_params.dll_enable_1=false;
	bzm_params.cfg.pll_bypass=0;
	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		for(uint32_t i=0;i<7;i++)

		{
			bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
			clear_jobdone_status_counters();

			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				ret=set_fast_clk(b, BROADCAST_ASIC, fastclk[i],bzm_params.cfg.post1_divider);

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
						{
							if(bzm_params.engine_exist[b][a][r][c] == 0)
								continue;

							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

							if(bzm_params.cfg.jobcnt==2)
							{
								seq_id++;
								bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
								seq_id--;
							}
						}
					}
				}
			}
			seq_id+=bzm_params.cfg.jobcnt;

			bzm_params.job_submit = bzm_params.engine_count;
			if(bzm_params.cfg.jobcnt==2)
				bzm_params.job_submit *=2;

			rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

			rand_log(LOG_INFO, "\nWait for TDM results....\n");
			ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
			rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

			if(ret)
				goto END;

			ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

			if(ret)
				goto END;

			if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				goto END; /*breaking regression loop on failure */
			}
			ret|= verify_noncecollected(true);
			if(ret)
				goto END;


		}
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_internalfastclk_dcdll_disabled()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t fastclk[7] = {400,500,600,700,800,900,1000};


	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "Enable PLL and disable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=false;
	bzm_params.dll_enable_1=false;

	bzm_params.cfg.pll_bypass=0;
	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);



		for(uint32_t i=0;i<7;i++)

		{
			bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
			clear_jobdone_status_counters();

			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				ret=set_fast_clk(b, BROADCAST_ASIC, fastclk[i],bzm_params.cfg.post1_divider);
				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
						{
							if(bzm_params.engine_exist[b][a][r][c] == 0)
								continue;

							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

							if(bzm_params.cfg.jobcnt==2)
							{
								seq_id+=subjobcnt;
								bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
								seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
							}
						}
					}
				}
			}
			seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

			bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
			if(bzm_params.cfg.jobcnt==2)
				bzm_params.job_submit *=2;
			bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

			rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

			rand_log(LOG_INFO, "\nWait for TDM results....\n");
			ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
			rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

			if(ret)
				goto END;


			ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

			if(ret)
				goto END;

			if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
			{
				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
				ret = ERR_NONCE_CNT_MISMATCH;
				goto END; /*breaking regression loop on failure */
			}

			ret |= verify_noncecollected(true);
			if(ret)
				goto END;

		}
	}


	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_tdm_externalfastclk_dcdll_enable()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "External PLL and Enable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=true;
	bzm_params.dll_enable_1=true;
	bzm_params.cfg.pll_bypass=1;
	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			goto END;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			goto END;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			goto END; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			goto END;


	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_externalfastclk_dcdll_disable()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "External PLL and Disable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=false;
	bzm_params.dll_enable_1=false;
	bzm_params.cfg.pll_bypass=1;
	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);



		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			goto END;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			goto END;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			goto END; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			goto END;

	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_internalfastclk_dcdll_freeze()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "Enable PLL and Enable Duty Cycle DLL with DllFreeze...\n");
	bzm_params.dll_enable_0=true;
	bzm_params.dll_enable_1=true;
	bzm_params.cfg.pll_bypass=0;
	bzm_params.dllfreeze_0=1;
	bzm_params.dllfreeze_1=1;

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);



		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			goto END;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			goto END;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			goto END; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			goto END;

	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_tdm_internalfastclk_dcdll_pi_byp_disabled()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "Enable PLL and Enable Duty Cycle DLL with pibypb=0...\n");
	bzm_params.dll_enable_0=true;
	bzm_params.dll_enable_1=true;
	bzm_params.cfg.pll_bypass=0;
	bzm_params.pibypb_0=0;
	bzm_params.pibypb_1=0;

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);



		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			goto END;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			goto END;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			goto END; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			goto END;

	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_bist_ext_unicast_thermal_threshold_exceeds_at_beginning()
{
	int ret = SUCCESS;
	int ret2 = SUCCESS;
	uint8_t asic_id = 0;
	//uint32_t backdoor_vol_val = 0;
	uint32_t backdoor_temp_val = 0;
	uint32_t value = 1;
	//uint32_t control = 0;
	bzm_params.bist_mode = BIST_UNICAST_MODE;

	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	uint32_t val = 0x0;
	uint32_t job_count = 0x1;
	uint32_t eng_cnt = bzm_params.enginecount_per_asic;
	uint32_t timeout = bzm_params.sw_timeout;

	initialize_board(1, 1);
	enable_thermal_sensor(bzm_params.cfg.ts_clk_div, bzm_params.therm_resolution, CONVERSION_MODE, bzm_params.therm_threshold);
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_bzm2_dts_vs_callback(bzm_params.uart_dev, tdm_bzm2_dts_vs_callback,NULL);
	sleep(2);
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.cfg.idle_time = 5;
		asic_id = rand()%bzm_params.cfg.asiccount;
		wait_for_backdoor_prog_normal_temp_volt();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			backdoor_temp_val= bzm_params.therm_threshold + 0x20;
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program thermal backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_temp_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
			sleep(5);
		}
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				if(a!=asic_id)
					continue;
				if(bzm_params.therm_trip_status [b][asic_id] != 1)
				{
					rand_log(LOG_ERROR,"[ERROR] trip not triggered for b:%d a:%d \n value in bzm_params.therm_trip_status: %d\n",b, a, bzm_params.therm_trip_status [b][asic_id] );
					ret = FAILURE;
					goto END;
				}
				else
					rand_log(LOG_INFO,"Thermal trip Triggered for b:%d, a:%d value in bzm_params.therm_trip_status: %d\n", b, a, bzm_params.therm_trip_status [b][asic_id]);
			}
		}
		bzm_params.sw_timeout = timeout*2;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				ret2 = bist_external_pattern(job_count,b,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,eng_cnt);
				get_next_effbst_data_index();
				if(ret2)
					ret = FAILURE;
                                if(bzm_params.tdm_enabled)
                                        while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TRIP_STATUS, 4, &value));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_TRIP_STATUS, 4, &value);
				rand_log(LOG_INFO, "1. board:%d asic:%d LOCAL_REG_THERMAL_TRIP_STATUS:0x%x\n", b, a, value);

			}
		}
		if(ret)
			break;

	}
	/********* setting temp vol to normal *************/
	END:
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}


int test_tdm_switch_bw_dll_enabled_and_disable()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	rand_log(LOG_INFO, "External PLL and Enable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=true;
	bzm_params.dll_enable_1=true;
	bzm_params.cfg.pll_bypass=1;
	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.dll_enable_0=false;
		bzm_params.dll_enable_1=false;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				ret=dll0_config(b,a, bzm_params.dll_enable_0);
				if(ret)
					break;

				ret=dll1_config(b,a, bzm_params.dll_enable_1);
				if(ret)
					break;
			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.cfg.timestampcount = 128;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		sleep(10);
		bzm_params.dll_enable_0=true;
		bzm_params.dll_enable_1=true;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				ret=dll0_config(b,a, bzm_params.dll_enable_0);
				if(ret)
					break;

				ret=dll1_config(b,a, bzm_params.dll_enable_1);
				if(ret)
					break;
			}
		}
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			goto END;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			goto END;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce count is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_EXPECTED_JOBDONE_MISMATCH;
			goto END; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			goto END;

	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_bist_pattern_with_tce_disable()
{
	int ret = SUCCESS;
	uint32_t bist_job_count = 1;
	uint32_t val = 0;
	uint32_t tcelist[MAX_EFFBST_SUBJOBS]={0,1,2,3};
	uint8_t tce_gated_cnt;

	//initialize_board(1, 1);
	bzm_params.bist_tce_disable= 1;
	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 for bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		tce_gated_cnt = rand()%4; //no. of TCEs to disable
		randomize(tcelist,MAX_EFFBST_SUBJOBS); //Shuffling the TCE number list

		for(uint32_t t=0;t<MAX_EFFBST_SUBJOBS;t++)
			bzm_params.bist_tce_clkgated[t]=0;

		val=(1<<EFFBST_ENABLE_BITPOS) |(1<<4);

		for(uint32_t i=0;i<tce_gated_cnt;i++)
		{
			if(tcelist[i] == 0)
			{
				rand_log(LOG_INFO,"Testing JOBS with TCE 0 off\n");
				val|= 1<<0;
				bzm_params.bist_tce_clkgated[0] = 1;
			}
			else if(tcelist[i] == 1)
			{
				rand_log(LOG_INFO,"Testing JOBS with TCE 1 off\n");
				val|= 1<<1;
				bzm_params.bist_tce_clkgated[1] = 1;
			}
			else if(tcelist[i] == 2)
			{
				rand_log(LOG_INFO,"Testing JOBS with TCE 2 off\n");
				val|=1<<5;
				bzm_params.bist_tce_clkgated[2] = 1;
			}
			else if(tcelist[i] == 3)
			{
				rand_log(LOG_INFO,"Testing JOBS with TCE 3 off\n");
				val|=1<<6;
				bzm_params.bist_tce_clkgated[3] = 1;
			}
		}


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;


			uint32_t bist_type = rand() % 2;
			if(bzm_params.eng_type == FAKE_ENGINE)
			{
				bist_type=1;
				bzm_params.fake_engine_exp_nonce=EXP_NONCE_FAKE_ENG_NORMAL_2;
				//bzm_params.fake_engine_exp_nonce=EXP_NONCE_FAKE_ENG_NORMAL;
			}

			uint32_t mode_type = (rand() % 3 )+1;
			rand_log(LOG_INFO, "BIST_TYPE : %d , Mode %d\n", bist_type, mode_type);


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				uart_command_writereg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_ENG_CLK_GATE, 4, &val);
				uint32_t value=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, UART_BIST_ACCESS,BIST_ENG_CLK_GATE , 4, &value));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS,BIST_ENG_CLK_GATE , 4, &value);
				rand_log(LOG_INFO,"BIST_ENG_CLK_GATE : 0x%x\n",val);

				if (bist_type == 0)
				{
					rand_log(LOG_INFO, "TESTING WITH INTERNAL PATTERN...\n");
					bist_job_count = 1; //fixing to 1 for latest RTL since BIST pattern 2//(rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

					bzm_params.bist_mode = mode_type; //1:UNICAST  , 2:MULTICAST , 3:BROADCAST
					ret = bist_internal_pattern(bist_job_count,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);

				}
				else //BIST EXTERNAL PATTERN
				{
					rand_log(LOG_INFO, "TESTING WITH EXTERNAL PATTERN...\n");
					bist_job_count = 1;
					bzm_params.bist_mode = mode_type; //1:UNICAST  , 2:MULTICAST , 3:BROADCAST

					ret = bist_external_pattern(bist_job_count,b,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);
					get_next_effbst_data_index();
				}
				uint32_t bisten = 0;
				uart_command_writereg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_ENABLE_REG, 4, &bisten);
				asic_soft_reset(b,a);
				sleep(1);
				if(ret) // break from Asic loop if fail
					break;
			}
			if(ret) // break from Board loop if fail
				break;
		}
		if(ret) // break from Regr count loop if fail
			break;


	}

	return ret;

}

int test_update_extrn_bist_when_intrb_bist_enabled()
{
	int ret = SUCCESS;
	uint32_t bist_job_count = 1;

	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 for bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	bzm_params.update_extrn_bist = true;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			uint32_t mode_type = (rand() % 3 )+1;
			rand_log(LOG_INFO, "Mode %d\n", mode_type);


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				uint32_t val = 0x0;
				uart_command_writereg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);


				bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

				bzm_params.bist_mode = mode_type; //1:UNICAST  , 2:MULTICAST , 3:BROADCAST
				ret = bist_internal_pattern(bist_job_count,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);

				if(ret)
					break;
			}
			if(ret) // break from Board loop if fail
				break;
		}
		if(ret) // break from Regr count loop if fail
			break;
	}
	return ret;
}

int test_bist_func_with_ext_bypass_clk_mode()
{
	int ret = SUCCESS;
	uint32_t bist_job_count = 1;

	rand_log(LOG_INFO, "Enable PLL and disable Duty Cycle DLL...\n");
	bzm_params.dll_enable_0=false;
	bzm_params.dll_enable_1=false;
	bzm_params.cfg.pll_bypass=0;
	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		rand_log(LOG_INFO,"Issuing Hard Reset to board %d\n",b);
		ret=asic_global_reset(b,false);
		if(ret)
			goto END;

		ret=engine_init(b);
		if(ret)
			goto END;
	}


	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 for bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			uint32_t bist_type = (rand() % 2 );

			uint32_t mode_type = (rand() % 3 )+1;
			rand_log(LOG_INFO, "BIST_TYPE : %d , Mode %d\n", bist_type, mode_type);


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				if ( bist_type == 0 ) // BIST INTERNAL PATTERN
				{
					bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count

					bzm_params.bist_mode = mode_type; //1:UNICAST  , 2:MULTICAST , 3:BROADCAST
					ret = bist_internal_pattern(bist_job_count,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);

					//BIST EXTERNAL PATTERN
				} else if ( bist_type == 1 ) {
					bist_job_count = 1;
					bzm_params.bist_mode = mode_type; //1:UNICAST  , 2:MULTICAST , 3:BROADCAST
					ret = bist_external_pattern(bist_job_count,b,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);
					get_next_effbst_data_index();
				}

				if(ret) // break from Asic loop if fail

					break;
			}
			if(ret) // break from Board loop if fail
				break;
		}
		if(ret) // break from Regr count loop if fail
			break;
	}
	END:
	return ret;
}


int test_nontdm_enable_disable_jobdone_status_frf0_backpressurefifo()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t nonce_cnt=0;
	uint32_t job_submit_per_asic[BOARD_PER_DEVICE][ASIC_PER_BOARD];

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	if(bzm_params.enginecount_per_asic>RESULT_FSM_FIFO_DEPTH)
		bzm_params.cfg.nonce_count=1;
	else
		bzm_params.cfg.nonce_count=(RESULT_FSM_FIFO_DEPTH/(bzm_params.enginecount_per_asic*2))-1;

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Enable jobstatus\n");
			job_status_indicator_cfg(b,1);

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				job_submit_per_asic[b][a]=0;

				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						nonce_cnt=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.job_submit+=1;
						seq_id++;
						nonce_cnt=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.job_submit+=1;
						seq_id--;
						job_submit_per_asic[b][a]+=2;

						if((bzm_params.exp_noncecnt_per_asic[b][a]+(bzm_params.cfg.nonce_count*2)) >= (RESULT_FSM_FIFO_DEPTH-job_submit_per_asic[b][a]))
							break;

					}
					if((bzm_params.exp_noncecnt_per_asic[b][a]+(bzm_params.cfg.nonce_count*2)) >= (RESULT_FSM_FIFO_DEPTH-job_submit_per_asic[b][a]))
						break;


				}

			}
		}

		seq_id+=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/2;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		uint32_t sleeptime=5; /*5 secs */
		uint32_t loopcnt = (bzm_params.jobprocessingtime)/sleeptime;
		bool usleep_enable=false;

		rand_log(LOG_INFO, "Sleep for first job to complete...\n");
		if(loopcnt==0)
		{
			usleep_enable=true;
			sleeptime = (bzm_params.jobprocessingtime_us);
			loopcnt=1;
		}

		rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}

		rand_log(LOG_INFO, "Disable jobstatus\n");

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			job_status_indicator_cfg(b,0);
		}
		rand_log(LOG_INFO, "Sleep for second job to complete...\n");
		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}
		bzm_params.poll_eng_idle=true;
		ret=nontdm_readresult_from_resultfsm_frf0_wo_fifofull(bzm_params.job_submit, bzm_params.exp_noncecnt,&bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*2);
		if(ret)
			break;

		rand_log(LOG_INFO, "TOTAL_JOB_DONE_STATUS_COUNT: %d, EXPECTED_JOBDONE_STATUS :%d\n", bzm_params.total_job_done_sts_cnt,bzm_params.exp_jobdone_sts_cnt);
		if( bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOB_STATUS_DONE  %d but TOTAL_JOB_STATUS_DONE%d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_EXPECTED_JOBDONE_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}


int test_tdm_enable_disable_jobdone_status_backpressurefifo()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t b = 0;
	uint32_t nonce_cnt=0;
	uint32_t job_submit_per_asic[BOARD_PER_DEVICE][ASIC_PER_BOARD];

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	if(bzm_params.enginecount_per_asic>RESULT_FSM_FIFO_DEPTH)
		bzm_params.cfg.nonce_count=1;
	else
		bzm_params.cfg.nonce_count=(RESULT_FSM_FIFO_DEPTH/(bzm_params.enginecount_per_asic*2))-1;


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Enable jobstatus\n");
			job_status_indicator_cfg(b,1);

			rand_log(LOG_INFO, "Disable back ReadResult in UART TX control\n");
			uint32_t control = 0xB; //Disable ReadResult
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				job_submit_per_asic[b][a]=0;

				bzm_params.exp_noncecnt_per_asic[b][a]=0;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++) {
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						nonce_cnt=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.job_submit+=1;
						seq_id++;
						nonce_cnt=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt_per_asic[b][a] += nonce_cnt;
						bzm_params.exp_noncecnt+=nonce_cnt;
						bzm_params.job_submit+=1;
						seq_id--;
						job_submit_per_asic[b][a]+=2;

						if((bzm_params.exp_noncecnt_per_asic[b][a]+(bzm_params.cfg.nonce_count*2)) >= (RESULT_FSM_FIFO_DEPTH-job_submit_per_asic[b][a]))
							break;

					}
					if((bzm_params.exp_noncecnt_per_asic[b][a]+(bzm_params.cfg.nonce_count*2)) >= (RESULT_FSM_FIFO_DEPTH-job_submit_per_asic[b][a]))
						break;



				}

			}
		}

		seq_id+=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/2;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		uint32_t sleeptime=5; /*5 secs */
		uint32_t loopcnt = (bzm_params.jobprocessingtime)/sleeptime;
		bool usleep_enable=false;

		rand_log(LOG_INFO, "Sleep for first job to complete...\n");
		if(loopcnt==0)
		{
			usleep_enable=true;
			sleeptime = (bzm_params.jobprocessingtime_us);
			loopcnt=1;
		}

		rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}

		rand_log(LOG_INFO, "Disable jobstatus\n");
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
			if(bzm_params.board_exist[b] == 0)
				continue;

			job_status_indicator_cfg(b,0);
		}
		rand_log(LOG_INFO, "Sleep for second job to complete...\n");

		for (uint32_t loop = 0; loop <= loopcnt; loop++)
		{
			if(usleep_enable)
				usleep(sleeptime);
			else
				sleep(sleeptime);
		}


		rand_log(LOG_INFO, "Enable back ReadResult in UART TX control\n");
		uint32_t control = 0xF; //Enable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);
#if 0
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;
#endif
		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*2);

		if(ret)
			break;

		rand_log(LOG_INFO, "TOTAL_JOB_DONE_STATUS_COUNT: %d, EXPECTED_JOBDONE_STATUS :%d\n", bzm_params.total_job_done_sts_cnt,bzm_params.exp_jobdone_sts_cnt);
		if( bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOBDONE_STATUS  %d but TOTAL_JOB_STATUS_DONE%d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_EXPECTED_JOBDONE_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_result_fifobackpressure_with_dummyresult()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t control=0;
	uint32_t b = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;


			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

					}
				}
			}
		}
		seq_id++;

		bzm_params.job_submit = bzm_params.engine_count;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.check_noncecnt_only=true;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_EXPECTED_JOBDONE_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		rand_log(LOG_INFO, "Disable back ReadResult in UART TX control\n");
		control = 0xB; //Enable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);


		bzm_params.poll_eng_idle = true;
		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		rand_log(LOG_INFO, "Enable back ReadResult in UART TX control\n");
		control = 0xF; //Enable ReadResult
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);
		bzm_params.check_noncecnt_only=false;

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);


		rand_log(LOG_INFO, "TOTAL_JOB_DONE_STATUS_COUNT: %d, EXPECTED_JOBDONE_STATUS :%d\n", bzm_params.total_job_done_sts_cnt,bzm_params.exp_jobdone_sts_cnt);
		if( bzm_params.exp_jobdone_sts_cnt != bzm_params.total_job_done_sts_cnt ) //Pass if job_submit == total_job_done_sts_cnt
		{
			rand_log(LOG_ERROR, "[ERROR] - Total Job status done is not as expected. EXPECTED_JOBDONE_STATUS  %d but TOTAL_JOB_STATUS_DONE%d\n",bzm_params.exp_jobdone_sts_cnt, bzm_params.total_job_done_sts_cnt);
			ret = ERR_JOB_DONE_STS_CNT_MISMATCH;
			break;
		}



		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_direct_mode_temp_sensor_dout_read()
{


	int ret =  SUCCESS;
	uint8_t enable_sensor = 1;
	uint32_t control = 0;
	uint32_t status = 0;
	//uint8_t resolution = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	//wait_for_backdoor_prog_normal_temp_volt();
	bzm_params.cfg.therm_resolution_bit=8;
	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		bzm_params.cfg.idle_time = 2;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			sleep(bzm_params.cfg.idle_time);

			/*********** disable sensor **************/
			rand_log(LOG_INFO, "Disabling TS to update cfg0..\n");
			control = (bzm_params.therm_threshold << 1) ;
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &control);
			sleep(2);
			/********** update sensor configuration with mode and resolution***************/
			//control = bzm_params.therm_resolution | THERMAL_MODE_CFG_R0_D;
			control = THERMAL_MODE_CFG_R0_D;
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_TEMPSENSOR_CFG, 4, &control);
			sleep(2);
			rand_log(LOG_INFO, "Enabling TS back after cfg0 update\n");
			/*********** configure thermal sensor threshold and enable sensor **************/
			control = (bzm_params.therm_threshold << 1) | enable_sensor;
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &control);

			sleep(bzm_params.cfg.idle_time);

			/*********** Read thermal sensor status ********************/
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TSENSOR_DIRECT_MODE_DATA, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TSENSOR_DIRECT_MODE_DATA, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TSENSOR_DIRECT_MODE_DATA=0x%x\n",b,a,status);
				if (status!=THERMAL_MODE_CFG_R0_D)
				{
					rand_log(LOG_ERROR, "[ERROR]- Directm mode dout_data : %d is not equal as THERMAL_MODE_CFG_R0_D : %d\n",status, THERMAL_MODE_CFG_R0_D);
					ret = FAILURE;
					goto END;
				}

			}
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

int test_direct_mode_vol_sensor_dout_read()
{

	int ret =  SUCCESS;
	uint8_t enable_sensor = 1;
	uint32_t control = 0;
	uint32_t status = 0;
	//uint8_t resolution = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	//wait_for_backdoor_prog_normal_temp_volt();
	bzm_params.cfg.vol_resolution_bit=10;
	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		bzm_params.cfg.idle_time = 2;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			sleep(bzm_params.cfg.idle_time);

			rand_log(LOG_INFO, "Disabling VS to update cfg0 for resolution=%d..\n",bzm_params.cfg.vol_resolution_bit);
			control =  (bzm_params.vol_threshold<<16) ;// | (vol_shutdown<<15);
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &control);
			sleep(2);
			/********** update sensor configuration with mode and resolution***************/
			control = VOLTAGE_MODE_CFG_R0_D;
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_VSENSOR_CFG, 4, &control);
			sleep(2);
			rand_log(LOG_INFO, "Enabling VS back after cfg0 update\n");
			/********** enable voltage sensor : set bit 0******/
			control =  (bzm_params.vol_threshold<<16) | enable_sensor;// | (vol_shutdown<<15);
			uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &control);

			sleep(bzm_params.cfg.idle_time);

			/*********** Read thermal sensor status ********************/
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TSENSOR_DIRECT_MODE_DATA, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TSENSOR_DIRECT_MODE_DATA, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TSENSOR_DIRECT_MODE_DATA=0x%x\n",b,a,status);
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VSENSOR_DIRECT_MODE_DATA, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VSENSOR_DIRECT_MODE_DATA, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VSENSOR_DIRECT_MODE_DATA=0x%x\n",b,a,status);

				if (status!=VOLTAGE_MODE_CFG_R0_D)
				{
					rand_log(LOG_ERROR, "[ERROR]- Directm mode dout_data : %d is not equal as VOLTAGE_MODE_CFG_R0_D : %d\n",status, VOLTAGE_MODE_CFG_R0_D);
					ret = FAILURE;
					goto END;
				}

			}

		}
	}

END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}


int test_bist_unique_pattern_per_job()
{
	int ret = SUCCESS;

	uint32_t b=0,a=0,r=0,c=0;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		if(bzm_params.cfg.boardcount>1)
		{
			b = rand()%bzm_params.cfg.boardcount;
		}
		else
		{
			b=0;
		}
		/* shuffle the asic/row/col ids stored in the array and pick the first one */
		if(bzm_params.asic_count>1)
		{

			randomize(bzm_params.active_asic_id[b],bzm_params.asic_count);
			a=bzm_params.active_asic_id[b][0];
		}
		else
		{
			a=bzm_params.active_asic_id[b][0];
		}
		if(bzm_params.enginecount_per_asic>1)
		{
			randomize(bzm_params.active_row_id[b][a],bzm_params.enginecount_per_asic);
			r = bzm_params.active_row_id[b][a][0];
			randomize(bzm_params.active_col_id[b][a][r],bzm_params.enginecount_per_asic);
			c =  bzm_params.active_col_id[b][a][r][0];
		}
		else
		{
			r = bzm_params.active_row_id[b][a][0];
			c = bzm_params.active_col_id[b][a][r][0];
		}


		uint32_t mode_type = (rand() % 3 )+1;
		rand_log(LOG_INFO, "Mode %d\n", mode_type);


		for ( uint32_t bist_job_count = 1; bist_job_count < BIST_JB_CNT_MAX; bist_job_count++) {
			bzm_params.bist_mode = mode_type; //1:UNICAST  , 2:MULTICAST , 3:BROADCAST
			//bzm_params.bist_mode = BIST_UNICAST_MODE;
			ret = bist_internal_pattern(bist_job_count,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);
			engine_register_dump(b,a,r,c);
			if(ret)
				break;
		}

		if(ret) // break regression looop
			break;
	}


	return ret;
}


int test_effbst_tdm_dll_tuning_without_dll_bypass()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.dll_enable_0=true;
		bzm_params.dll_enable_1=true;
		bzm_params.cfg.pll_bypass = true;
		uint32_t dc_variation=rand()%5;
		if(dc_variation==0)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 50_50\n");
		else if(dc_variation==1)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 75_25\n");
		if(dc_variation==2)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 60_40\n");
		if(dc_variation==3)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 55_45\n");
		if(dc_variation==4)
			rand_log(LOG_INFO, "Setting DUTYCYCLE (H_L) - 25_75\n");


		bzm_params.nde_dll_0 = bzm_params.dutycycle_cfg_0[dc_variation][0];
		bzm_params.nde_clk_0 = bzm_params.dutycycle_cfg_0[dc_variation][1];
		bzm_params.npi_clk_0 = bzm_params.dutycycle_cfg_0[dc_variation][2];

		bzm_params.nde_dll_1 = bzm_params.dutycycle_cfg_1[dc_variation][0];
		bzm_params.nde_clk_1 = bzm_params.dutycycle_cfg_1[dc_variation][1];
		bzm_params.npi_clk_1 = bzm_params.dutycycle_cfg_1[dc_variation][2];

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				ret=dll0_config(b,a,true);
				if(ret)
					goto END;

				ret=dll1_config(b,a,true);
				if(ret)
					goto END;
			}


		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}


END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_bist_internal_pattern_engine_disable()
{
	int ret = SUCCESS;

	uint32_t bist_job_count;
	uint32_t disabled_r=0,disabled_c=0;
	uint32_t row_offset=0;
	uint32_t col_offset = 0; //MSB of Column
	uint32_t engine_offset = 0;
	uint32_t value=0,wrvalue, org_value;

	value=0;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &value);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bist_job_count = (rand() % BIST_JB_CNT_MAX)+1; //randomize bist job count
		uint32_t mode_type = (rand() % 3 )+1;
		rand_log(LOG_INFO, "BIST Mode %d\n", mode_type);


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.bist_engine_disable = true;
				if(bzm_params.enginecount_per_asic>1)
				{
					randomize(bzm_params.active_row_id[b][a],bzm_params.enginecount_per_asic);
					disabled_r = bzm_params.active_row_id[b][a][0];
					randomize(bzm_params.active_col_id[b][a][disabled_r],bzm_params.enginecount_per_asic);
					disabled_c =  bzm_params.active_col_id[b][a][disabled_r][0];
				}
				else
				{
					disabled_r = bzm_params.active_row_id[b][a][0];
					disabled_c = bzm_params.active_col_id[b][a][disabled_r][0];
				}

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{

					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;


						if((r==disabled_r) && (c==disabled_c))
						{
							rand_log(LOG_INFO, "Disabling engine id with b:%d a:%d r:%d c:%d\n", b, a, r, c );

							bzm_params.bist_disabled_engine[r][c] = 1;

							row_offset = (r) << 1;
							col_offset = 0; //MSB of Column
							engine_offset = (0xD8) | row_offset | col_offset;
							value=0;
							uart_command_readreg(bzm_params.uart_dev, b,a,UART_BIST_ACCESS,engine_offset,4,&value);
							rand_log(LOG_INFO,"Before write - read val at offset 0x%x is 0x%x\n",engine_offset, value);
							wrvalue = value| (1 << c);
							org_value = value;
							uart_command_writereg(bzm_params.uart_dev, b,a,UART_BIST_ACCESS,engine_offset,4,&wrvalue);
							value=0;
							uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, engine_offset, 4, &value);
							rand_log(LOG_INFO,"After write - read val at offset 0x%x is 0x%x\n",engine_offset, value);
						}
					}
				}

				//First arg => job_count : 1 to 10
				bzm_params.bist_mode = mode_type;
				ret = bist_internal_pattern(bist_job_count,a,0,ENGINE_ROW_PER_ASIC-1,0,ENGINE_COLUMN_PER_ASIC-1,bzm_params.enginecount_per_asic);

				if(ret)
					break;

				rand_log(LOG_INFO,"Issuing Engine soft reset to b:%d a:%d to clear fifo of disabled engine\n",b,a);
				asic_soft_reset(b,a);

				uart_command_writereg(bzm_params.uart_dev, b,a,UART_BIST_ACCESS,engine_offset,4,&org_value);
				value=0;
				uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, engine_offset, 4, &value);
				rand_log(LOG_INFO,"Reverting back to org value - read val at offset 0x%x is 0x%x\n",engine_offset, value);



			}
			if(ret) //break for board
				break;
		}
		if(ret) //break for regression loop
			break;
	}
	return ret;
}


/* BIST EXTERNAL BROADCAST */
int test_bist_external_pattern_engine_disable()
{
	int ret = SUCCESS;
	int ret2 = SUCCESS;
	bzm_params.bist_mode = BIST_BROADCAST_MODE;

	uint32_t row_offset=0;
	uint32_t col_offset = 0; //MSB of Column
	uint32_t engine_offset = 0;
	uint32_t value=0,wrvalue, org_value;

	uint32_t disabled_r=0,disabled_c=0;

	bzm_params.cfg.nonce_count = 1; /* fixing nonce count to 1 for bist test */
	//bzm_params.static_data_index = bzm_params.cfg.bch_data_index;
	//get_next_static_data_index();
	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	uint32_t val = 0x0;
	uint32_t job_count = 0x1;
	uint32_t eng_cnt = bzm_params.enginecount_per_asic;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			uint32_t mode_type = (rand() % 3 )+1;
			rand_log(LOG_INFO, "BIST Mode %d\n", mode_type);

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				bzm_params.bist_engine_disable = true;

				if(bzm_params.enginecount_per_asic>1)
				{
					randomize(bzm_params.active_row_id[b][a],bzm_params.enginecount_per_asic);
					disabled_r = bzm_params.active_row_id[b][a][0];
					randomize(bzm_params.active_col_id[b][a][disabled_r],bzm_params.enginecount_per_asic);
					disabled_c =  bzm_params.active_col_id[b][a][disabled_r][0];
				}
				else
				{
					disabled_r = bzm_params.active_row_id[b][a][0];
					disabled_c = bzm_params.active_col_id[b][a][disabled_r][0];
				}

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						if((r==disabled_r) && (c==disabled_c))
						{
							bzm_params.bist_disabled_engine[r][c] = 1;

							row_offset = (r) << 1;
							col_offset = 0; //MSB of Column
							engine_offset = (0xD8) | row_offset | col_offset;
							value=0;
							uart_command_readreg(bzm_params.uart_dev, b,a,UART_BIST_ACCESS,engine_offset,4,&value);
							rand_log(LOG_INFO,"Before write - read val at offset 0x%x is 0x%x\n",engine_offset, value);
							wrvalue = value| (1 << c);
							org_value = value;
							uart_command_writereg(bzm_params.uart_dev, b,a,UART_BIST_ACCESS,engine_offset,4,&wrvalue);
							value=0;
							uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, engine_offset, 4, &value);
							rand_log(LOG_INFO,"After write - read val at offset 0x%x is 0x%x\n",engine_offset, value);
						}
					}
				}
				bzm_params.bist_mode = mode_type;
				ret2 = bist_external_pattern(job_count, b, a, 0, ENGINE_ROW_PER_ASIC-1, 0, ENGINE_COLUMN_PER_ASIC-1, eng_cnt);
				get_next_effbst_data_index();
				if(ret2)
					ret = FAILURE;
				rand_log(LOG_INFO,"Issuing Engine soft reset to b:%d a:%d to clear fifo of disabled engine\n",b,a);
				asic_soft_reset(b,a);

				uart_command_writereg(bzm_params.uart_dev, b,a,UART_BIST_ACCESS,engine_offset,4,&org_value);
				value=0;
				uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, engine_offset, 4, &value);
				rand_log(LOG_INFO,"Reverting back to org value - read val at offset 0x%x is 0x%x\n",engine_offset, value);
			}
		}
		if(ret)
			break;
	}

	return ret;
}


int test_thermal_threshold_counter_update_and_reset()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;
	uint8_t trip_read_counter = 0;

	uint32_t status;
	uint8_t asic_id = 0;
	uint32_t temp_val = 0;
	uint32_t threshold_value = 0, ts_thrs_cnt;
	uint32_t tunecode_reg_org_val=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	//wait_for_backdoor_prog_normal_temp_volt();

	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);


						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;

		trip_read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			thermal_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming TS threshold count = %d\n",trip_read_counter);
			status = status & 0xFF00FFFF;
			ts_thrs_cnt = (trip_read_counter << 16) | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &ts_thrs_cnt);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);



			temp_val= bzm_params.normal_temp - 0x20;	// lowering down thershold

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,status);
			//status = status & (~(((1<<12)-1)<<1)); //masking off bit12-1
			tunecode_reg_org_val=status;
			status = status & 0xFFFFE001;
			threshold_value = status | (temp_val << 1);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &threshold_value);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d After setting threshold=0x%x, LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,temp_val, status);


			thermal_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>24) & 0xFF)>=trip_read_counter)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);

				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for TS readcount update. Expected=%d Readcounter= %d\n",b,asic_id,trip_read_counter, ((status>>24) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}

			rand_log(LOG_INFO,"b:%d a:%d TS ReadCount = %d\n",b,asic_id,((status>>24) & 0xFF));


			if(bzm_params.therm_trip_status [b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] trip not triggered for b:%d a:%d \n value in bzm_params.therm_trip_status: %d\n",b, asic_id, bzm_params.therm_trip_status [b][asic_id] );
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO,"Thermal trip Triggered for b:%d, a:%d value in bzm_params.therm_trip_status: %d\n", b, asic_id, bzm_params.therm_trip_status [b][asic_id]);

		}


		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming TS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.therm_threshold, tunecode_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &tunecode_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}
int test_effbst_thermal_threshold_counter_update_and_reset()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;
	uint8_t trip_read_counter = 0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t status;
	uint8_t asic_id = 0;
	uint32_t temp_val = 0;
	uint32_t threshold_value = 0, ts_thrs_cnt;
	uint32_t tunecode_reg_org_val=0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.sw_timeout = timeout * 2;


		asic_id = rand()%bzm_params.cfg.asiccount;
		trip_read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			thermal_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming TS threshold count = %d\n",trip_read_counter);
			status = status & 0xFF00FFFF;
			ts_thrs_cnt = (trip_read_counter << 16) | status;
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &ts_thrs_cnt);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			temp_val= bzm_params.normal_temp - 0x20;	// lowering down thershold

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,status);
			//status = status & (~(((1<<12)-1)<<1)); //masking off bit12-1
			tunecode_reg_org_val=status;
			status = status & 0xFFFFE001;
			threshold_value = status | (temp_val << 1);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &threshold_value);

			thermal_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>24) & 0xFF)>=trip_read_counter)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}

				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for TS readcount update. Expected=%d Readcounter= %d\n",b,asic_id,trip_read_counter, ((status>>24) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d TS ReadCount = %d\n",b,asic_id,((status>>24) & 0xFF));


			if(bzm_params.therm_trip_status [b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] trip not triggered for b:%d a:%d \n value in bzm_params.therm_trip_status: %d\n",b, asic_id, bzm_params.therm_trip_status [b][asic_id] );
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO,"Thermal trip Triggered for b:%d, a:%d value in bzm_params.therm_trip_status: %d\n", b, asic_id, bzm_params.therm_trip_status [b][asic_id]);

		}


		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming TS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.therm_threshold, tunecode_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &tunecode_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}



int test_voltage_threshold_counter_update_and_reset_ch0()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t asic_id = 0;
	uint32_t vol_value = 0;
	uint32_t status = 0;
	uint32_t threshold_value = 0;
	uint8_t read_counter = 0;
	uint32_t vs_ctrl_reg_org_val=0, vs_thrs_cnt;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}
	uint32_t timeout = bzm_params.sw_timeout;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH0 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_value= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xFFFF8001;
			threshold_value = status | (vol_value << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
                if(bzm_params.tdm_enabled)
                        while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
                else
                        uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
                rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
                if (((status>>8) & 0xFF) >=read_counter)
                {
                        ret = SUCCESS;
                        rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x VS CH0 threshold counter value got updated\n",b,asic_id, status);
                        break;
                }
                sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH0 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}

			rand_log(LOG_INFO,"b:%d a:%d CH0 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));


			if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);

		}

		ret=cancel_all_jobs_and_check_engine_idle();
		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}



int test_effbst_voltage_threshold_counter_update_and_reset_ch0()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t vol_value = 0;
	uint32_t status = 0;
	uint8_t read_counter = 0;
	uint32_t threshold_value = 0;
	uint32_t vs_ctrl_reg_org_val=0, vs_thrs_cnt;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	uint32_t timeout = bzm_params.sw_timeout;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b,asic_id,false);
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH0 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_value= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xFFFF8001;
			threshold_value = status | (vol_value << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);
			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)>=read_counter)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x VS CH0 threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH0 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH0 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

			if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);

		}

		ret=cancel_all_jobs_and_check_engine_idle();
		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_voltage_threshold_counter_update_and_reset_ch1()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;

	uint8_t asic_id = 0;
	uint32_t vol_val = 0;
	uint32_t status = 0;
	uint32_t threshold_value = 0;
	uint8_t read_counter = 0;
	uint32_t vs_ctrl_reg_org_val = 0, vs_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH1 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_val= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xC000FFFF;
			threshold_value = status | (vol_val << 16);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if(((status>>8) & 0xFF)>= read_counter )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x VS CH0 threshold counter value got updated\n",b,asic_id, status);
					break;
				}

				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH1 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH1 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

			if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
			
		}

		ret=cancel_all_jobs_and_check_engine_idle();
		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}
		
	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}




int test_effbst_voltage_threshold_counter_update_and_reset_ch1()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t vol_val = 0;
	uint32_t status = 0;
	uint32_t threshold_value = 0, vs_thrs_cnt;
	uint8_t read_counter = 0;
	uint32_t vs_ctrl_reg_org_val = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH1 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_val= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xC000FFFF;
			threshold_value = status |  (vol_val << 16);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if(((status>>8) & 0xFF)>= read_counter )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x VS CH0 threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH1 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH1 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

			if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n",b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status[b][asic_id]: %d\n", b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);

		}

		ret=cancel_all_jobs_and_check_engine_idle();
		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_thermal_threshold_variation_and_counter_update()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;
	uint8_t trip_read_counter = 0;

	uint8_t asic_id = 0;
	uint32_t status;
	uint32_t temp_val = 0;
	uint32_t threshold_value = 0;
	uint32_t tunecode_reg_org_val=0, ts_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		temp_val = bzm_params.therm_threshold;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;


						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		trip_read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5
		ts_thrs_cnt = trip_read_counter << 16; // to be written in LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT to store count before trip

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			thermal_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming TS threshold count = %d\n",trip_read_counter);
			status = status & 0xFF00FFFF;
			ts_thrs_cnt = trip_read_counter << 16 | status;
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &ts_thrs_cnt);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			temp_val= bzm_params.normal_temp - 0x20;	// lowering down thershold
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,status);
			tunecode_reg_org_val=status;
			status = status & 0xFFFFE001;
			threshold_value = status | (temp_val << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &threshold_value);		sleep(1);

			thermal_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>24) & 0xFF)!=0)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;

				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for TS readcount update. Expected=%d Readcounter= %d\n",b,asic_id,trip_read_counter, ((status>>24) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d TS ReadCount = %d\n",b,asic_id,((status>>24) & 0xFF));
			//setting threshold back to standard
			temp_val= bzm_params.therm_threshold;
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,status);
			status = status & 0xFFFFE001;
			threshold_value = status | (temp_val << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &threshold_value);

			timeout=20;
			// checking for theshold counter reset
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>24) & 0xFF)==0)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter turned 0\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for TS readcount update. Expected=0 Readcounter= %d\n",b,asic_id,((status>>24) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d TS ReadCount = %d\n",b,asic_id,((status>>24) & 0xFF));

		}

		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming TS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.therm_threshold, tunecode_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &tunecode_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_effbst_thermal_threshold_variation_and_counter_update()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;
	uint8_t trip_read_counter = 0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t status;
	uint32_t temp_val = 0;
	uint32_t threshold_value = 0;
	uint32_t tunecode_reg_org_val=0, ts_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		trip_read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5
		ts_thrs_cnt = trip_read_counter << 16; // to be written in LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT to store count before trip

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			thermal_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming TS threshold count = %d\n",trip_read_counter);
			status = status & 0xFF00FFFF;
			ts_thrs_cnt = trip_read_counter << 16 | status;
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &ts_thrs_cnt);
			temp_val= bzm_params.normal_temp - 0x20;	// lowering down thershold
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,status);
			tunecode_reg_org_val=status;
			status = status & 0xFFFFE001;
			threshold_value = status | (temp_val << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &threshold_value);		sleep(1);
			thermal_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if ((status&0xFF000000)!=0)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;

				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for TS readcount update. Expected=%d Readcounter= %d\n",b,asic_id,trip_read_counter, ((status>>24) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d TS ReadCount = %d\n",b,asic_id,((status>>24) & 0xFF));

			//setting threshold back to standard
			temp_val= bzm_params.therm_threshold;
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_TEMPSERSOR_TUNECODE=0x%x\n",b,asic_id,status);
			status = status & 0xFFFFE001;
			threshold_value = status | (temp_val << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &threshold_value);

			timeout=20;
			// checking for theshold counter reset
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if ((status&0xFF000000)==0)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter turned 0\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for TS readcount update. Expected=0 Readcounter= %d\n",b,asic_id,((status>>24) & 0xFF));
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d TS ReadCount = %d\n",b,asic_id,((status>>24) & 0xFF));

		}

		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming TS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.therm_threshold, tunecode_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_TEMPSERSOR_TUNECODE, 4, &tunecode_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}



int test_voltage_threshold_variation_and_counter_update_ch0()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t asic_id = 0;
	uint32_t vol_value = 0;
	uint32_t status = 0;
	uint8_t read_counter = 0;
	uint32_t threshold_value;
	uint32_t vs_ctrl_reg_org_val = 0, vs_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			voltage_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH0 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_value= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xFFFF8001;
			threshold_value = status | (vol_value << 1) ;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if(((status>>8) & 0xFF)!=0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH0 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH0 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

			//setting threshold back to standard
			vol_value= bzm_params.vol_threshold;
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);

			status = status & 0xFFFF8001;
			threshold_value = status | (vol_value << 1) ;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			timeout=20;
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if(((status>>8) & 0xFF)==0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter turned 0\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for VS readcount update.\n",b,asic_id);
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH0 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

		}

		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}






int test_effbst_voltage_threshold_variation_and_counter_update_ch0()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t vol_value = 0;
	uint32_t status = 0;
	uint32_t threshold_value = 0;
	uint8_t read_counter = 0;
	uint32_t vs_ctrl_reg_org_val=0, vs_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	uint32_t timeout = bzm_params.sw_timeout;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b,asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH0 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_value= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xFFFF8001;
			threshold_value = status | (vol_value << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);
			uint32_t timeout=20;
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)!=0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH0 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH0 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

			//setting threshold back to standard
			vol_value= bzm_params.vol_threshold;
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);

			status = status & 0xFFFF8001;
			threshold_value = status | (vol_value << 1);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			timeout=20;
			while (1){
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)==0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH0_TS_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH0 VS readcount update. Expected=0 ReadValue=%d\n",b,asic_id,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH0 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

		}

		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}



int test_voltage_threshold_variation_and_counter_update_ch1()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t asic_id = 0;
	uint32_t vol_val = 0;
	uint32_t status = 0;
	uint8_t read_counter = 0;
	uint32_t threshold_value;
	uint32_t vs_ctrl_reg_org_val = 0, vs_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);


	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	bzm_params.cfg.jobcnt=1;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,false,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		bzm_params.sw_timeout = timeout * 2;


		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b,asic_id,false);
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH1 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_val= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xC000FFFF;
			threshold_value = status | (vol_val << 16);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b,asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)!=0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH1 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;

					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH1 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));


			//setting threshold back to standard
			vol_val= bzm_params.vol_threshold;
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);

			status = status & 0xC000FFFF;
			threshold_value = status |  (vol_val << 16);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)==0)
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH1 VS readcount update. Expected=0 ReadValue=%d\n",b,asic_id,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH1 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

		}

		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}
		
	}
END:

	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_effbst_voltage_threshold_variation_and_counter_update_ch1()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t vol_val = 0;
	uint32_t status = 0;
	uint8_t read_counter = 0;
	uint32_t threshold_value = 0;
	uint32_t vs_ctrl_reg_org_val = 0, vs_thrs_cnt;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	uint32_t timeout = bzm_params.sw_timeout;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}


		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.sw_timeout = timeout * 2;

		asic_id = rand()%bzm_params.cfg.asiccount;
		read_counter = rand()%10 + 5; // considering counter value max 15 and lowest as 5

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			voltage_sensor_enable(b, asic_id,false);

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);

			rand_log(LOG_INFO, "Programming CH1 VS threshold count = %d\n",read_counter);
			status = status & 0xFFFFFF00;
			vs_thrs_cnt = read_counter | status;

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &vs_thrs_cnt);
			vol_val= bzm_params.normal_vol - 0x40;

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);
			vs_ctrl_reg_org_val = status;
			status = status & 0xC000FFFF;
			threshold_value = status | (vol_val << 16);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			voltage_sensor_enable(b, asic_id,true);

			uint32_t timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)!=0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH1 VS readcount update. Expected=%d ReadValue=%d\n",b,asic_id,read_counter,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH1 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

			//setting threshold back to standard
			vol_val= bzm_params.vol_threshold;
			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &status);
			rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_CTL=0x%x\n",b,asic_id,status);

			status = status & 0xC000FFFF;
			threshold_value = status | (vol_val << 16);

			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &threshold_value);

			timeout=20;
			while (1)
			{
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status));
				else
					uart_command_readreg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT, 4, &status);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x\n",b,asic_id,status);
				if (((status>>8) & 0xFF)==0 )
				{
					ret = SUCCESS;
					rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VS_CH1_CH2_SENSOR_THRS_CNT=0x%x threshold counter value got updated\n",b,asic_id, status);
					break;
				}
				sleep(1);
				timeout--;
				if(timeout==0)
				{
					rand_log(LOG_ERROR, "[ERROR] - b:%d a:%d Timeout occured waiting for CH1 VS readcount update. Expected=0 ReadValue=%d\n",b,asic_id,((status>>8) & 0xFF) );
					ret=FAILURE;
					goto END;
				}
			}
			rand_log(LOG_INFO,"b:%d a:%d CH1 VS ReadCount = %d\n",b,asic_id,((status>>8) & 0xFF));

		}

		ret=cancel_all_jobs_and_check_engine_idle();

		if(ret)
			break;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			rand_log(LOG_INFO, "Programming VS threshold back to original value = 0x%x. reg write value=0x%x\n",bzm_params.vol_threshold, vs_ctrl_reg_org_val);
			uart_command_writereg(bzm_params.uart_dev, b, asic_id, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_CTL, 4, &vs_ctrl_reg_org_val);
		}
		
	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_vs_continous_conversion_read_inbetween_jobprocessing()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t backdoor_vol_val = 0;
	bzm_params.vs_cont_conv_mode=1;
	//uint32_t backdoor_temp_val = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	initialize_voltage_thermal_thershold_and_resolution();
	enable_voltage_sensor(bzm_params.cfg.vs_clk_div, bzm_params.vol_resolution, CONVERSION_MODE, bzm_params.vol_threshold, 0);
	backdoor_vol_val = bzm_params.vol_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		//bzm_params.cfg.idle_time = 5;

		wait_for_backdoor_prog_normal_temp_volt();
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		asic_id = rand() % bzm_params.cfg.asiccount;
		backdoor_vol_val = bzm_params.vol_threshold + 0x40;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program voltage backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_vol_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());


			if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status: %d\n",b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status: %d\n", b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);


		}
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;

	}

	END:

	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}


int test_vs_onetime_conversion_read_inbetween_jobprocessing()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t asic_id = 0;
	uint32_t backdoor_vol_val = 0;
	//uint32_t backdoor_temp_val = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	bzm_params.vs_cont_conv_mode=0;
	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		bzm_params.cfg.idle_time = 10;
	bzm_params.cfg.jobcnt=1;
	initialize_voltage_thermal_thershold_and_resolution();
	enable_voltage_sensor(bzm_params.cfg.vs_clk_div, bzm_params.vol_resolution, CONVERSION_MODE, bzm_params.vol_threshold, 0);
	backdoor_vol_val = bzm_params.vol_threshold;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		//bzm_params.cfg.idle_time = 5;

		wait_for_backdoor_prog_normal_temp_volt();
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		asic_id = rand() % bzm_params.cfg.asiccount;
		backdoor_vol_val = bzm_params.vol_threshold + 0x40;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			voltage_sensor_enable(b,asic_id,false);
			applog(LOG_INFO,"System entering idle for %d s, for board %d asic_id: %d program voltage backdoor with value : 0x%x\n",bzm_params.cfg.idle_time, b, asic_id, backdoor_vol_val);
			sleep(bzm_params.cfg.idle_time);
			applog(LOG_INFO,"Exiting sleep\n");
			applog(LOG_INFO,"\nEnd Time = %s: \n\n",get_datetime());
			voltage_sensor_enable(b,asic_id,true);

			sleep(bzm_params.cfg.idle_time);

			if(bzm_params.vol_shutdown_status[b][asic_id] != 1)
			{
				rand_log(LOG_ERROR,"[ERROR] voltage shutdown not triggered for b:%d a:%d \n value in bzm_params.vol_shutdown_status: %d\n",b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);
				ret = FAILURE;
				goto END;
			}
			else
				rand_log(LOG_INFO," Voltage shutdown for b:%d, a:%d value in bzm_params.vol_shutdown_status: %d\n", b, asic_id, bzm_params.vol_shutdown_status[b][asic_id]);

		}
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;

	}

	END:

	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}


int test_tdm_jobsubmit_update_tdmgapcnt_dts_disable()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		bzm_params.sensor_tdm_gap_cnt = rand()%64;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				/*  ******* Programming the counter ****** */
				//Diable DTS
				uint32_t ctl = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

				//Enable DTS
				ctl = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_effbst_jobsubmit_update_tdmgapcnt_with_dts_disable()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;


	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;



	uint32_t timeout = bzm_params.sw_timeout;
	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		bzm_params.sensor_tdm_gap_cnt = rand()%64;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				/*  ******* Programming the counter ****** */
				//Diable DTS
				uint32_t ctl = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

				//Enable DTS
				ctl = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.sw_timeout = timeout * 2;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}

int test_tdm_jobsubmit_update_tdmgapcnt_onfly()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		bzm_params.sensor_tdm_gap_cnt = rand()%64;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				/*  ******* Programming the counter ****** */

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_effbst_jobsubmit_update_tdmgapcnt_onfly()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;



	uint32_t timeout = bzm_params.sw_timeout;
	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		bzm_params.sensor_tdm_gap_cnt = rand()%64;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				/*  ******* Programming the counter ****** */

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.sw_timeout = timeout * 2;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}


int test_tdm_jobsubmit_different_tdmgapcnt()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				bzm_params.sensor_tdm_gap_cnt = rand()%64;
				/*  ******* Programming the counter ****** */
				//Diable DTS
				uint32_t ctl = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

				//Enable DTS
				ctl = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);


				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}
int test_tdm_effbst_without_jobsubmit_update_tdmgapcnt_with_dts_disable()
{
	int ret =  SUCCESS;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	if(bzm_params.cfg.idle_time==1000)
		bzm_params.cfg.idle_time=1;

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		bzm_params.sensor_tdm_gap_cnt = rand()%64;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				/*  ******* Programming the counter ****** */
				//Diable DTS
				uint32_t ctl = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

				//Enable DTS
				ctl = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);


			}
		}
		sleep(bzm_params.cfg.idle_time);

	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}

int test_tdm_without_jobsubmit_update_tdmgapcnt_onfly()
{

	int ret = SUCCESS;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		bzm_params.sensor_tdm_gap_cnt = rand()%64;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				/*  ******* Programming the counter ****** */

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);


			}
		}
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_without_jobsubmit_update_tdmgapcnt_in_ascen_descn_order()
{

	int ret = SUCCESS;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				if ( ( l&1 ) != 1 )  { //If even loop then in ascending order
					bzm_params.sensor_tdm_gap_cnt = (a+1) % 63;
				} else {
					bzm_params.sensor_tdm_gap_cnt = a % 63;
					bzm_params.sensor_tdm_gap_cnt = 63 - bzm_params.sensor_tdm_gap_cnt;
				}

				/*  ******* Programming the counter ****** */
				//Diable DTS
				uint32_t ctl = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

				//Enable DTS
				ctl = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

			}
		}
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_update_tdmgapcnt_with_readreg()
{

	int ret = SUCCESS;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.sensor_tdm_gap_cnt_en = true;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				if ( ( l&1 ) != 1 )  { //If even loop then in ascending order
					bzm_params.sensor_tdm_gap_cnt = (a+1) % 63;
				} else {
					bzm_params.sensor_tdm_gap_cnt = a % 63;
					bzm_params.sensor_tdm_gap_cnt = 63 - bzm_params.sensor_tdm_gap_cnt;
				}

				/*  ******* Programming the counter ****** */
				//Diable DTS
				uint32_t ctl = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);

				// Program tdm gap count
				uint32_t thrs_cnt_val = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val);
				uint32_t thrs_cnt_val_read;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &thrs_cnt_val_read);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,thrs_cnt_val_read);

				//Enable DTS
				ctl = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &ctl);
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						engine_register_dump(b,a,r,c);
					}
				}
			}
		}
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_thermal_sensor_clk_div_variation()
{
	int ret =  SUCCESS;
	uint8_t seq_id=0;


	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	uint32_t timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				uint32_t div_index = rand() % bzm_params.no_of_sensor_clkdiv;
				uint32_t clk_div = bzm_params.sensor_clkdiv_list[div_index];

				uint32_t status1, status2;

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status1));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status1);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS before clk update =0x%x\n",b,a,status1);

				thermal_sensor_clk_update(b, a, clk_div);
				sleep(1);

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status2));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS, 4, &status2);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_THERMAL_SENSOR_TEMPCODE_STS after clk update =0x%x\n",b,a,status2);

				if(status1 != status2)
				{
					rand_log(LOG_INFO, "[ERROR] - Temperature data before and after clock setting is not same. Before=0x%x. After=0x%x\n", status1, status2);
					ret=FAILURE;
					goto END;
				}
			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		if(ret)
			break;

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		bzm_params.sw_timeout = timeout * 2;
		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}

int test_voltage_sensor_clk_div_variation()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;

		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				uint32_t div_index = rand() % bzm_params.no_of_sensor_clkdiv;
				uint32_t clk_div = bzm_params.sensor_clkdiv_list[div_index];
				uint32_t ch0_status1, ch0_status2, ch1_status1, ch1_status2;

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_STATUS, 4, &ch0_status1));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_STATUS, 4, &ch0_status1);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_STATUS before clk change=0x%x\n",b,a,ch0_status1);

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS, 4, &ch1_status1));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS, 4, &ch1_status1);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS before clk change=0x%x\n",b,a,ch1_status1);

				voltage_sensor_clk_update(b, a, clk_div);

				sleep(1);

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_STATUS, 4, &ch0_status2));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_VOLTAGE_SENSOR_STATUS, 4, &ch0_status2);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_VOLTAGE_SENSOR_STATUS after clk change=0x%x\n",b,a,ch0_status2);

				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS, 4, &ch1_status2));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS, 4, &ch1_status2);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_CH1_CH2_VOLTAGE_SENSOR_STATUS after clk change=0x%x\n",b,a,ch1_status2);


				if(ch0_status1 != ch0_status2)
				{
					rand_log(LOG_INFO, "[ERROR] - CH0 VS data before and after clock setting is not same. Before=0x%x. After=0x%x\n", ch0_status1, ch0_status2);
					ret=FAILURE;
					goto END;
				}
				if(ch1_status1 != ch1_status2)
				{
					rand_log(LOG_INFO, "[ERROR] - CH1 VS data before and after clock setting is not same. Before=0x%x. After=0x%x\n", ch1_status1, ch1_status2);
					ret=FAILURE;
					goto END;
				}
			}
		}
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		if(ret) //If initial vol val != second vol val
			break;

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;


		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;


	}
	END:
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

int test_sensor_clk_div_below4mhz()
{
	uint8_t ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;


		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				uint32_t clk_div = 14;

				thermal_sensor_clk_update(b, a, clk_div);

			}
		}

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		if(ret)
			break;
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;

		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;


		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;


	}
	END:
	wait_for_backdoor_prog_normal_temp_volt();
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}



int test_effbst_tdm_engine_recovery_with_alternate_tce()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint8_t value = 0;

	uint32_t effbst_data_index=0;
	uint32_t timeout;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	effbst_data_index = bzm_params.effbst_data_index ;


	//if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
	//      bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if((ret=enable_effbst()))
		return ret;

	timeout = bzm_params.sw_timeout;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		//second stage of code
		bzm_params.tce_selected = ODD_TCE;
		rand_log(LOG_INFO,"Testing JOBS with Enable even TCE 0 and keep odd TCE 1 off\n");
		value=(1<<EFFBST_ENABLE_BITPOS) | 2 | (1<<4);

JOB_SUBMIT:
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			asic_soft_reset(b,BROADCAST_ASIC);
			sleep(1);

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				engine_config(b, a, value);
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t readvalue=0;
						uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue);
						rand_log(LOG_INFO, "b:%d a:%d c:%d r:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , readvalue);
						if(readvalue!=value)
						{
							ret= ERR_READVALUE_MISMATCH;
							rand_log(LOG_ERROR, "[ERROR] -ENGINE_REG_CONFIG not updated. Write value=0x%x, readvalue=0x%x\n",value,readvalue);

							goto END;
						}
					}
				}
			}
		}

		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;

		bzm_params.effbst_data_index = effbst_data_index;
		bzm_params.effbst_exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_1TCE_EFFBST;
		bzm_params.sw_timeout = timeout*2;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

		if (bzm_params.tce_selected == ODD_TCE)
		{
			bzm_params.tce_selected = EVEN_TCE;
			rand_log(LOG_INFO,"Testing JOBS with Enable Odd TCE 1 and keep even TCE 0 off\n");
			value=(1<<EFFBST_ENABLE_BITPOS) | 1 | (1<<4);
			goto JOB_SUBMIT;
		}

	}
END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;


}


int test_uart_bist_write_reg(void)
{
	int ret=SUCCESS;
	uint32_t value=0, readvalue=0;
	uint32_t b=0,a=0;
	uint32_t offset=0;

	char input[50];
	char *endptr;

	printf("\nEnter Board and Asic number for write : ");
	fgets(input, sizeof input, stdin);

	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);

	printf("\nEnter Write offset in hex : ");
	fgets(input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);

	readvalue=0;
	if(bzm_params.tdm_enabled ==true)
	{
		uart_enable_tmd(bzm_params.uart_dev,b, true);
		uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, offset, 4, &readvalue);
	}
	else
		uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, offset, 4, &readvalue);
	applog(LOG_INFO,"\nValue read before write in [b:%d][a:%d][offset:0x%x] = 0x%x\n",b,a,offset,readvalue);


	printf("\nEnter Write value in hex : ");
	fgets(input, sizeof input, stdin);
	value= (uint32_t)strtoul(input, NULL, 16);
	printf("value = 0x%x\n",value);

	uart_command_writereg(bzm_params.uart_dev, b, a,UART_BIST_ACCESS , offset, 4, &value);

	readvalue=0;
	if(bzm_params.tdm_enabled==true)
	{
		uart_enable_tmd(bzm_params.uart_dev,b, true);
		uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, offset, 4, &readvalue);
	}
	else
		uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, offset, 4, &readvalue);

	applog(LOG_INFO,"Value read after write in [b:%d][a:%d][offset:0x%x] = 0x%x\n",b,a,offset,readvalue);
	if(readvalue!=value)
	{
		applog(LOG_ERROR, "[ERROR] - Value not written. Expected=0x%x ReadValue=0x%x\n",value,readvalue);
		ret=ERR_READVALUE_MISMATCH;
	}

	return ret;
}

int test_uart_bist_read_reg(void)
{
	uint32_t value=0;
	uint32_t b=0,a=0;
	uint32_t offset=0;

	char input[50];
	char *endptr;

	printf("\nEnter Board and Asic ID for read : ");
	fgets(input, sizeof input, stdin);
	b = (uint32_t)strtoul(input, &endptr, 10);
	a = (uint32_t)strtoul(endptr, &endptr, 10);

	printf("\nEnter Read offset in hex : ");
	fgets(input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);


	if(bzm_params.tdm_enabled==true)
	{
		uart_enable_tmd(bzm_params.uart_dev,b, true);
		uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, offset, 4, &value);
	}
	else
		uart_command_readreg(bzm_params.uart_dev, b, a, UART_BIST_ACCESS, offset, 4, &value);

	applog(LOG_INFO,"Value read in [b:%d][a:%d][offset:0x%x] = 0x%x\n",b,a,offset,value);

	return SUCCESS;
}


#endif

int test_sanity_check()
{
	int ret = FAILURE;

	rand_log(LOG_INFO," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	/************************ asic reset *************************/
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
		if(b==bzm_params.cfg.boardcount)
			break;
		bzm_params.board_exist[b] = detect_board(b);
		if (bzm_params.board_exist[b] == 1)
		{
			rand_log(LOG_INFO,"Board %d exist\n",b);

			if((ret=asic_global_reset(b,false)))
				return ret;
		}
	}


	/************************** test noop *********************/

	if(bzm_params.cfg.sw_prg_asic_id)
		ret=sw_prog_asic_discovery();
	else
		ret=asic_discovery();

	//	ret = asic_id_init_and_discovery();
	if(ret)
	{
		rand_log(LOG_ERROR,"[ERROR] - noop failed and asic not found\n");
		ret=ERR_NO_ASIC_FOUND;
		goto END;
	}
	/************************** read-engine_status *********************/
	ret = check_all_engine_status(bzm_params.sw_timeout*10);
	if(ret)
		goto END;


	/************************** read thermal data *********************/
	END:

	rand_log(LOG_INFO," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_end_successful()
{
	int ret=SUCCESS;
	char buf[3];
	uint32_t asic_per_board[BOARD_PER_DEVICE];
	uint32_t asic_cnt=0;


	rand_log(LOG_INFO," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	/************************ test noop *************************/
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		asic_per_board[b]=0;
		rand_log(LOG_INFO, "Finding asic in board %d..\n",b);
		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{

			memset(buf, '\0', 3);
			ret=uart_command_noop(bzm_params.uart_dev, b, a, buf);
			if(ret)
			{
				rand_log(LOG_INFO, "NOOP Response of [b:%d] [a:%d] = %c %c %c\n", b, a, buf[0], buf[1], buf[2]);

				if(strncmp(buf,bzm_params.expected_noop_resp,3) == 0)
				{
					asic_cnt++;
					asic_per_board[b]++;
				}
			}

		}
		rand_log(LOG_INFO,"\n\nNo. of asic found in [b:%d] = %d\n\n",b,asic_per_board[b]);
	}
	if(asic_cnt==0)
	{
		rand_log(LOG_ERROR,"[ERROR] - No asic found\n");
		ret=ERR_NO_ASIC_FOUND;
		goto END;
	}
	else
	{
		rand_log(LOG_INFO,"Total no. of asic found = %d\n\n",asic_cnt);
		ret=SUCCESS;
	}
	/************************** read-engine_status *********************/
	ret = check_all_engine_status(bzm_params.sw_timeout*10);
	if(ret)
		goto END;

	END:

	rand_log(LOG_INFO," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_pll_lock_stress(void)
{
	int ret = FAILURE;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	if(bzm_params.cfg.vdd_hash!=0)
	{
		if((ret=set_vddhash_voltage(bzm_params.cfg.vdd_hash)))
		{
			rand_log(LOG_ERROR,"[ERROR] - set_vddhash_voltage failed\n");
			return ret;
		}
	}

	//rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

	if(bzm_params.cfg.edm_pll_mode==EDM_PLL_MODE_PARALLEL)
	{
		if((ret = enable_edm_pll_parallel_mode(bzm_params.cfg.fastclk,false))) //reconfigure = false , as configuring pll 1st time in init
		{
			rand_log(LOG_ERROR,"[ERROR] - enable_edm_pll_parallel_mode failed\n");
			goto FAIL;
		}


		// read lock bit 5 times

		for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
		{
			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
				if(bzm_params.board_exist[b] == 0)
					continue;

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					uint32_t value=0;
					if(bzm_params.tdm_enabled)
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a,NOTCH_REG, EDM_PLL_ENABLE_REG,4, &value));
					else
						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_ENABLE_REG,4, &value);
					rand_log(LOG_INFO, "EDM_PLL_ENABLE_REG [b:%d[[a:%d]= 0x%x\n",b, a, value);
					if(!((value>>2) & 0x1))
					{
						rand_log(LOG_ERROR,"[ERROR] - PLL Lock bit got reset\n");
						bzm_params.pll_locked = false;												
						ret = FAILURE;
					}


				}
			}
		}
	}
	else
	{
		uint32_t edm_pll_g_divider;
		//edm_pll_g_divider = (bzm_params.cfg.fastclk*1000000)/(bzm_params.refclk*bzm_params.cfg.edm_pll_pre_scalar);
		edm_pll_g_divider = ((bzm_params.cfg.fastclk*1000000)*bzm_params.cfg.edm_pll_pre_scalar)/bzm_params.refclk;

		if((ret = enable_edm_pll_serial_mode(edm_pll_g_divider, bzm_params.cfg.edm_pll_pre_scalar, false))) //reconfigure = false , as configuring pll 1st time in init
		{
			rand_log(LOG_ERROR,"[ERROR] - enable_edm_pll_serial_mode failed\n");
			goto FAIL;
		}
		// read lock bit 5 times
		for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
		{

			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {
				if(bzm_params.board_exist[b] == 0)
					continue;

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++) {
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					uint32_t value=0;
					if(bzm_params.tdm_enabled)
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a,NOTCH_REG, EDM_PLL_ENABLE_REG,4, &value));
					else
						uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, EDM_PLL_ENABLE_REG,4, &value);
					rand_log(LOG_INFO, "EDM_PLL_ENABLE_REG [b:%d[[a:%d]= 0x%x\n",b, a, value);
					if(!((value>>2) & 0x1))
					{
						rand_log(LOG_ERROR,"[ERROR] - PLL Lock bit got reset\n");                                                                                                    bzm_params.pll_locked = false;                                                                       
						ret = FAILURE;
					}


				}
			}
		}

	}
	FAIL:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;

}    

int test_effbst_tdm_canceljob_with_writejob()
{
        int ret=SUCCESS;

        rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

        uint32_t mode0_result=0 ,mode2_result=0,mode3_result=0;

        initialize_board(1, 0);

        if((ret=enable_effbst()))
                goto END;


        mode0_result = load_and_cancel_job(CANCEL_PENDING_JOB, false, true);
        rand_log(LOG_INFO,"CANCEL_PENDING_JOB - Mode0 Result=%d \n",mode0_result);

        usleep(2000);
        mode2_result = load_and_cancel_job(CANCEL_CUR_PENDING_JOB,false, true);
        rand_log(LOG_INFO,"CANCEL_CUR_PENDING_JOB - Mode2 Result=%d \n",mode2_result);

        usleep(2000);
        mode3_result = load_and_cancel_job(CANCEL_CURRENT_JOB,false, true);
        rand_log(LOG_INFO,"CANCEL_CURRENT_JOB - Mode3 Result=%d \n",mode3_result);

        rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

        if( (mode0_result == 0) && (mode2_result == 0) && (mode3_result == 0) )
        {
                ret= SUCCESS;
        }
        else
        {
                ret= ERR_CANCELJOB_MODE_FAILURE;
        }

        END:
        return ret;
}

int test_effbst_tdm_jobsubmit_with_both_tce_disabled_and_enabled_with_canceljob()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t cfgvalue = 0;
	uint32_t job_control_value = 0;
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	bzm_params.cfg.jobcnt=2;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;
			cfgvalue = 0x3 ;

			uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_CONFIG, 1, &cfgvalue);	// disable both engine

			bzm_params.exp_noncecnt=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);		// submit 1st job
			cfgvalue = 0x1;
			uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_CONFIG, 1, &cfgvalue);	// enable both engine
			job_control_value = 0x2;
			uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_JOB_CONTROL, 1, &job_control_value);	// Cancel submitted job

			if(bzm_params.cfg.jobcnt==2)
			{

				seq_id+=subjobcnt;
				bzm_params.exp_noncecnt=effbst_write_bch_data(false, false, true, b, BROADCAST_ASIC,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);		//submit 2nd job
				seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		clear_jobdone_status_counters();

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

	}

END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_both_tce_disabled_and_enabled_back()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	//uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t subjobcnt=1;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	//bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	//get_next_effbst_data_index();

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	bzm_params.cfg.jobcnt=2;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		//enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	//uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	//if((ret=enable_effbst()))
	//	goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						//uint32_t cfgvalue = 0x3 | (1<<EFFBST_ENABLE_BITPOS);
						uint32_t cfgvalue = 0x3 ;
						rand_log(LOG_INFO, "Clock gating both TCE\n");
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &cfgvalue);

						uint8_t readvalue=0;
						if(bzm_params.tdm_enabled)
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue));
						else
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue);
						rand_log(LOG_INFO, "ENGINE_REG_CONFIG value = 0x%x \n",readvalue);


						rand_log(LOG_INFO, "Submitting first job\n");
						//bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);		// submit 1st job
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						//sleep(5);
						//sleep(bzm_params.cfg.idle_time);

						if(bzm_params.tdm_enabled)
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_STATUS, 1, &readvalue));
						else
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_STATUS, 1, &readvalue);
						rand_log(LOG_INFO, "ENGINE_REG_STATUS value = 0x%x \n",readvalue);


						//cfgvalue = 0x0|(1<<EFFBST_ENABLE_BITPOS);
						cfgvalue = 0x0;
						rand_log(LOG_INFO, "Clock ungating both TCE\n");
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &cfgvalue);

						readvalue=0;
						if(bzm_params.tdm_enabled)
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue));
						else
							uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue);
						rand_log(LOG_INFO, "ENGINE_REG_CONFIG value = 0x%x \n",readvalue);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							rand_log(LOG_INFO, "Submitting second job\n");
							//bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);		//submit 2nd job
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		bzm_params.exp_noncecnt=0;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);
		bzm_params.poll_eng_idle=true;
		bzm_params.sw_timeout_expected=true;
		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;
		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

	}

//END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_tdm_dts_disable()
{

	int ret = SUCCESS;
	uint32_t control=0,status=0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	if(bzm_params.cfg.idle_time == 1000)
		bzm_params.cfg.idle_time=1;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
				continue;
			if(bzm_params.cfg.enable_dts_callback == true)
			{
				rand_log(LOG_INFO,"b:%d a:%d Disabling DTS packet in LOCAL_REG_UART_TX..\n",b,a);
				control = 0x7;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);
			}

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &status);

			rand_log(LOG_INFO,"LOCAL_REG_UART_TX[b:%d][a:%d] = 0x%x\n",b,a,status);

			rand_log(LOG_INFO, "Sleeping for %d secs\n",bzm_params.cfg.idle_time);
			sleep(bzm_params.cfg.idle_time);

			if(bzm_params.cfg.enable_dts_callback == true)
			{
				rand_log(LOG_INFO,"b:%d a:%d Disabling DTS packet in LOCAL_REG_UART_TX..\n",b,a);
				control = 0xF;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &control);
			}

			if(bzm_params.tdm_enabled)
				while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &status));
			else
				uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_UART_TX, 4, &status);

			rand_log(LOG_INFO,"LOCAL_REG_UART_TX[b:%d][a:%d] = 0x%x\n",b,a,status);
		}
	}

	return ret;
}



int test_clockgate()
{
	int ret = SUCCESS;
	uint8_t seq_id=0; //nikhil
	uint32_t a=0, b=0;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
		bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);

	uint32_t value = 0;

	for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
	{
		for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
			if (bzm_params.engine_exist[b][a][r][c] == 0)
				continue;

			uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
			value = (value | (1<<3)) & (value & ~(1<<1)) & (value & ~(1<<0));

			uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
		}
	}

	for (b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if(bzm_params.cfg.idle_time==1000)
		bzm_params.cfg.idle_time=1;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		ret=submitjob_getresults_allengines(seq_id,bzm_params.static_data_index);
		if(ret)
			break;
		seq_id++;

		rand_log(LOG_INFO,"\n************* Sleeping for %d seconds, Manual signal check is required *******\n",bzm_params.cfg.idle_time);
		sleep(bzm_params.cfg.idle_time);

		ret=submitjob_getresults_allengines(seq_id,bzm_params.static_data_index);
		if(ret)
			break;
		seq_id++;
	}
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}



int test_effbst_clockgate()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t value = 0;
	uint32_t effbst_data_index=0;
	uint32_t a=0, b=0;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	effbst_data_index = bzm_params.effbst_data_index ;

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if((ret=enable_effbst()))
		return ret;

	for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
	{
		for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
			if (bzm_params.engine_exist[b][a][r][c] == 0)
				continue;

			uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
			value = (value | (1<<3)) & (value & ~(1<<1)) & (value & ~(1<<0));

			uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
		}
	}

	if(bzm_params.cfg.idle_time==1000)
		bzm_params.cfg.idle_time=1;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		effbst_data_index = bzm_params.effbst_data_index ;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

		rand_log(LOG_INFO,"\n************* Sleeping for %d seconds, Manual signal check is required *******\n",bzm_params.cfg.idle_time);
		sleep(bzm_params.cfg.idle_time);

		bzm_params.effbst_data_index = effbst_data_index;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

	}
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}

int test_tce_clockgate()
{
	int ret = SUCCESS;
	uint8_t seq_id=0; //nikhil
	uint32_t a=0, b=0;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	if((bzm_params.cfg.nonce_count==1) && (bzm_params.cfg.nonce_range!=NONCE_RANGE_DEFAULT))
		bzm_params.cfg.nonce_range = NONCE_RANGE_DEFAULT;

	initialize_board(1, 0);

	uint32_t value = 0;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if(bzm_params.cfg.idle_time==1000)
		bzm_params.cfg.idle_time=1;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		ret=submitjob_getresults_allengines(seq_id,bzm_params.static_data_index);
		if(ret)
			break;
		seq_id++;

		for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
		{
			for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
				if (bzm_params.engine_exist[b][a][r][c] == 0)
					continue;

				uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
				value = (value & ~(1<<1)) & (value & ~(1<<0));

				uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
			}
		}

		rand_log(LOG_INFO,"\n************* Sleeping for %d seconds, Manual signal check is required *******\n",bzm_params.cfg.idle_time);
		sleep(bzm_params.cfg.idle_time);

		ret=submitjob_getresults_allengines(seq_id,bzm_params.static_data_index);
		if(ret)
			break;
		seq_id++;
	}
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}



int test_tce_effbst_clockgate()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t value = 0;
	uint32_t effbst_data_index=0;
	uint32_t a=0, b=0;
	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();
	effbst_data_index = bzm_params.effbst_data_index ;

	initialize_board(1, 0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	if((ret=enable_effbst()))
		return ret;

	if(bzm_params.cfg.idle_time==1000)
		bzm_params.cfg.idle_time=1;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		effbst_data_index = bzm_params.effbst_data_index ;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

		for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
		{
			for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++) {
				if (bzm_params.engine_exist[b][a][r][c] == 0)
					continue;

				uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
				value = (value & ~(1<<1)) & (value & ~(1<<0));

				uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &value);
			}
		}

		rand_log(LOG_INFO,"\n************* Sleeping for %d seconds, Manual signal check is required *******\n",bzm_params.cfg.idle_time);
		sleep(bzm_params.cfg.idle_time);

		bzm_params.effbst_data_index = effbst_data_index;
		ret=effbst_submitjob_getresults_allengines(seq_id,bzm_params.effbst_data_index);
		if(ret)
			break;
		seq_id+=bzm_params.effbst_max_subjobs;

	}
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);
	return ret;
}



int test_tdm_max_delay_for_all_asic()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t tdm_delay[4] = {1, 4, 8, 15};

	uint32_t value = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();


	for(uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t asic = 0; asic < ASIC_PER_BOARD; asic++)
		{
			if(bzm_params.asic_exist[b][asic] == 0)
				continue;
			if(asic<=3)
			{
				uart_command_writereg(bzm_params.uart_dev, b,asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay[asic]);
				if(bzm_params.tdm_enabled)
				{
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);

				}
				else
				{
					uart_command_readreg(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);
				}

			}
			else
			{
				uart_command_writereg(bzm_params.uart_dev, b,asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay[3]);
				if(bzm_params.tdm_enabled)
				{
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);

				}
				else
				{
					uart_command_readreg(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);
				}
			}
		}
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}





	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		//tdm_delay = rand()%3; //delay counter value to beprogrammed 2bit data
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_max_delay_for_all_asic()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t tdm_delay[4] = {1, 4, 8, 15};
	uint32_t value = 0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);



	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t asic = 0; asic < ASIC_PER_BOARD; asic++)
		{
			if(bzm_params.asic_exist[b][asic] == 0)
				continue;
			if(asic<=3)
			{
				uart_command_writereg(bzm_params.uart_dev, b,asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay[asic]);
				if(bzm_params.tdm_enabled)
				{
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);

				}
				else
				{
					uart_command_readreg(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);
				}

			}
			else
			{
				uart_command_writereg(bzm_params.uart_dev, b,asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay[3]);
				if(bzm_params.tdm_enabled)
				{
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);

				}
				else
				{
					uart_command_readreg(bzm_params.uart_dev, b, asic, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);
					rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, asic, value);
				}
			}
		}
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}




	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}




int test_tdm_delay_sensgapcnt_variation_for_all_asic()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t tdm_delay;
	uint32_t value = 0;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.tdm_divider_value=150;
	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();



	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for(uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				tdm_delay = rand()%15+1;
				bzm_params.sensor_tdm_gap_cnt = rand()%64;
				rand_log(LOG_INFO, "Programming tdm_delay=%d sensor_tdm_gap_cnt=%d for b:%d a:%d\n", tdm_delay,bzm_params.sensor_tdm_gap_cnt, b, a);
				uart_command_writereg(bzm_params.uart_dev, b,a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay);
				value=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));

				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);

				rand_log(LOG_INFO, "b:%d a:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, a, value);

				// Program tdm gap count
				uint32_t tdm_gap_cnt = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &tdm_gap_cnt);
				value=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &value));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &value);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,value);

			}
			enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
		}

		//tdm_delay = rand()%3; //delay counter value to beprogrammed 2bit data
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id++;
							bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r,seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							seq_id--;
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;

		bzm_params.job_submit = bzm_params.engine_count;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. Job JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}
		ret|= verify_noncecollected(true);
		if(ret)
			break;
		disable_tdm();

	}

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_delay_sensgapcnt_variation_for_all_asic()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t tdm_delay;
	uint32_t value = 0;


	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	bzm_params.tdm_divider_value=150;
	initialize_board(1, 0);


	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();




	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for(uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
				tdm_delay = rand()%15+1;
				bzm_params.sensor_tdm_gap_cnt = rand()%64;
				rand_log(LOG_INFO, "Programming tdm_delay=%d sensor_tdm_gap_cnt=%d for b:%d a:%d\n", tdm_delay,bzm_params.sensor_tdm_gap_cnt, b, a);
				uart_command_writereg(bzm_params.uart_dev, b,a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &tdm_delay);
				value=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value));

				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &value);

				rand_log(LOG_INFO, "board:%d asic:%d LOCAL_REG_TDM_DELAY:0x%x\n", b, a, value);

				// Program tdm gap count
				uint32_t tdm_gap_cnt = bzm_params.sensor_tdm_gap_cnt;
				uart_command_writereg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &tdm_gap_cnt);
				value=0;
				if(bzm_params.tdm_enabled)
					while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &value));
				else
					uart_command_readreg(bzm_params.uart_dev, b, a, NOTCH_REG, LOCAL_REG_SENS_TDM_GAP_CNT, 4, &value);
				rand_log(LOG_INFO,"b:%d a:%d LOCAL_REG_SENS_TDM_GAP_CNT=0x%x\n",b,a,value);

			}
			enable_tdm(true,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
		}


		uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
		disable_tdm();
	}

	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl2()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.exp_noncecnt+=effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						bzm_params.exp_noncecnt+=effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						canceljob_mode=0x2;
						rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);
						
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	//uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	bzm_params.cfg.jobcnt=2;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						bzm_params.exp_noncecnt+=effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						bzm_params.exp_noncecnt+=effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						//canceljob_mode=0x2;
						//rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						//uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);
						
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						if(bzm_params.cfg.jobcnt==2)
						{
							//seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
							seq_id+=subjobcnt;
						}

					}
				//}
			}
		}

		//seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_writejobcmd_canceljob_dummy_job_ctl3()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	//uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	bzm_params.cfg.jobcnt=2;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		bzm_params.set_job_ctl3=true;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, 0,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, 0,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						sleep(1);
						//canceljob_mode=0x2;
						//rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						//uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);
						
						bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 3);
						seq_id+=subjobcnt;
						if(bzm_params.cfg.jobcnt==2)
						{
							//seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 1);
							//seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
							seq_id+=subjobcnt;
						}

					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_engine_broadcastwrite()
{

	int ret = SUCCESS;
	uint8_t value=0,readvalue=0;
	uint32_t offset=0;
	char input[50];


	rand_log(LOG_INFO, "\nEnter Engine Write offset in hex : ");
	fgets(input, sizeof input, stdin);
	offset= (uint32_t)strtoul(input, NULL, 16);


	rand_log(LOG_INFO, "\nEnter 1byte write value in hex : ");
	fgets(input, sizeof input, stdin);
	value= (uint32_t)strtoul(input, NULL, 16);



	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;

		uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, offset, 1, &value);
		rand_log(LOG_INFO, "Write Complete. Reading the values from all engines..\n");

		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
				continue;

			//uart_command_multicast_write(bzm_params.uart_dev, b, a, BROADCAST_ENGINE, offset, 1, &value);
			//rand_log(LOG_INFO, "Write Complete. Reading the values from all engines..\n");

			for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
			{
				for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
				{
					if (bzm_params.engine_exist[b][a][r][c] == 0)
						continue;

					readvalue=0;
					if(bzm_params.tdm_enabled)
						ret=uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, offset, 1, &readvalue);
					else
						ret=uart_command_readreg(bzm_params.uart_dev, b, a, (c << 6) | r, offset, 1, &readvalue);

					rand_log(LOG_INFO,"Value read after write in [b:%d][a:%d][r:%d][c:%d][offset:0x%x] = 0x%x\n",b,a,r,c,offset,readvalue);
					if(readvalue!=value)
					{
						rand_log(LOG_ERROR,"[ERROR] - Write and read value mismatch for [b:%d][a:%d][r:%d][c:%d][offset:0x%x]. Expected= 0x%x. Value read=0x%x\n",b,a,r,c,offset,value,readvalue);
						ret=ERR_READVALUE_MISMATCH;
						return ret;
					}
				}
			}
		}
	}
	return SUCCESS;
}

int test_effbst_tdm_jobsubmit_with_multicastwrite_and_disable_1tce()
{


	int ret = SUCCESS;
	uint8_t seq_id=0;
	uint32_t default_timeout;
	uint32_t value =0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;

	default_timeout = bzm_params.sw_timeout;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (int jobcnt_loop=1; jobcnt_loop<=bzm_params.cfg.jobcnt; jobcnt_loop++)
		{
			for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
			{
				if(bzm_params.board_exist[b] == 0)
					continue;

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;
#if 0
					for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
						{
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];
							if(bzm_params.engine_exist[b][a][r][c] == 0)
								continue;

							bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id+=subjobcnt;
							if(jobcnt_loop==2)
								//bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
								seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */

							break; /* break column loop since job sent to all columns */
						}
					//}
				}
			}
		}
		ret = cancel_all_jobs_and_check_engine_idle();
		if(ret)
			break;



		bzm_params.tce_selected = EVEN_TCE;

		rand_log(LOG_INFO,"Testing JOBS with Enable Odd TCE 1 and keep even TCE 0 off\n");
		value=(1<<EFFBST_ENABLE_BITPOS) | 1;
		bzm_params.effbst_exp_nonce_minus_value = EXP_NONCE_MINUS_VALUE_1TCE_EFFBST;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;
			//asic_soft_reset(b,BROADCAST_ASIC);
			//sleep(1);
			uint32_t sleeptime=60; /*5 secs */
			uint32_t loopcnt = (bzm_params.jobprocessingtime)/sleeptime;
			bool usleep_enable=false;
			if(loopcnt==0)
			{
				usleep_enable=true;
				sleeptime = (bzm_params.jobprocessingtime_us);
				loopcnt=1;
			}
			rand_log(LOG_INFO, "loop cnt to wait for expected job done = %d sleeptime=%d\n",loopcnt,sleeptime);

			for (uint32_t loop = 0; loop <= loopcnt; loop++)
			{
				if(usleep_enable)
					usleep(sleeptime);
				else
					sleep(sleeptime);
				rand_log(LOG_INFO, "Sleep time Loop=%d\n",loop);
			}

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				uart_command_multicast_write(bzm_params.uart_dev, b, a, BROADCAST_ENGINE, ENGINE_REG_CONFIG, 1, &value);

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t readvalue=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_CONFIG, 1, &readvalue));
						rand_log(LOG_INFO, "b:%d a:%d c:%d r:%d ENGINE_REG_CONFIG value = 0x%x \n",b ,a, c, r , readvalue);
						if(readvalue!=value)
						{
							ret= ERR_READVALUE_MISMATCH;
							rand_log(LOG_ERROR, "[ERROR] -ENGINE_REG_CONFIG not updated. Write value=0x%x, readvalue=0x%x\n",value,readvalue);

							goto END;
						}
					}
				}
			}

		}
		bzm_params.exp_noncecnt=0;
		bzm_params.sw_timeout = default_timeout*2;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(true, false, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
						break; /* break column loop since job sent to all columns */
					}
				}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			//break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_selectable_leadingzeros_b2b()
{
	uint32_t bch_data_index = bzm_params.cfg.bch_data_index%32;
	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint8_t value = 0;
	bzm_params.leadingzeros_to_find =32 + bch_data_index;

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);
	bzm_params.verify_nonce_received=false;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}

	bzm_params.leadingzeros_enabled=true;
	bzm_params.cfg.jobcnt=2;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
						rand_log(LOG_INFO,"\nJOB1: Find ZEROS  = %d\n",bzm_params.leadingzeros_to_find);

						value=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
						rand_log(LOG_INFO,"\nValue of ENGINE_REG_ZEROS_TO_FIND = %d\n",value);
						if(value!=wrvalue)
						{
							ret= ERR_READVALUE_MISMATCH;
							goto END;
						}

						bzm_params.exp_noncecnt+=leadingzeros_write_bch_data(false,false,false,true, b, a, c, r, seq_id,bch_data_index,bzm_params.cfg.timestampcount);
						bzm_params.job_submit++;
						bch_data_index++;
						seq_id++;
					    if(bzm_params.cfg.jobcnt==2)
						{
					    	bzm_params.leadingzeros_to_find++;
							if(bzm_params.leadingzeros_to_find >= MAX_LEADING_ZEROS )
							{
								bzm_params.leadingzeros_to_find = MIN_LEADING_ZEROS;
								bch_data_index=0;
							}
					    	wrvalue=bzm_params.leadingzeros_to_find - 32;

							uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
							rand_log(LOG_INFO,"\nJOB2: Find ZEROS  = %d\n",bzm_params.leadingzeros_to_find);

							value=0;
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
							rand_log(LOG_INFO,"\nValue of ENGINE_REG_ZEROS_TO_FIND = %d\n",value);
							if(value!=wrvalue)
							{
								ret= ERR_READVALUE_MISMATCH;
								goto END;
							}
							bzm_params.exp_noncecnt+=leadingzeros_write_bch_data(false,false,false,true, b, a, c, r, seq_id,bch_data_index,bzm_params.cfg.timestampcount);
							bzm_params.job_submit++;
							bch_data_index++;
							seq_id--;
						}
						bzm_params.leadingzeros_to_find++;
						if(bzm_params.leadingzeros_to_find >= MAX_LEADING_ZEROS )
						{
							bzm_params.leadingzeros_to_find = MIN_LEADING_ZEROS;
							bch_data_index=0;
						}

					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		if(ret)
			break;

		ret|= verify_noncecollected(true);
		if(ret)
			break;
		if(bzm_params.hw_sha256_fail)
		{
			rand_log(LOG_ERROR, "SHA FAILURE COUNT = %d\n",bzm_params.hw_sha256_fail);
			ret=ERR_SHA_FAILURE;
			break;
		}

	}



	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}



int test_effbst_tdm_selectable_leadingzeros_b2b()
{
	int ret = SUCCESS;
	uint8_t seq_id=0;

	//uint32_t skip_leading0s[14] = {43, 44, 45, 46, 47, 48, 49, 50, 51, 59, 60, 61, 62, 63}; //vector not available for the list

	uint8_t value = 0;
	bzm_params.leadingzeros_to_find = 32;

	bzm_params.cfg.nonce_count=MAX_NONCE-1; // setting it -1 to go into while loop in get_next_effbst_data_index

	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.leadingzeros_enabled=true;

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}


	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);
	if((ret=enable_effbst()))
		goto END;

	bzm_params.cfg.jobcnt=2;
	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
						rand_log(LOG_INFO,"\nJOB1: Find ZEROS  = %d\n",bzm_params.leadingzeros_to_find);

						value=0;
						while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
						rand_log(LOG_INFO,"\nValue of ENGINE_REG_ZEROS_TO_FIND = %d\n",value);
						if(value!=wrvalue)
						{
							ret= ERR_READVALUE_MISMATCH;
							goto END;
						}
						bzm_params.effbst_index_leading0s[bzm_params.effbst_data_index]=bzm_params.leadingzeros_to_find;
						uint32_t exp_noncecnt=0;
						exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=exp_noncecnt;
						seq_id+=bzm_params.effbst_max_subjobs;
						if(bzm_params.cfg.jobcnt==2)
						{
							uint8_t wrvalue=bzm_params.leadingzeros_to_find - 32;

							uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &wrvalue);
							rand_log(LOG_INFO,"\nJOB2: Find ZEROS  = %d\n",bzm_params.leadingzeros_to_find);

							value=0;
							while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_ZEROS_TO_FIND, 1, &value));
							rand_log(LOG_INFO,"\nValue of ENGINE_REG_ZEROS_TO_FIND = %d\n",value);
							if(value!=wrvalue)
							{
								ret= ERR_READVALUE_MISMATCH;
								goto END;
							}
							bzm_params.effbst_index_leading0s[bzm_params.effbst_data_index]=bzm_params.leadingzeros_to_find;
							exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=exp_noncecnt;
							seq_id-=bzm_params.effbst_max_subjobs;
						}
						rand_log(LOG_INFO, "Leading 0s=%d Expected Nonce count= %d\n",bzm_params.leadingzeros_to_find-1,exp_noncecnt);
						if(exp_noncecnt==0)
						{
							rand_log(LOG_ERROR, "[ERROR] - Job not found for %d leading 0s\n",bzm_params.leadingzeros_to_find);
							goto END;

						}



					}
				}
			}
		}
		seq_id+=bzm_params.effbst_max_subjobs;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*bzm_params.effbst_max_subjobs;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		if(ret)
			break;
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
		if(ret)
			break;
#if 1
		ret|= verify_noncecollected(true);
		if(ret)
			break;
		if(bzm_params.hw_sha256_fail)
		{
			rand_log(LOG_ERROR, "SHA FAILURE COUNT = %d\n",bzm_params.hw_sha256_fail);
			ret=ERR_SHA_FAILURE;
			break;
		}
#endif
	}

	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;
}

int test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence1()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	bzm_params.cfg.jobcnt=2;
	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						canceljob_mode=0x2;
						rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);

						seq_id+=subjobcnt;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
//		if(ret)
//			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

//		if(ret)
//			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence2()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	bzm_params.cfg.jobcnt=2;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						if(bzm_params.cfg.jobcnt==2)
						{
							//seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */

						}

					}
				//}
			}
		}

		//seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
//		if(ret)
//			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

//		if(ret)
//			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence3()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	//uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	bzm_params.cfg.jobcnt=2;
	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, 0,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						effbst_write_bch_data_dummy(false, true, false, b, a,c,r, seq_id, 0,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						sleep(1);

						bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 3);
						seq_id+=subjobcnt;
						if(bzm_params.cfg.jobcnt==2)
						{
							//seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 1);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */

						}

					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
//		if(ret)
//			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
//		if(ret)
//			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence4()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	//uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	bzm_params.cfg.jobcnt=2;
	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

								uint32_t r = 0,c=0,err=0;
								init_engine_stack(b,a);
								while(1)
								{
								err=get_next_engine_for_jobsubmit(b,a);
								if(err)
								break;
								r=bzm_params.next_r[b][a];
								c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						if(l==0)

						{
							//write_bch_data_dummy(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							write_bch_data_dummy(false,true,false,true, b, a, c, r, 0xa,bzm_params.static_data_index,0);
							//seq_id++;
							//write_bch_data_dummy(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
							write_bch_data_dummy(false,true,false,true, b, a, c, r, 0xb,bzm_params.static_data_index,0);
							//seq_id++;
							sleep(2);


						}
						uint8_t canceljob_mode=0x2;
						rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);

						write_bch_data_dummy(false,true,false,false, b, a, c, r, 0xc,bzm_params.static_data_index,0);

						//bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 3);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							//bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 1);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
//		if(ret)
//			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

//		if(ret)
//			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence5()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	bzm_params.cfg.jobcnt=2;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						write_bch_data_dummy(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						seq_id++;
						write_bch_data_dummy(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						seq_id++;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						if(bzm_params.cfg.jobcnt==2)
						{
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id++;
						}

					}
				//}
			}
		}

		//seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
//		if(ret)
//			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

//		if(ret)
//			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_effbst_tdm_jobsubmit_with_writejobcmd_dummy_jobs_testsequence6()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	//uint8_t canceljob_mode = 0;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	bzm_params.cfg.jobcnt=2;
	if((ret=enable_effbst()))
		goto END;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif
						uint32_t r = 0,c=0,err=0;
						init_engine_stack(b,a);
						while(1)
						{
						err=get_next_engine_for_jobsubmit(b,a);
						if(err)
						break;
						r=bzm_params.next_r[b][a];
						c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						write_bch_data_dummy(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						seq_id++;
						write_bch_data_dummy(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						seq_id++;
						sleep(1);
						bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 3);
						seq_id+=subjobcnt;
						if(bzm_params.cfg.jobcnt==2)
						{
							bzm_params.exp_noncecnt+=effbst_write_bch_data_ver2(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount, 1);
							seq_id++;

						}

					}
				//}
			}
		}

		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
//		if(ret)
//			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);
//		if(ret)
//			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_disable_enable_many_engines()
{


	int ret = SUCCESS;

	uint8_t seq_id=0;


	//int disable_seq_id =1;
	uint32_t engine_disabled[BOARD_PER_DEVICE][ASIC_PER_BOARD][ENGINE_ROW_PER_ASIC][ENGINE_COLUMN_PER_ASIC];
	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint32_t exp_jobs_for_disabled_eng = 0;
	uint32_t exp_jobs_per_engine=0;
	uint32_t count = 0;
	uint32_t value=0;



	rand_log(LOG_DEBUG,"*** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1,0);

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++) {

		if (bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,BROADCAST_ASIC,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	bzm_params.effbst_data_index = bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);

		bzm_params.collected_noncecnt=0;bzm_params.job_submit=0;bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();
		srand(bzm_params.cfg.seed_id + rand());
		count=0;exp_jobs_for_disabled_eng=0;

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					uint32_t samerow=0;
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						engine_disabled[b][a][r][c]=0;

						if (rand()%10 <=1)
						{
							engine_disabled[b][a][r][c]=1;
							rand_log(LOG_INFO, "Disabling engine id with b:%d a:%d r:%d c:%d\n", b, a, r, c );
							uint32_t engine_offset = 0x80;
							uint32_t row_offset = (r) << 1;
							uint32_t col_offset = 0; //MSB of Column
							if(samerow==0)
								value=0;
							value |= (1<<c);
							samerow++;

							engine_offset = engine_offset | row_offset | col_offset;
							uart_command_writereg(bzm_params.uart_dev, b,a,NOTCH_REG,engine_offset,4,&value);
							count++;
						}

						exp_jobs_per_engine=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						bzm_params.exp_noncecnt+= exp_jobs_per_engine;

						if(engine_disabled[b][a][r][c])
						{
							bzm_params.exp_noncecnt-=exp_jobs_per_engine;

							if(exp_jobs_per_engine>4)
								exp_jobs_for_disabled_eng+=4;
							else
								exp_jobs_for_disabled_eng+= exp_jobs_per_engine;

						}


					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt;
		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		//bzm_params.exp_noncecnt = bzm_params.exp_noncecnt - exp_jobs_for_disabled_eng;
		bzm_params.exp_jobdone_sts_cnt = (bzm_params.job_submit/bzm_params.subjobcnt)-count;


		rand_log(LOG_INFO, "JOB_SUBMITTED=%d EXPECTED_NONCE_COUNT = %d\n",bzm_params.job_submit,bzm_params.exp_noncecnt);


		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
		if(ret)
			break;

		if((bzm_params.job_submit/bzm_params.subjobcnt==1) && (bzm_params.engine_count==1))
		{

			bzm_params.poll_eng_idle=true;
			ret=check_all_engine_status(bzm_params.sw_timeout);
			if(ret)
				break;
		}


		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break;
		}

		bzm_params.collected_noncecnt=0;
		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if (bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
					continue;
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					uint32_t samerow=0;
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if (bzm_params.engine_exist[b][a][r][c] == 0)
							continue;
						if(engine_disabled[b][a][r][c])
						{
							rand_log(LOG_INFO, "Enabling engine id with b:%d a:%d r:%d c:%d\n",  b,a,r,c);

							if(samerow==0)
							{
								uint32_t engine_offset = 0x80;
								uint32_t row_offset = (r) << 1;
								uint32_t col_offset = 0; //MSB of Column
								value = 0;
								engine_offset = engine_offset | row_offset | col_offset;
								uart_command_writereg(bzm_params.uart_dev, b,a,NOTCH_REG,engine_offset,4,&value);
								samerow=1;
							}

						}

					}
				}
			}
		}

		//sleep(1);

		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout);
		if(ret)
			break;

		sleep(10);

		rand_log(LOG_INFO,"JOB_DONE after enabling engines = %d\n",bzm_params.collected_noncecnt);

		if(bzm_params.collected_noncecnt != exp_jobs_for_disabled_eng)
		{

				rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",exp_jobs_for_disabled_eng, bzm_params.collected_noncecnt);
				ret|= ERR_NONCE_CNT_MISMATCH;
				break;


		}

	}
	END:
	rand_log(LOG_DEBUG,"*** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}


int test_effbst_tdm_cancelcurrentjob()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;

	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;
	uint8_t canceljob_mode = 2;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id+=subjobcnt;
						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
						seq_id-=subjobcnt;

						if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
							sleep(10);
						else
							sleep(bzm_params.cfg.idle_time);

						canceljob_mode=0x2;
						rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);


					}
				}
			}
		}



		seq_id+=subjobcnt;  /* updating seq id for next iteration */


		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout);



		if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
			sleep(10);
		else
			sleep(bzm_params.cfg.idle_time);

		bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, 0, 0,0,0, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

		if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
			sleep(10);
		else
			sleep(bzm_params.cfg.idle_time);
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_tdm_cancel_current_and_pending_job()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	uint8_t canceljob_mode = 2;
	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,true,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
	}



	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();


		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						seq_id++;
						bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, b, a, c, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						//seq_id--;
						if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
							sleep(10);
						else
							sleep(bzm_params.cfg.idle_time);

						canceljob_mode=0x2;
						rand_log(LOG_INFO, "writing job control for b:%d a:%d r:%d c:%d  using writereg with value : 0x%x\n",b, a, r, c, canceljob_mode);
						uart_command_writereg(bzm_params.uart_dev, b, a, (c << 6) | r, ENGINE_REG_JOB_CONTROL, 1, &canceljob_mode);


					}
				}
			}
		}



		seq_id++;  /* updating seq id for next iteration */


		bzm_params.poll_eng_idle=true;
		ret=check_all_engine_status(bzm_params.sw_timeout);

		if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
			sleep(10);
		else
			sleep(bzm_params.cfg.idle_time);
		bzm_params.exp_noncecnt+=write_bch_data(false,true,false,true, 0, 0, 0, 0, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);
		if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
			sleep(10);
		else
			sleep(bzm_params.cfg.idle_time);

	}


	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_effbst_tdm_engine_config_regread_during_job()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	//rand_log(LOG_INFO, "**** Config reg read at the beginning of test****\n");
	//read_engine_configreg();

	initialize_board(0, 1);
	bzm_params.use_multicast_for_eng_config_wr=false;

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		//asic_soft_reset(b,BROADCAST_ASIC);
		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if(bzm_params.asic_exist[b][a] == 0)
				continue;
			asic_soft_reset(b,a);
		}
		//sleep(1);
	}


	//if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
	//	sleep(10);
	//else
	//	sleep(bzm_params.cfg.idle_time);



	rand_log(LOG_INFO, "**** Config reg read before BIST ****\n");
	//read_engine_configreg();
	read_engine_reg(ENGINE_REG_END_NONCE+1, 1);





	bzm_params.bist_mode = BIST_UNICAST_MODE;
	uint32_t bist_job_count = 1;
	uint32_t eng_cnt = 1;

	rand_log(LOG_INFO, "***** Unicast BIST testing ****\n");

	uint32_t val = 0x0;
	uart_command_writereg(bzm_params.uart_dev, 0, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &val);


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;

		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if (bzm_params.asic_exist[b][a] == 0)
				continue;


			for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
			{
				for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
				{
					if (bzm_params.engine_exist[b][a][r][c] == 0)
						continue;
					// first argument => job_count : 1 to 10
					rand_log(LOG_INFO," bist_job_count = %d\n", bist_job_count);
					ret = bist_internal_pattern(bist_job_count,a,r,r,c,c,eng_cnt);
					if(ret)
						break;
				}
			}
			if(ret) // break from Asic loop if fail
				break;
		}
		if(ret) // break from Board loop if fail
			break;
	}

	if(ret)
		goto END;



	uint32_t control=0;

	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		uart_flush(bzm_params.uart_dev,b);
		control = 0;
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_ENABLE_REG, 4, &control);

		control=1;
		//BIST Result FSM Status and Control for FRF0
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, UART_BIST_ACCESS, BIST_RESULT_FSM_CTL, 4, &control);

	}

	rand_log(LOG_INFO, "**** going to do engine reset ****\n");
	//read_engine_configreg();
	//read_engine_reg(ENGINE_REG_END_NONCE, 1);




	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		//asic_soft_reset(b,BROADCAST_ASIC);
		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if(bzm_params.asic_exist[b][a] == 0)
				continue;
			asic_soft_reset(b,a);
		}

	}

#if 0
	rand_log(LOG_INFO,"before bist status read\n");
	if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
		sleep(10);
	else
		sleep(bzm_params.cfg.idle_time);
	if(bzm_params.tdm_enabled)
		while(!uart_command_readreg_tdm_sync(bzm_params.uart_dev, 0, 0, UART_BIST_ACCESS, BIST_STATUS_REG, 4, &val));
	else
		uart_command_readreg(bzm_params.uart_dev, 0, 0, UART_BIST_ACCESS, BIST_STATUS_REG, 4, &val);
	rand_log(LOG_INFO,"\n**********  BIST STATUS REGISTER is 0x%x ****\n",val);




	sleep(2);
#endif

	uart_command_readreg(bzm_params.uart_dev, 0, 0, NOTCH_REG, LOCAL_REG_TDM_DELAY, 4, &val);
	rand_log(LOG_INFO, "LOCAL_REG_TDM_DELAY:0x%x\n",val);

//	rand_log(LOG_INFO, "*** Config reg read after BIST after reset ***\n");
//	read_engine_configreg();

	//if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
	//	sleep(10);
	//else
	//	sleep(bzm_params.cfg.idle_time);

	//rand_log(LOG_INFO, "**** Config reg read after BIST ****\n");
		//read_engine_configreg();
	read_engine_reg(ENGINE_REG_END_NONCE+1, 1);
	read_engine_reg(ENGINE_REG_END_NONCE+1, 1);
	return ret;

	if((ret=enable_effbst()))
		goto END;

	//rand_log(LOG_INFO, "*** Config reg read after Asic Boost Enable ***\n");
	//read_engine_configreg();
	//rand_log(LOG_INFO, "*** Config reg re-read after Asic Boost Enable ***\n");
	//read_engine_configreg();

	//return ret;

	control = bzm_params.cfg.job_done_status_en<<JOB_DONE_STATUS_ENABLE_BITPOS;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		uart_command_writereg(bzm_params.uart_dev, b, BROADCAST_ASIC, NOTCH_REG, LOCAL_REG_RESULT_STS_CTL, 4, &control);
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	//read_engine_configreg();
	//read_engine_configreg();

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for(uint32_t i=0;i<bzm_params.cfg.jobcnt;i++)
			{

				for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
				{
					if(bzm_params.asic_exist[b][a] == 0)
						continue;

					for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
						{
							if(bzm_params.engine_exist[b][a][r][c] == 0)
								continue;

							if(i==0)
							{
								bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							}

							if(i==1)
							{
								seq_id+=subjobcnt;
								bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
								seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
							}

						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		if(bzm_params.cfg.idle_time == IDLE_TIME_DEFAULT)
			sleep(10);
		else
			sleep(bzm_params.cfg.idle_time);

		//read_engine_configreg();
		rand_log(LOG_INFO, "**** Config reg read after BIST ****\n");
			//read_engine_configreg();
		read_engine_reg(ENGINE_REG_END_NONCE+1, 1);

		return ret;

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}



int test_non_effbst_job_in_effbstmode()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;


	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();
	bzm_params.non_effbst_in_effbst=true;


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;


	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;

				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=write_bch_data_in_effbst(b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);
						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=write_bch_data_in_effbst(b, a,c,r, seq_id, bzm_params.static_data_index,bzm_params.cfg.timestampcount);

							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;
		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;


		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt < bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:
	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}





int test_effbst_tdm_jobsubmit_with_jobcontrol1_for_all_subjobs()
{

	int ret = SUCCESS;
	uint8_t seq_id=0;



	uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);


	initialize_board(1, 0);

	bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
	get_next_effbst_data_index();


	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if(bzm_params.board_exist[b] == 0)
			continue;
		enable_tdm(true,false,b,bzm_params.tdm_divider_value,NULL);
	}

	uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_callback, &bzm_params.collected_noncecnt);

	if((ret=enable_effbst()))
		goto END;
	bzm_params.effbst_set_jc_for_all_subjobs=true;

	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);
		bzm_params.job_submit = 0;bzm_params.collected_noncecnt = 0; bzm_params.exp_noncecnt=0;
		clear_jobdone_status_counters();

		for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
		{
			if(bzm_params.board_exist[b] == 0)
				continue;

			for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
			{
				if(bzm_params.asic_exist[b][a] == 0)
					continue;
#if 0
				for (uint32_t r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					for (uint32_t c = 0; c < ENGINE_COLUMN_PER_ASIC; c++)
					{
#endif

							uint32_t r = 0,c=0,err=0;
							init_engine_stack(b,a);
							while(1)
							{
							err=get_next_engine_for_jobsubmit(b,a);
							if(err)
							break;
							r=bzm_params.next_r[b][a];
							c=bzm_params.next_c[b][a];
						if(bzm_params.engine_exist[b][a][r][c] == 0)
							continue;

						bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,c,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}

					}
				//}
			}
		}
		seq_id+=bzm_params.cfg.jobcnt*subjobcnt;  /* updating seq id for next iteration */

		bzm_params.job_submit = bzm_params.engine_count*subjobcnt;
		if(bzm_params.cfg.jobcnt==2)
			bzm_params.job_submit *=2;
		bzm_params.exp_jobdone_sts_cnt = bzm_params.job_submit/bzm_params.subjobcnt;

		rand_log(LOG_INFO, "\nJOB_SUBMITTED: %d, EXPECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt);

		rand_log(LOG_INFO, "\nWait for TDM results....\n");
		ret=wait_for_tdm_results(bzm_params.job_submit,bzm_params.exp_noncecnt, &bzm_params.collected_noncecnt);
		rand_log(LOG_INFO,"JOB_SUBMITTED: %d,  EXPECTED_NONCE_COUNT: %d, COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);

		if(ret)
			break;
		bzm_params.poll_eng_idle=true;

		ret=check_all_engine_status(bzm_params.sw_timeout*bzm_params.cfg.jobcnt*2);

		if(ret)
			break;

		if(bzm_params.collected_noncecnt != bzm_params.exp_noncecnt)
		{
			rand_log(LOG_ERROR, "[ERROR] - Nonce Collected is not as expected. JOB_SUBMITTED: %d EXPECTED_NONCE_COUNT: %d. But COLLECTED_NONCE_COUNT: %d\n",bzm_params.job_submit, bzm_params.exp_noncecnt, bzm_params.collected_noncecnt);
			ret = ERR_NONCE_CNT_MISMATCH;
			break; /*breaking regression loop on failure */
		}

		ret |= verify_noncecollected(true);
		if(ret)
			break;
	}

	END:

	rand_log(LOG_DEBUG," *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	return ret;

}

int test_uart_open_close()
{



	for(uint32_t l=0; l < bzm_params.cfg.regression_count; l++)
	{
		rand_log(LOG_INFO,"\n************* %s - REGRESSION_COUNT == %d *******\n",__func__, l+1);


		uart_dev_close();
		sleep(1);
		rand_log(LOG_INFO,"Uart Init..\n");
		bzm_params.uart_dev = uart_init(bzm_params.default_baudrate,1);
		if(bzm_params.uart_dev==NULL)
		{

			rand_log(LOG_ERROR, "[ERROR] - Unable to open uart port..\n");
			rand_log(LOG_INFO, "[RESULT] - Uart port stuck\n");
			return ERR_UART_PORT_OPEN_FAIL;
		}

	}
	return SUCCESS;
}


int test_engine_broadcast_reset()
{
	for (uint32_t b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;

		asic_soft_reset(b, BROADCAST_ASIC);
	}
	return SUCCESS;
}



int test_asic_asic_delay_tdm_delay_calibrator()
{


	rand_log(LOG_DEBUG," *** [Function START] : File:%s, Function:%s, Line:%d  ***\n",__FILE__,__func__,__LINE__);

	uint8_t seq_id=0;
	int ret = SUCCESS;
	uint32_t total_active_asic = 0 ;
	uint32_t control = 0;
	uint32_t tdm_delay[ASIC_PER_BOARD];
	uint8_t tuned_asic[ASIC_PER_BOARD];
	uint32_t redo_tuningcnt=2;
	uint32_t timestamp=0;
	uint32_t jobcnt=1;
	uint32_t noncecnt_per_asic;
	uint32_t tdm_divider_value = 110;
	uint32_t loop=1;


        uint32_t subjobcnt=bzm_params.effbst_max_subjobs;

	timestamp = (jobcnt==2)?0:1;
	rand_log(LOG_INFO, "Timestamp: %d\n", timestamp);
	memset(tdm_delay,0, sizeof(tdm_delay));
	memset(tuned_asic,0x0, sizeof(uint8_t)*ASIC_PER_BOARD);

	bzm_params.start_asic = -1;
	bzm_params.total_pass_asic = 0;
	bzm_params.static_data_index =bzm_params.cfg.bch_data_index;
	get_next_static_data_index();
	bzm_params.cfg.nonce_count=1;

	for (int b = 0; b < BOARD_PER_DEVICE; b++)
	{
		if (bzm_params.board_exist[b] == 0)
			continue;
		for (uint32_t a = 0; a < ASIC_PER_BOARD; a++)
		{
			if(bzm_params.asic_exist[b][a] == 0)
				continue;
			tdm_delay[a] = 0;
			//tdm_delay[a] = 3;
		}

		while(1)
		{


			rand_log(LOG_INFO, "\n\n***************** Trial %d ***************\n",loop++);
			noncecnt_per_asic = jobcnt*(timestamp+1);
			rand_log(LOG_INFO, "noncecnt_per_asic: %d, jobcnt: %d, timestamp: %d\n", noncecnt_per_asic, jobcnt, timestamp);
			bzm_params.effbst_data_index =bzm_params.cfg.effbst_bch_data_index;
				get_next_effbst_data_index();

			initialize_board(1, 0);
			control = (jobcnt==2)?0x3:0x7;// 0x7; //only allow readreg and noop
			uart_command_writereg(bzm_params.uart_dev, 0, 0xFF, 0xfff, LOCAL_REG_UART_TX, 4, &control);
			bzm_params.start_asic = -1;
			bzm_params.total_pass_asic = 0 ;
			total_active_asic=0;
			control = 0;

			//Disable TDM
			//API_EnableTDM(false, false,b,tdm_divider_value,&bzm_params.collected_noncecnt);
			if(bzm_params.tdm_enabled)
				enable_tdm(false,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);

			enable_effbst();

			memset(bzm_params.success_callback_asic, 0, sizeof(bzm_params.success_callback_asic));

			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
				{
					continue;
				}
				total_active_asic++;
				//rand_log(LOG_INFO,"Asic:%d tdm_delay_value:%d\n",a,tdm_delay[a]);
				uart_command_writereg(bzm_params.uart_dev, b, a,0xFFF, LOCAL_REG_TDM_DELAY, 4,&tdm_delay[a]); //different delay?
				for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++)
				{
					if (bzm_params.engine_exist[b][a][r][0] == 0)
					{
						continue;
					}

					bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,0,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

                                       // if(bzm_params.cfg.jobcnt==2)
                                        //{
                                         //	seq_id+=subjobcnt;
                                           //     bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,0,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
                                             //   seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
                                        //}
				}
			}
			enable_tdm(true,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
			//API_EnableTDM(true, false,b,tdm_divider_value,&bzm_params.collected_noncecnt);
			uart_set_tmd_result_callback(bzm_params.uart_dev, effbst_tdm_result_calibrator_callback , &bzm_params.collected_noncecnt);
			//variable delay needed??


			enable_effbst();


			uint32_t job_control = 1;
			uart_command_multicast_write(bzm_params.uart_dev, b, BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_JOB_CONTROL, 1, &job_control);
			if(jobcnt==2)
			{
				rand_log(LOG_INFO, "Submitting 2nd job..\n");
				//seq_index=1;
				for (int a = 0; a < ASIC_PER_BOARD; a++)
				{
					if (bzm_params.asic_exist[b][a] == 0)
					{
						continue;
					}
					for (int r = 0; r < ENGINE_ROW_PER_ASIC; r++)
					{
						if (bzm_params.engine_exist[b][a][r][0] == 0)
						{
							continue;
						}
						//API_WriteBCHData(MultiCastWrite,true,AutoStart,b,a,0,r,seq_index,timestamp);
						//seq_id++;
						//bzm_params.exp_noncecnt+=write_bch_data(true,false,false,false, b, a, 0, r, seq_id,bzm_params.static_data_index,bzm_params.cfg.timestampcount);

					//	bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,0,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);

						if(bzm_params.cfg.jobcnt==2)
						{
							seq_id+=subjobcnt;
							bzm_params.exp_noncecnt+=effbst_write_bch_data(false, true, false, b, a,0,r, seq_id, bzm_params.effbst_data_index,bzm_params.cfg.timestampcount);
							seq_id-=subjobcnt;  /* subtracting back to use same seq ids for all engines */
						}
					}
				}


				uart_command_multicast_write(bzm_params.uart_dev, b,  BROADCAST_ASIC, BROADCAST_ENGINE, ENGINE_REG_JOB_CONTROL, 1, &job_control);


				control = 0x7; //start flush!
				uart_command_writereg(bzm_params.uart_dev, 0, 0xFF, 0xfff, LOCAL_REG_UART_TX, 4, &control);
			}
			sleep(2);

			//check for what is the last failure_asic
			//asic_soft_reset(0, 0xFF);
			//ret=asic_global_reset(b,false);
			//if(ret)
			//	return ret;
			//ret=engine_init(b);
			//if(ret)
			//	return ret;

			//initialize_board(1, 0);

			if(bzm_params.tdm_enabled)
				enable_tdm(false,false,b,bzm_params.tdm_divider_value,&bzm_params.collected_noncecnt);
			sleep(2);


			rand_log(LOG_INFO,"Start asic:%d\n",bzm_params.start_asic);
			rand_log(LOG_INFO,"Last Pass asic:%d\n",bzm_params.last_pass_asic);
			rand_log(LOG_INFO,"total active asic:%d\n",total_active_asic);
			rand_log(LOG_INFO,"total pass asic:%d\n",bzm_params.total_pass_asic);

			rand_log(LOG_INFO,"Failing asic:");
			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
				{
					continue;
				}

				if(bzm_params.success_callback_asic[a]==0)
				{
					rand_log(LOG_INFO,"%d ",a);
					tuned_asic[a]=0;
				}
			}
			rand_log(LOG_INFO,"\n");


			for (int a = 0; a < ASIC_PER_BOARD; a++)
			{
				if (bzm_params.asic_exist[b][a] == 0)
				{
					continue;
				}

                		rand_log(LOG_INFO," bzm_params.success_callback_asic[a]: %d, noncecnt_per_asic: %d\n", bzm_params.success_callback_asic[a], noncecnt_per_asic);

				if(bzm_params.success_callback_asic[a]==noncecnt_per_asic)
				{
					tuned_asic[a]=1;
					rand_log(LOG_INFO,"Asic %d tuned with value %d......\n",a,tdm_delay[a]);

				}
				else
					break;

			}


			if (bzm_params.total_pass_asic!=(total_active_asic*noncecnt_per_asic))
			{

				for (int a = 0; a < ASIC_PER_BOARD; a++)
				{
					// for (int a = ASIC_PER_BOARD-1; a >= 0; a--) {
					if (bzm_params.asic_exist[b][a] == 0)
					{
						continue;
					}

					if(tuned_asic[a]==0) //if not tuned
					{
						//if(tdm_delay[a] == 0)
						if(tdm_delay[a] == 0xF)
						{
							tdm_delay[a]=0xF;
							//tdm_delay[a]=0;

							if(bzm_params.success_callback_asic[a]!=0) //if tuned for 1 job and corrupted for 2nd job and reached max delay of 3
							{
								rand_log(LOG_INFO,"\nUnable to tune asic :%d with tdm delay %d. Continue tuning with next asic.. \n",a,tdm_delay[a]);
								continue;
							}
							else
								return 1;

							}
							else
							{
								//tdm_delay[a]-=1;
								tdm_delay[a]+=1;
								rand_log(LOG_INFO,"\nSet asic :%d tdm_delay:%d\n",a,tdm_delay[a]);
								break;
							}

						}

					}

				
			}
			else
			{

				for (int a = 0; a < ASIC_PER_BOARD; a++)
				{
					if (bzm_params.asic_exist[b][a] == 0)
					{
						continue;
					}
					rand_log(LOG_INFO,"Success_Callback asic :%d value:%d tdm_delay:%d\n",a,bzm_params.success_callback_asic[a],tdm_delay[a]);

				}
				rand_log(LOG_INFO,"ALL PASS for tdm div %d at trial %d !!!\n",tdm_divider_value,loop-1);
				timestamp=1;
				redo_tuningcnt--;
				if(redo_tuningcnt<=0)
					break;
			}
		}
	}

	rand_log(LOG_DEBUG,"%s: *** [Function END] : File:%s, Function:%s, Line:%d  ***\n",get_datetime(),__FILE__,__func__,__LINE__);
	return ret;
	
	}

